Index: utils.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n\tCopyright 2016 - 2019 Benjamin Vedder\tbenjamin@vedder.se\n\n\tThis file is part of the VESC firmware.\n\n\tThe VESC firmware is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The VESC firmware is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n    */\n\n#include \"utils.h\"\n#include \"ch.h\"\n#include \"hal.h\"\n#include \"app.h\"\n#include \"conf_general.h\"\n#include <math.h>\n#include <string.h>\n#include <stdlib.h>\n\n// Private variables\nstatic volatile int sys_lock_cnt = 0;\n\nvoid utils_step_towards(float *value, float goal, float step) {\n    if (*value < goal) {\n        if ((*value + step) < goal) {\n            *value += step;\n        } else {\n            *value = goal;\n        }\n    } else if (*value > goal) {\n        if ((*value - step) > goal) {\n            *value -= step;\n        } else {\n            *value = goal;\n        }\n    }\n}\n\nfloat utils_calc_ratio(float low, float high, float val) {\n\treturn (val - low) / (high - low);\n}\n\n/**\n * Make sure that 0 <= angle < 360\n *\n * @param angle\n * The angle to normalize.\n */\nvoid utils_norm_angle(float *angle) {\n\t*angle = fmodf(*angle, 360.0);\n\n\tif (*angle < 0.0) {\n\t\t*angle += 360.0;\n\t}\n}\n\n/**\n * Make sure that -pi <= angle < pi,\n *\n * TODO: Maybe use fmodf instead?\n *\n * @param angle\n * The angle to normalize in radians.\n * WARNING: Don't use too large angles.\n */\nvoid utils_norm_angle_rad(float *angle) {\n\twhile (*angle < -M_PI) {\n\t\t*angle += 2.0 * M_PI;\n\t}\n\n\twhile (*angle >  M_PI) {\n\t\t*angle -= 2.0 * M_PI;\n\t}\n}\n\nint utils_truncate_number(float *number, float min, float max) {\n\tint did_trunc = 0;\n\n\tif (*number > max) {\n\t\t*number = max;\n\t\tdid_trunc = 1;\n\t} else if (*number < min) {\n\t\t*number = min;\n\t\tdid_trunc = 1;\n\t}\n\n\treturn did_trunc;\n}\n\nint utils_truncate_number_int(int *number, int min, int max) {\n\tint did_trunc = 0;\n\n\tif (*number > max) {\n\t\t*number = max;\n\t\tdid_trunc = 1;\n\t} else if (*number < min) {\n\t\t*number = min;\n\t\tdid_trunc = 1;\n\t}\n\n\treturn did_trunc;\n}\n\nint utils_truncate_number_abs(float *number, float max) {\n\tint did_trunc = 0;\n\n\tif (*number > max) {\n\t\t*number = max;\n\t\tdid_trunc = 1;\n\t} else if (*number < -max) {\n\t\t*number = -max;\n\t\tdid_trunc = 1;\n\t}\n\n\treturn did_trunc;\n}\n\nfloat utils_map(float x, float in_min, float in_max, float out_min, float out_max) {\n\treturn (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;\n}\n\nint utils_map_int(int x, int in_min, int in_max, int out_min, int out_max) {\n\treturn (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;\n}\n\n/**\n * Truncate absolute values less than tres to zero. The value\n * tres will be mapped to 0 and the value max to max.\n */\nvoid utils_deadband(float *value, float tres, float max) {\n\tif (fabsf(*value) < tres) {\n\t\t*value = 0.0;\n\t} else {\n\t\tfloat k = max / (max - tres);\n\t\tif (*value > 0.0) {\n\t\t\t*value = k * *value + max * (1.0 - k);\n\t\t} else {\n\t\t\t*value = -(k * -*value + max * (1.0 - k));\n\t\t}\n\t}\n}\n\n/**\n * Get the difference between two angles. Will always be between -180 and +180 degrees.\n * @param angle1\n * The first angle\n * @param angle2\n * The second angle\n * @return\n * The difference between the angles\n */\nfloat utils_angle_difference(float angle1, float angle2) {\n//\tutils_norm_angle(&angle1);\n//\tutils_norm_angle(&angle2);\n//\n//\tif (fabsf(angle1 - angle2) > 180.0) {\n//\t\tif (angle1 < angle2) {\n//\t\t\tangle1 += 360.0;\n//\t\t} else {\n//\t\t\tangle2 += 360.0;\n//\t\t}\n//\t}\n//\n//\treturn angle1 - angle2;\n\n\t// Faster in most cases\n\tfloat difference = angle1 - angle2;\n\twhile (difference < -180.0) difference += 2.0 * 180.0;\n\twhile (difference > 180.0) difference -= 2.0 * 180.0;\n\treturn difference;\n}\n\n/**\n * Get the difference between two angles. Will always be between -pi and +pi radians.\n * @param angle1\n * The first angle in radians\n * @param angle2\n * The second angle in radians\n * @return\n * The difference between the angles in radians\n */\nfloat utils_angle_difference_rad(float angle1, float angle2) {\n\tfloat difference = angle1 - angle2;\n\twhile (difference < -M_PI) difference += 2.0 * M_PI;\n\twhile (difference > M_PI) difference -= 2.0 * M_PI;\n\treturn difference;\n}\n\n/**\n * Takes the average of a number of angles.\n *\n * @param angles\n * The angles in radians.\n *\n * @param angles_num\n * The number of angles.\n *\n * @param weights\n * The weight of the summarized angles\n *\n * @return\n * The average angle.\n */\nfloat utils_avg_angles_rad_fast(float *angles, float *weights, int angles_num) {\n\tfloat s_sum = 0.0;\n\tfloat c_sum = 0.0;\n\n\tfor (int i = 0; i < angles_num; i++) {\n\t\tfloat s, c;\n\t\tutils_fast_sincos_better(angles[i], &s, &c);\n\t\ts_sum += s * weights[i];\n\t\tc_sum += c * weights[i];\n\t}\n\n\treturn utils_fast_atan2(s_sum, c_sum);\n}\n\n/**\n * Get the middle value of three values\n *\n * @param a\n * First value\n *\n * @param b\n * Second value\n *\n * @param c\n * Third value\n *\n * @return\n * The middle value\n */\nfloat utils_middle_of_3(float a, float b, float c) {\n\tfloat middle;\n\n\tif ((a <= b) && (a <= c)) {\n\t\tmiddle = (b <= c) ? b : c;\n\t} else if ((b <= a) && (b <= c)) {\n\t\tmiddle = (a <= c) ? a : c;\n\t} else {\n\t\tmiddle = (a <= b) ? a : b;\n\t}\n\treturn middle;\n}\n\n/**\n * Get the middle value of three values\n *\n * @param a\n * First value\n *\n * @param b\n * Second value\n *\n * @param c\n * Third value\n *\n * @return\n * The middle value\n */\nint utils_middle_of_3_int(int a, int b, int c) {\n\tint middle;\n\n\tif ((a <= b) && (a <= c)) {\n\t\tmiddle = (b <= c) ? b : c;\n\t} else if ((b <= a) && (b <= c)) {\n\t\tmiddle = (a <= c) ? a : c;\n\t} else {\n\t\tmiddle = (a <= b) ? a : b;\n\t}\n\treturn middle;\n}\n\n// Fast inverse square-root\n// See: http://en.wikipedia.org/wiki/Fast_inverse_square_root\nfloat utils_fast_inv_sqrt(float x) {\n\tunion {\n\t\tfloat as_float;\n\t\tlong as_int;\n\t} un;\n\n\tfloat xhalf = 0.5f*x;\n\tun.as_float = x;\n\tun.as_int = 0x5f3759df - (un.as_int >> 1);\n\tun.as_float = un.as_float * (1.5f - xhalf * un.as_float * un.as_float);\n\treturn un.as_float;\n}\n\n/**\n * Fast atan2\n *\n * See http://www.dspguru.com/dsp/tricks/fixed-point-atan2-with-self-normalization\n *\n * @param y\n * y\n *\n * @param x\n * x\n *\n * @return\n * The angle in radians\n */\nfloat utils_fast_atan2(float y, float x) {\n\tfloat abs_y = fabsf(y) + 1e-20; // kludge to prevent 0/0 condition\n\tfloat angle;\n\n\tif (x >= 0) {\n\t\tfloat r = (x - abs_y) / (x + abs_y);\n\t\tfloat rsq = r * r;\n\t\tangle = ((0.1963 * rsq) - 0.9817) * r + (M_PI / 4.0);\n\t} else {\n\t\tfloat r = (x + abs_y) / (abs_y - x);\n\t\tfloat rsq = r * r;\n\t\tangle = ((0.1963 * rsq) - 0.9817) * r + (3.0 * M_PI / 4.0);\n\t}\n\n\tif (y < 0) {\n\t\treturn(-angle);\n\t} else {\n\t\treturn(angle);\n\t}\n}\n\n/**\n * Truncate the magnitude of a vector.\n *\n * @param x\n * The first component.\n *\n * @param y\n * The second component.\n *\n * @param max\n * The maximum magnitude.\n *\n * @return\n * True if saturation happened, false otherwise\n */\nbool utils_saturate_vector_2d(float *x, float *y, float max) {\n\tbool retval = false;\n\tfloat mag = sqrtf(SQ(*x) + SQ(*y));\n\tmax = fabsf(max);\n\n\tif (mag < 1e-10) {\n\t\tmag = 1e-10;\n\t}\n\n\tif (mag > max) {\n\t\tconst float f = max / mag;\n\t\t*x *= f;\n\t\t*y *= f;\n\t\tretval = true;\n\t}\n\n\treturn retval;\n}\n\n/**\n * Fast sine and cosine implementation.\n *\n * See http://lab.polygonal.de/?p=205\n *\n * @param angle\n * The angle in radians\n * WARNING: Don't use too large angles.\n *\n * @param sin\n * A pointer to store the sine value.\n *\n * @param cos\n * A pointer to store the cosine value.\n */\nvoid utils_fast_sincos(float angle, float *sin, float *cos) {\n\t//always wrap input angle to -PI..PI\n\twhile (angle < -M_PI) {\n\t\tangle += 2.0 * M_PI;\n\t}\n\n\twhile (angle >  M_PI) {\n\t\tangle -= 2.0 * M_PI;\n\t}\n\n\t// compute sine\n\tif (angle < 0.0) {\n\t\t*sin = 1.27323954 * angle + 0.405284735 * angle * angle;\n\t} else {\n\t\t*sin = 1.27323954 * angle - 0.405284735 * angle * angle;\n\t}\n\n\t// compute cosine: sin(x + PI/2) = cos(x)\n\tangle += 0.5 * M_PI;\n\n\tif (angle >  M_PI) {\n\t\tangle -= 2.0 * M_PI;\n\t}\n\n\tif (angle < 0.0) {\n\t\t*cos = 1.27323954 * angle + 0.405284735 * angle * angle;\n\t} else {\n\t\t*cos = 1.27323954 * angle - 0.405284735 * angle * angle;\n\t}\n}\n\n/**\n * Fast sine and cosine implementation.\n *\n * See http://lab.polygonal.de/?p=205\n *\n * @param angle\n * The angle in radians\n * WARNING: Don't use too large angles.\n *\n * @param sin\n * A pointer to store the sine value.\n *\n * @param cos\n * A pointer to store the cosine value.\n */\nvoid utils_fast_sincos_better(float angle, float *sin, float *cos) {\n\t//always wrap input angle to -PI..PI\n\twhile (angle < -M_PI) {\n\t\tangle += 2.0 * M_PI;\n\t}\n\n\twhile (angle >  M_PI) {\n\t\tangle -= 2.0 * M_PI;\n\t}\n\n\t//compute sine\n\tif (angle < 0.0) {\n\t\t*sin = 1.27323954 * angle + 0.405284735 * angle * angle;\n\n\t\tif (*sin < 0.0) {\n\t\t\t*sin = 0.225 * (*sin * -*sin - *sin) + *sin;\n\t\t} else {\n\t\t\t*sin = 0.225 * (*sin * *sin - *sin) + *sin;\n\t\t}\n\t} else {\n\t\t*sin = 1.27323954 * angle - 0.405284735 * angle * angle;\n\n\t\tif (*sin < 0.0) {\n\t\t\t*sin = 0.225 * (*sin * -*sin - *sin) + *sin;\n\t\t} else {\n\t\t\t*sin = 0.225 * (*sin * *sin - *sin) + *sin;\n\t\t}\n\t}\n\n\t// compute cosine: sin(x + PI/2) = cos(x)\n\tangle += 0.5 * M_PI;\n\tif (angle >  M_PI) {\n\t\tangle -= 2.0 * M_PI;\n\t}\n\n\tif (angle < 0.0) {\n\t\t*cos = 1.27323954 * angle + 0.405284735 * angle * angle;\n\n\t\tif (*cos < 0.0) {\n\t\t\t*cos = 0.225 * (*cos * -*cos - *cos) + *cos;\n\t\t} else {\n\t\t\t*cos = 0.225 * (*cos * *cos - *cos) + *cos;\n\t\t}\n\t} else {\n\t\t*cos = 1.27323954 * angle - 0.405284735 * angle * angle;\n\n\t\tif (*cos < 0.0) {\n\t\t\t*cos = 0.225 * (*cos * -*cos - *cos) + *cos;\n\t\t} else {\n\t\t\t*cos = 0.225 * (*cos * *cos - *cos) + *cos;\n\t\t}\n\t}\n}\n\n/**\n * Calculate the values with the lowest magnitude.\n *\n * @param va\n * The first value.\n *\n * @param vb\n * The second value.\n *\n * @return\n * The value with the lowest magnitude.\n */\nfloat utils_min_abs(float va, float vb) {\n\tfloat res;\n\tif (fabsf(va) < fabsf(vb)) {\n\t\tres = va;\n\t} else {\n\t\tres = vb;\n\t}\n\n\treturn res;\n}\n\n/**\n * Calculate the values with the highest magnitude.\n *\n * @param va\n * The first value.\n *\n * @param vb\n * The second value.\n *\n * @return\n * The value with the highest magnitude.\n */\nfloat utils_max_abs(float va, float vb) {\n\tfloat res;\n\tif (fabsf(va) > fabsf(vb)) {\n\t\tres = va;\n\t} else {\n\t\tres = vb;\n\t}\n\n\treturn res;\n}\n\n/**\n * Create string representation of the binary content of a byte\n *\n * @param x\n * The byte.\n *\n * @param b\n * Array to store the string representation in.\n */\nvoid utils_byte_to_binary(int x, char *b) {\n\tb[0] = '\\0';\n\n\tint z;\n\tfor (z = 128; z > 0; z >>= 1) {\n\t\tstrcat(b, ((x & z) == z) ? \"1\" : \"0\");\n\t}\n}\n\nfloat utils_throttle_curve(float val, float curve_acc, float curve_brake, int mode) {\n\tfloat ret = 0.0;\n\t\n\tif (val < -1.0) {\n\t\tval = -1.0;\n\t}\n\n\tif (val > 1.0) {\n\t\tval = 1.0;\n\t}\n\t\n\tfloat val_a = fabsf(val);\n\n\tfloat curve;\n\tif (val >= 0.0) {\n\t\tcurve = curve_acc;\n\t} else {\n\t\tcurve = curve_brake;\n\t}\n\n\t// See\n\t// http://math.stackexchange.com/questions/297768/how-would-i-create-a-exponential-ramp-function-from-0-0-to-1-1-with-a-single-val\n\tif (mode == 0) { // Exponential\n\t\tif (curve >= 0.0) {\n\t\t\tret = 1.0 - powf(1.0 - val_a, 1.0 + curve);\n\t\t} else {\n\t\t\tret = powf(val_a, 1.0 - curve);\n\t\t}\n\t} else if (mode == 1) { // Natural\n\t\tif (fabsf(curve) < 1e-10) {\n\t\t\tret = val_a;\n\t\t} else {\n\t\t\tif (curve >= 0.0) {\n\t\t\t\tret = 1.0 - ((expf(curve * (1.0 - val_a)) - 1.0) / (expf(curve) - 1.0));\n\t\t\t} else {\n\t\t\t\tret = (expf(-curve * val_a) - 1.0) / (expf(-curve) - 1.0);\n\t\t\t}\n\t\t}\n\t} else if (mode == 2) { // Polynomial\n\t\tif (curve >= 0.0) {\n\t\t\tret = 1.0 - ((1.0 - val_a) / (1.0 + curve * val_a));\n\t\t} else {\n\t\t\tret = val_a / (1.0 - curve * (1.0 - val_a));\n\t\t}\n\t} else { // Linear\n\t\tret = val_a;\n\t}\n\n\tif (val < 0.0) {\n\t\tret = -ret;\n\t}\n\n\treturn ret;\n}\n\n/**\n * A system locking function with a counter. For every lock, a corresponding unlock must\n * exist to unlock the system. That means, if lock is called five times, unlock has to\n * be called five times as well. Note that chSysLock and chSysLockFromIsr are the same\n * for this port.\n */\nvoid utils_sys_lock_cnt(void) {\n\tif (!sys_lock_cnt) {\n\t\tchSysLock();\n\t}\n\tsys_lock_cnt++;\n}\n\n/**\n * A system unlocking function with a counter. For every lock, a corresponding unlock must\n * exist to unlock the system. That means, if lock is called five times, unlock has to\n * be called five times as well. Note that chSysUnlock and chSysUnlockFromIsr are the same\n * for this port.\n */\nvoid utils_sys_unlock_cnt(void) {\n\tif (sys_lock_cnt) {\n\t\tsys_lock_cnt--;\n\t\tif (!sys_lock_cnt) {\n\t\t\tchSysUnlock();\n\t\t}\n\t}\n}\n\nuint32_t utils_crc32c(uint8_t *data, uint32_t len) {\n\tuint32_t crc = 0xFFFFFFFF;\n\n\tfor (uint32_t i = 0; i < len;i++) {\n\t\tuint32_t byte = data[i];\n\t\tcrc = crc ^ byte;\n\n\t\tfor (int j = 7;j >= 0;j--) {\n\t\t\tuint32_t mask = -(crc & 1);\n\t\t\tcrc = (crc >> 1) ^ (0x82F63B78 & mask);\n\t\t}\n\t}\n\n\treturn ~crc;\n}\n\n// Yes, this is only the average...\nvoid utils_fft32_bin0(float *real_in, float *real, float *imag) {\n\t*real = 0.0;\n\t*imag = 0.0;\n\n\tfor (int i = 0;i < 32;i++) {\n\t\t*real += real_in[i];\n\t}\n\n\t*real /= 32.0;\n}\n\nvoid utils_fft32_bin1(float *real_in, float *real, float *imag) {\n\t*real = 0.0;\n\t*imag = 0.0;\n\tfor (int i = 0;i < 32;i++) {\n\t\t*real += real_in[i] * utils_tab_cos_32_1[i];\n\t\t*imag -= real_in[i] * utils_tab_sin_32_1[i];\n\t}\n\t*real /= 32.0;\n\t*imag /= 32.0;\n}\n\nvoid utils_fft32_bin2(float *real_in, float *real, float *imag) {\n\t*real = 0.0;\n\t*imag = 0.0;\n\tfor (int i = 0;i < 32;i++) {\n\t\t*real += real_in[i] * utils_tab_cos_32_2[i];\n\t\t*imag -= real_in[i] * utils_tab_sin_32_2[i];\n\t}\n\t*real /= 32.0;\n\t*imag /= 32.0;\n}\n\nvoid utils_fft16_bin0(float *real_in, float *real, float *imag) {\n\t*real = 0.0;\n\t*imag = 0.0;\n\n\tfor (int i = 0;i < 16;i++) {\n\t\t*real += real_in[i];\n\t}\n\n\t*real /= 16.0;\n}\n\nvoid utils_fft16_bin1(float *real_in, float *real, float *imag) {\n\t*real = 0.0;\n\t*imag = 0.0;\n\tfor (int i = 0;i < 16;i++) {\n\t\t*real += real_in[i] * utils_tab_cos_32_1[2 * i];\n\t\t*imag -= real_in[i] * utils_tab_sin_32_1[2 * i];\n\t}\n\t*real /= 16.0;\n\t*imag /= 16.0;\n}\n\nvoid utils_fft16_bin2(float *real_in, float *real, float *imag) {\n\t*real = 0.0;\n\t*imag = 0.0;\n\tfor (int i = 0;i < 16;i++) {\n\t\t*real += real_in[i] * utils_tab_cos_32_2[2 * i];\n\t\t*imag -= real_in[i] * utils_tab_sin_32_2[2 * i];\n\t}\n\t*real /= 16.0;\n\t*imag /= 16.0;\n}\n\nvoid utils_fft8_bin0(float *real_in, float *real, float *imag) {\n\t*real = 0.0;\n\t*imag = 0.0;\n\n\tfor (int i = 0;i < 8;i++) {\n\t\t*real += real_in[i];\n\t}\n\n\t*real /= 8.0;\n}\n\nvoid utils_fft8_bin1(float *real_in, float *real, float *imag) {\n\t*real = 0.0;\n\t*imag = 0.0;\n\tfor (int i = 0;i < 8;i++) {\n\t\t*real += real_in[i] * utils_tab_cos_32_1[4 * i];\n\t\t*imag -= real_in[i] * utils_tab_sin_32_1[4 * i];\n\t}\n\t*real /= 8.0;\n\t*imag /= 8.0;\n}\n\nvoid utils_fft8_bin2(float *real_in, float *real, float *imag) {\n\t*real = 0.0;\n\t*imag = 0.0;\n\tfor (int i = 0;i < 8;i++) {\n\t\t*real += real_in[i] * utils_tab_cos_32_2[4 * i];\n\t\t*imag -= real_in[i] * utils_tab_sin_32_2[4 * i];\n\t}\n\t*real /= 8.0;\n\t*imag /= 8.0;\n}\n\n/**\n * Get ID of second motor.\n *\n * @return\n * id for second motor. -1 if this hardware only has one motor.\n */\nuint8_t utils_second_motor_id(void) {\n#ifdef HW_HAS_DUAL_MOTORS\n\tuint8_t id_next = app_get_configuration()->controller_id + 1;\n\tif (id_next == 255) {\n\t\tid_next = 0;\n\t}\n\treturn id_next;\n#else\n\treturn 0;\n#endif\n}\n\nint utils_read_hall(bool is_second_motor) {\n\tint h1, h2, h3;\n\n\tif (is_second_motor) {\n\t\th1 = READ_HALL1_2();\n\t\th2 = READ_HALL2_2();\n\t\th3 = READ_HALL3_2();\n\n\t\th1 += READ_HALL1_2();\n\t\th2 += READ_HALL2_2();\n\t\th3 += READ_HALL3_2();\n\n\t\th1 += READ_HALL1_2();\n\t\th2 += READ_HALL2_2();\n\t\th3 += READ_HALL3_2();\n\t} else {\n\t\th1 = READ_HALL1();\n\t\th2 = READ_HALL2();\n\t\th3 = READ_HALL3();\n\n\t\th1 += READ_HALL1();\n\t\th2 += READ_HALL2();\n\t\th3 += READ_HALL3();\n\n\t\th1 += READ_HALL1();\n\t\th2 += READ_HALL2();\n\t\th3 += READ_HALL3();\n\t}\n\n\treturn (h1 > 1) | ((h2 > 1) << 1) | ((h3 > 1) << 2);\n}\n\n// A mapping of a samsung 30q cell for % remaining capacity vs. voltage from\n// 4.2 to 3.2, note that the you lose 15% of the 3Ah rated capacity in this range\nfloat utils_batt_liion_norm_v_to_capacity(float norm_v) {\n\t// constants for polynomial fit of lithium ion battery\n\tconst float li_p[] = {\n\t\t\t\t\t\t  -2.979767, 5.487810, -3.501286, 1.675683, 0.317147};\n\tutils_truncate_number(&norm_v,0.0,1.0);\n\tfloat v2 = norm_v*norm_v;\n\tfloat v3 = v2*norm_v;\n\tfloat v4 = v3*norm_v;\n\tfloat v5 = v4*norm_v;\n\tfloat capacity = li_p[0] * v5 + li_p[1] * v4 + li_p[2] * v3 +\n\t\t\tli_p[3] * v2 + li_p[4] * norm_v;\n\treturn capacity;\n}\n\nstatic int uint16_cmp_func (const void *a, const void *b) {\n\treturn (*(uint16_t*)a - *(uint16_t*)b);\n}\n\nuint16_t utils_median_filter_uint16_run(uint16_t *buffer,\n\t\tunsigned int *buffer_index, unsigned int filter_len, uint16_t sample) {\n\tbuffer[(*buffer_index)++] = sample;\n\t*buffer_index %= filter_len;\n\tuint16_t buffer_sorted[filter_len]; // Assume we have enough stack space\n\tmemcpy(buffer_sorted, buffer, sizeof(uint16_t) * filter_len);\n\tqsort(buffer_sorted, filter_len, sizeof(uint16_t), uint16_cmp_func);\n\treturn buffer_sorted[filter_len / 2];\n}\n\nconst float utils_tab_sin_32_1[] = {\n\t0.000000, 0.195090, 0.382683, 0.555570, 0.707107, 0.831470, 0.923880, 0.980785,\n\t1.000000, 0.980785, 0.923880, 0.831470, 0.707107, 0.555570, 0.382683, 0.195090,\n\t0.000000, -0.195090, -0.382683, -0.555570, -0.707107, -0.831470, -0.923880, -0.980785,\n\t-1.000000, -0.980785, -0.923880, -0.831470, -0.707107, -0.555570, -0.382683, -0.195090};\n\nconst float utils_tab_sin_32_2[] = {\n\t0.000000, 0.382683, 0.707107, 0.923880, 1.000000, 0.923880, 0.707107, 0.382683,\n\t0.000000, -0.382683, -0.707107, -0.923880, -1.000000, -0.923880, -0.707107, -0.382683,\n\t-0.000000, 0.382683, 0.707107, 0.923880, 1.000000, 0.923880, 0.707107, 0.382683,\n\t0.000000, -0.382683, -0.707107, -0.923880, -1.000000, -0.923880, -0.707107, -0.382683};\n\nconst float utils_tab_cos_32_1[] = {\n\t1.000000, 0.980785, 0.923880, 0.831470, 0.707107, 0.555570, 0.382683, 0.195090,\n\t0.000000, -0.195090, -0.382683, -0.555570, -0.707107, -0.831470, -0.923880, -0.980785,\n\t-1.000000, -0.980785, -0.923880, -0.831470, -0.707107, -0.555570, -0.382683, -0.195090,\n\t-0.000000, 0.195090, 0.382683, 0.555570, 0.707107, 0.831470, 0.923880, 0.980785};\n\nconst float utils_tab_cos_32_2[] = {\n\t1.000000, 0.923880, 0.707107, 0.382683, 0.000000, -0.382683, -0.707107, -0.923880,\n\t-1.000000, -0.923880, -0.707107, -0.382683, -0.000000, 0.382683, 0.707107, 0.923880,\n\t1.000000, 0.923880, 0.707107, 0.382683, 0.000000, -0.382683, -0.707107, -0.923880,\n\t-1.000000, -0.923880, -0.707107, -0.382683, -0.000000, 0.382683, 0.707107, 0.923880};\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/utils.c b/utils.c
--- a/utils.c	
+++ b/utils.c	
@@ -29,23 +29,34 @@
 // Private variables
 static volatile int sys_lock_cnt = 0;
 
-void utils_step_towards(float *value, float goal, float step) {
-    if (*value < goal) {
-        if ((*value + step) < goal) {
-            *value += step;
-        } else {
-            *value = goal;
-        }
-    } else if (*value > goal) {
-        if ((*value - step) > goal) {
-            *value -= step;
-        } else {
-            *value = goal;
-        }
-    }
+void utils_step_towards(float* value, float goal, float step)
+{
+	if (*value < goal)
+	{
+		if ((*value + step) < goal)
+		{
+			*value += step;
+		}
+		else
+		{
+			*value = goal;
+		}
+	}
+	else if (*value > goal)
+	{
+		if ((*value - step) > goal)
+		{
+			*value -= step;
+		}
+		else
+		{
+			*value = goal;
+		}
+	}
 }
 
-float utils_calc_ratio(float low, float high, float val) {
+float utils_calc_ratio(float low, float high, float val)
+{
 	return (val - low) / (high - low);
 }
 
@@ -55,10 +66,12 @@
  * @param angle
  * The angle to normalize.
  */
-void utils_norm_angle(float *angle) {
+void utils_norm_angle(float* angle)
+{
 	*angle = fmodf(*angle, 360.0);
-
-	if (*angle < 0.0) {
+	
+	if (*angle < 0.0)
+	{
 		*angle += 360.0;
 	}
 }
@@ -72,63 +85,80 @@
  * The angle to normalize in radians.
  * WARNING: Don't use too large angles.
  */
-void utils_norm_angle_rad(float *angle) {
-	while (*angle < -M_PI) {
+void utils_norm_angle_rad(float* angle)
+{
+	while (*angle < -M_PI)
+	{
 		*angle += 2.0 * M_PI;
 	}
-
-	while (*angle >  M_PI) {
+	
+	while (*angle > M_PI)
+	{
 		*angle -= 2.0 * M_PI;
 	}
 }
 
-int utils_truncate_number(float *number, float min, float max) {
+int utils_truncate_number(float* number, float min, float max)
+{
 	int did_trunc = 0;
-
-	if (*number > max) {
+	
+	if (*number > max)
+	{
 		*number = max;
 		did_trunc = 1;
-	} else if (*number < min) {
+	}
+	else if (*number < min)
+	{
 		*number = min;
 		did_trunc = 1;
 	}
-
+	
 	return did_trunc;
 }
 
-int utils_truncate_number_int(int *number, int min, int max) {
+int utils_truncate_number_int(int* number, int min, int max)
+{
 	int did_trunc = 0;
-
-	if (*number > max) {
+	
+	if (*number > max)
+	{
 		*number = max;
 		did_trunc = 1;
-	} else if (*number < min) {
+	}
+	else if (*number < min)
+	{
 		*number = min;
 		did_trunc = 1;
 	}
-
+	
 	return did_trunc;
 }
 
-int utils_truncate_number_abs(float *number, float max) {
+int utils_truncate_number_abs(float* number, float max)
+{
 	int did_trunc = 0;
-
-	if (*number > max) {
+	
+	if (*number > max)
+	{
 		*number = max;
 		did_trunc = 1;
-	} else if (*number < -max) {
+	}
+	else if (*number < -max)
+	{
 		*number = -max;
 		did_trunc = 1;
 	}
-
+	
 	return did_trunc;
 }
 
-float utils_map(float x, float in_min, float in_max, float out_min, float out_max) {
+float utils_map(float x, float in_min, float in_max, float out_min, float out_max)
+{
 	return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
 }
 
-int utils_map_int(int x, int in_min, int in_max, int out_min, int out_max) {
+int utils_map_int(int x, int in_min, int in_max, int out_min, int out_max)
+{
 	return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
 }
 
@@ -136,14 +166,21 @@
  * Truncate absolute values less than tres to zero. The value
  * tres will be mapped to 0 and the value max to max.
  */
-void utils_deadband(float *value, float tres, float max) {
-	if (fabsf(*value) < tres) {
+void utils_deadband(float* value, float tres, float max)
+{
+	if (fabsf(*value) < tres)
+	{
 		*value = 0.0;
-	} else {
+	}
+	else
+	{
 		float k = max / (max - tres);
-		if (*value > 0.0) {
+		if (*value > 0.0)
+		{
 			*value = k * *value + max * (1.0 - k);
-		} else {
+		}
+		else
+		{
 			*value = -(k * -*value + max * (1.0 - k));
 		}
 	}
@@ -158,7 +195,8 @@
  * @return
  * The difference between the angles
  */
-float utils_angle_difference(float angle1, float angle2) {
+float utils_angle_difference(float angle1, float angle2)
+{
 //	utils_norm_angle(&angle1);
 //	utils_norm_angle(&angle2);
 //
@@ -171,11 +209,11 @@
 //	}
 //
 //	return angle1 - angle2;
-
+	
 	// Faster in most cases
 	float difference = angle1 - angle2;
-	while (difference < -180.0) difference += 2.0 * 180.0;
-	while (difference > 180.0) difference -= 2.0 * 180.0;
+	while (difference < -180.0) { difference += 2.0 * 180.0; }
+	while (difference > 180.0) { difference -= 2.0 * 180.0; }
 	return difference;
 }
 
@@ -188,10 +226,11 @@
  * @return
  * The difference between the angles in radians
  */
-float utils_angle_difference_rad(float angle1, float angle2) {
+float utils_angle_difference_rad(float angle1, float angle2)
+{
 	float difference = angle1 - angle2;
-	while (difference < -M_PI) difference += 2.0 * M_PI;
-	while (difference > M_PI) difference -= 2.0 * M_PI;
+	while (difference < -M_PI) { difference += 2.0 * M_PI; }
+	while (difference > M_PI) { difference -= 2.0 * M_PI; }
 	return difference;
 }
 
@@ -210,17 +249,19 @@
  * @return
  * The average angle.
  */
-float utils_avg_angles_rad_fast(float *angles, float *weights, int angles_num) {
+float utils_avg_angles_rad_fast(float* angles, float* weights, int angles_num)
+{
 	float s_sum = 0.0;
 	float c_sum = 0.0;
-
-	for (int i = 0; i < angles_num; i++) {
+	
+	for (int i = 0; i < angles_num; i++)
+	{
 		float s, c;
 		utils_fast_sincos_better(angles[i], &s, &c);
 		s_sum += s * weights[i];
 		c_sum += c * weights[i];
 	}
-
+	
 	return utils_fast_atan2(s_sum, c_sum);
 }
 
@@ -239,14 +280,20 @@
  * @return
  * The middle value
  */
-float utils_middle_of_3(float a, float b, float c) {
+float utils_middle_of_3(float a, float b, float c)
+{
 	float middle;
-
-	if ((a <= b) && (a <= c)) {
+	
+	if ((a <= b) && (a <= c))
+	{
 		middle = (b <= c) ? b : c;
-	} else if ((b <= a) && (b <= c)) {
+	}
+	else if ((b <= a) && (b <= c))
+	{
 		middle = (a <= c) ? a : c;
-	} else {
+	}
+	else
+	{
 		middle = (a <= b) ? a : b;
 	}
 	return middle;
@@ -267,14 +314,20 @@
  * @return
  * The middle value
  */
-int utils_middle_of_3_int(int a, int b, int c) {
+int utils_middle_of_3_int(int a, int b, int c)
+{
 	int middle;
-
-	if ((a <= b) && (a <= c)) {
+	
+	if ((a <= b) && (a <= c))
+	{
 		middle = (b <= c) ? b : c;
-	} else if ((b <= a) && (b <= c)) {
+	}
+	else if ((b <= a) && (b <= c))
+	{
 		middle = (a <= c) ? a : c;
-	} else {
+	}
+	else
+	{
 		middle = (a <= b) ? a : b;
 	}
 	return middle;
@@ -282,13 +335,15 @@
 
 // Fast inverse square-root
 // See: http://en.wikipedia.org/wiki/Fast_inverse_square_root
-float utils_fast_inv_sqrt(float x) {
-	union {
+float utils_fast_inv_sqrt(float x)
+{
+	union
+	{
 		float as_float;
 		long as_int;
-	} un;
-
-	float xhalf = 0.5f*x;
+	}un;
+	
+	float xhalf = 0.5f * x;
 	un.as_float = x;
 	un.as_int = 0x5f3759df - (un.as_int >> 1);
 	un.as_float = un.as_float * (1.5f - xhalf * un.as_float * un.as_float);
@@ -309,24 +364,31 @@
  * @return
  * The angle in radians
  */
-float utils_fast_atan2(float y, float x) {
+float utils_fast_atan2(float y, float x)
+{
 	float abs_y = fabsf(y) + 1e-20; // kludge to prevent 0/0 condition
 	float angle;
-
-	if (x >= 0) {
+	
+	if (x >= 0)
+	{
 		float r = (x - abs_y) / (x + abs_y);
 		float rsq = r * r;
 		angle = ((0.1963 * rsq) - 0.9817) * r + (M_PI / 4.0);
-	} else {
+	}
+	else
+	{
 		float r = (x + abs_y) / (abs_y - x);
 		float rsq = r * r;
 		angle = ((0.1963 * rsq) - 0.9817) * r + (3.0 * M_PI / 4.0);
 	}
-
-	if (y < 0) {
-		return(-angle);
-	} else {
-		return(angle);
+	
+	if (y < 0)
+	{
+		return (-angle);
+	}
+	else
+	{
+		return (angle);
 	}
 }
 
@@ -345,22 +407,25 @@
  * @return
  * True if saturation happened, false otherwise
  */
-bool utils_saturate_vector_2d(float *x, float *y, float max) {
+bool utils_saturate_vector_2d(float* x, float* y, float max)
+{
 	bool retval = false;
 	float mag = sqrtf(SQ(*x) + SQ(*y));
 	max = fabsf(max);
-
-	if (mag < 1e-10) {
+	
+	if (mag < 1e-10)
+	{
 		mag = 1e-10;
 	}
-
-	if (mag > max) {
+	
+	if (mag > max)
+	{
 		const float f = max / mag;
 		*x *= f;
 		*y *= f;
 		retval = true;
 	}
-
+	
 	return retval;
 }
 
@@ -379,33 +444,43 @@
  * @param cos
  * A pointer to store the cosine value.
  */
-void utils_fast_sincos(float angle, float *sin, float *cos) {
+void utils_fast_sincos(float angle, float* sin, float* cos)
+{
 	//always wrap input angle to -PI..PI
-	while (angle < -M_PI) {
+	while (angle < -M_PI)
+	{
 		angle += 2.0 * M_PI;
 	}
-
-	while (angle >  M_PI) {
+	
+	while (angle > M_PI)
+	{
 		angle -= 2.0 * M_PI;
 	}
-
+	
 	// compute sine
-	if (angle < 0.0) {
+	if (angle < 0.0)
+	{
 		*sin = 1.27323954 * angle + 0.405284735 * angle * angle;
-	} else {
+	}
+	else
+	{
 		*sin = 1.27323954 * angle - 0.405284735 * angle * angle;
 	}
-
+	
 	// compute cosine: sin(x + PI/2) = cos(x)
 	angle += 0.5 * M_PI;
-
-	if (angle >  M_PI) {
+	
+	if (angle > M_PI)
+	{
 		angle -= 2.0 * M_PI;
 	}
-
-	if (angle < 0.0) {
+	
+	if (angle < 0.0)
+	{
 		*cos = 1.27323954 * angle + 0.405284735 * angle * angle;
-	} else {
+	}
+	else
+	{
 		*cos = 1.27323954 * angle - 0.405284735 * angle * angle;
 	}
 }
@@ -425,55 +500,77 @@
  * @param cos
  * A pointer to store the cosine value.
  */
-void utils_fast_sincos_better(float angle, float *sin, float *cos) {
+void utils_fast_sincos_better(float angle, float* sin, float* cos)
+{
 	//always wrap input angle to -PI..PI
-	while (angle < -M_PI) {
+	while (angle < -M_PI)
+	{
 		angle += 2.0 * M_PI;
 	}
-
-	while (angle >  M_PI) {
+	
+	while (angle > M_PI)
+	{
 		angle -= 2.0 * M_PI;
 	}
-
+	
 	//compute sine
-	if (angle < 0.0) {
+	if (angle < 0.0)
+	{
 		*sin = 1.27323954 * angle + 0.405284735 * angle * angle;
-
-		if (*sin < 0.0) {
+		
+		if (*sin < 0.0)
+		{
 			*sin = 0.225 * (*sin * -*sin - *sin) + *sin;
-		} else {
+		}
+		else
+		{
 			*sin = 0.225 * (*sin * *sin - *sin) + *sin;
 		}
-	} else {
+	}
+	else
+	{
 		*sin = 1.27323954 * angle - 0.405284735 * angle * angle;
-
-		if (*sin < 0.0) {
+		
+		if (*sin < 0.0)
+		{
 			*sin = 0.225 * (*sin * -*sin - *sin) + *sin;
-		} else {
+		}
+		else
+		{
 			*sin = 0.225 * (*sin * *sin - *sin) + *sin;
 		}
 	}
-
+	
 	// compute cosine: sin(x + PI/2) = cos(x)
 	angle += 0.5 * M_PI;
-	if (angle >  M_PI) {
+	if (angle > M_PI)
+	{
 		angle -= 2.0 * M_PI;
 	}
-
-	if (angle < 0.0) {
+	
+	if (angle < 0.0)
+	{
 		*cos = 1.27323954 * angle + 0.405284735 * angle * angle;
-
-		if (*cos < 0.0) {
+		
+		if (*cos < 0.0)
+		{
 			*cos = 0.225 * (*cos * -*cos - *cos) + *cos;
-		} else {
+		}
+		else
+		{
 			*cos = 0.225 * (*cos * *cos - *cos) + *cos;
 		}
-	} else {
+	}
+	else
+	{
 		*cos = 1.27323954 * angle - 0.405284735 * angle * angle;
-
-		if (*cos < 0.0) {
+		
+		if (*cos < 0.0)
+		{
 			*cos = 0.225 * (*cos * -*cos - *cos) + *cos;
-		} else {
+		}
+		else
+		{
 			*cos = 0.225 * (*cos * *cos - *cos) + *cos;
 		}
 	}
@@ -491,14 +588,18 @@
  * @return
  * The value with the lowest magnitude.
  */
-float utils_min_abs(float va, float vb) {
+float utils_min_abs(float va, float vb)
+{
 	float res;
-	if (fabsf(va) < fabsf(vb)) {
+	if (fabsf(va) < fabsf(vb))
+	{
 		res = va;
-	} else {
+	}
+	else
+	{
 		res = vb;
 	}
-
+	
 	return res;
 }
 
@@ -514,14 +615,18 @@
  * @return
  * The value with the highest magnitude.
  */
-float utils_max_abs(float va, float vb) {
+float utils_max_abs(float va, float vb)
+{
 	float res;
-	if (fabsf(va) > fabsf(vb)) {
+	if (fabsf(va) > fabsf(vb))
+	{
 		res = va;
-	} else {
+	}
+	else
+	{
 		res = vb;
 	}
-
+	
 	return res;
 }
 
@@ -534,67 +639,95 @@
  * @param b
  * Array to store the string representation in.
  */
-void utils_byte_to_binary(int x, char *b) {
+void utils_byte_to_binary(int x, char* b)
+{
 	b[0] = '\0';
-
+	
 	int z;
-	for (z = 128; z > 0; z >>= 1) {
+	for (z = 128; z > 0; z >>= 1)
+	{
 		strcat(b, ((x & z) == z) ? "1" : "0");
 	}
 }
 
-float utils_throttle_curve(float val, float curve_acc, float curve_brake, int mode) {
+float utils_throttle_curve(float val, float curve_acc, float curve_brake, int mode)
+{
 	float ret = 0.0;
 	
-	if (val < -1.0) {
+	if (val < -1.0)
+	{
 		val = -1.0;
 	}
-
-	if (val > 1.0) {
+	
+	if (val > 1.0)
+	{
 		val = 1.0;
 	}
 	
 	float val_a = fabsf(val);
-
+	
 	float curve;
-	if (val >= 0.0) {
+	if (val >= 0.0)
+	{
 		curve = curve_acc;
-	} else {
+	}
+	else
+	{
 		curve = curve_brake;
 	}
-
+	
 	// See
 	// http://math.stackexchange.com/questions/297768/how-would-i-create-a-exponential-ramp-function-from-0-0-to-1-1-with-a-single-val
-	if (mode == 0) { // Exponential
-		if (curve >= 0.0) {
+	if (mode == 0)
+	{ // Exponential
+		if (curve >= 0.0)
+		{
 			ret = 1.0 - powf(1.0 - val_a, 1.0 + curve);
-		} else {
+		}
+		else
+		{
 			ret = powf(val_a, 1.0 - curve);
 		}
-	} else if (mode == 1) { // Natural
-		if (fabsf(curve) < 1e-10) {
+	}
+	else if (mode == 1)
+	{ // Natural
+		if (fabsf(curve) < 1e-10)
+		{
 			ret = val_a;
-		} else {
-			if (curve >= 0.0) {
+		}
+		else
+		{
+			if (curve >= 0.0)
+			{
 				ret = 1.0 - ((expf(curve * (1.0 - val_a)) - 1.0) / (expf(curve) - 1.0));
-			} else {
+			}
+			else
+			{
 				ret = (expf(-curve * val_a) - 1.0) / (expf(-curve) - 1.0);
 			}
 		}
-	} else if (mode == 2) { // Polynomial
-		if (curve >= 0.0) {
+	}
+	else if (mode == 2)
+	{ // Polynomial
+		if (curve >= 0.0)
+		{
 			ret = 1.0 - ((1.0 - val_a) / (1.0 + curve * val_a));
-		} else {
+		}
+		else
+		{
 			ret = val_a / (1.0 - curve * (1.0 - val_a));
 		}
-	} else { // Linear
+	}
+	else
+	{ // Linear
 		ret = val_a;
 	}
-
-	if (val < 0.0) {
+	
+	if (val < 0.0)
+	{
 		ret = -ret;
 	}
-
+	
 	return ret;
 }
 
@@ -604,8 +737,10 @@
  * be called five times as well. Note that chSysLock and chSysLockFromIsr are the same
  * for this port.
  */
-void utils_sys_lock_cnt(void) {
-	if (!sys_lock_cnt) {
+void utils_sys_lock_cnt(void)
+{
+	if (!sys_lock_cnt)
+	{
 		chSysLock();
 	}
 	sys_lock_cnt++;
@@ -617,47 +752,57 @@
  * be called five times as well. Note that chSysUnlock and chSysUnlockFromIsr are the same
  * for this port.
  */
-void utils_sys_unlock_cnt(void) {
-	if (sys_lock_cnt) {
+void utils_sys_unlock_cnt(void)
+{
+	if (sys_lock_cnt)
+	{
 		sys_lock_cnt--;
-		if (!sys_lock_cnt) {
+		if (!sys_lock_cnt)
+		{
 			chSysUnlock();
 		}
 	}
 }
 
-uint32_t utils_crc32c(uint8_t *data, uint32_t len) {
+uint32_t utils_crc32c(uint8_t* data, uint32_t len)
+{
 	uint32_t crc = 0xFFFFFFFF;
-
-	for (uint32_t i = 0; i < len;i++) {
+	
+	for (uint32_t i = 0; i < len; i++)
+	{
 		uint32_t byte = data[i];
 		crc = crc ^ byte;
-
-		for (int j = 7;j >= 0;j--) {
+		
+		for (int j = 7; j >= 0; j--)
+		{
 			uint32_t mask = -(crc & 1);
 			crc = (crc >> 1) ^ (0x82F63B78 & mask);
 		}
 	}
-
+	
 	return ~crc;
 }
 
 // Yes, this is only the average...
-void utils_fft32_bin0(float *real_in, float *real, float *imag) {
+void utils_fft32_bin0(float* real_in, float* real, float* imag)
+{
 	*real = 0.0;
 	*imag = 0.0;
-
-	for (int i = 0;i < 32;i++) {
+	
+	for (int i = 0; i < 32; i++)
+	{
 		*real += real_in[i];
 	}
-
+	
 	*real /= 32.0;
 }
 
-void utils_fft32_bin1(float *real_in, float *real, float *imag) {
+void utils_fft32_bin1(float* real_in, float* real, float* imag)
+{
 	*real = 0.0;
 	*imag = 0.0;
-	for (int i = 0;i < 32;i++) {
+	for (int i = 0; i < 32; i++)
+	{
 		*real += real_in[i] * utils_tab_cos_32_1[i];
 		*imag -= real_in[i] * utils_tab_sin_32_1[i];
 	}
@@ -665,10 +810,12 @@
 	*imag /= 32.0;
 }
 
-void utils_fft32_bin2(float *real_in, float *real, float *imag) {
+void utils_fft32_bin2(float* real_in, float* real, float* imag)
+{
 	*real = 0.0;
 	*imag = 0.0;
-	for (int i = 0;i < 32;i++) {
+	for (int i = 0; i < 32; i++)
+	{
 		*real += real_in[i] * utils_tab_cos_32_2[i];
 		*imag -= real_in[i] * utils_tab_sin_32_2[i];
 	}
@@ -676,21 +823,25 @@
 	*imag /= 32.0;
 }
 
-void utils_fft16_bin0(float *real_in, float *real, float *imag) {
+void utils_fft16_bin0(float* real_in, float* real, float* imag)
+{
 	*real = 0.0;
 	*imag = 0.0;
-
-	for (int i = 0;i < 16;i++) {
+	
+	for (int i = 0; i < 16; i++)
+	{
 		*real += real_in[i];
 	}
-
+	
 	*real /= 16.0;
 }
 
-void utils_fft16_bin1(float *real_in, float *real, float *imag) {
+void utils_fft16_bin1(float* real_in, float* real, float* imag)
+{
 	*real = 0.0;
 	*imag = 0.0;
-	for (int i = 0;i < 16;i++) {
+	for (int i = 0; i < 16; i++)
+	{
 		*real += real_in[i] * utils_tab_cos_32_1[2 * i];
 		*imag -= real_in[i] * utils_tab_sin_32_1[2 * i];
 	}
@@ -698,10 +849,12 @@
 	*imag /= 16.0;
 }
 
-void utils_fft16_bin2(float *real_in, float *real, float *imag) {
+void utils_fft16_bin2(float* real_in, float* real, float* imag)
+{
 	*real = 0.0;
 	*imag = 0.0;
-	for (int i = 0;i < 16;i++) {
+	for (int i = 0; i < 16; i++)
+	{
 		*real += real_in[i] * utils_tab_cos_32_2[2 * i];
 		*imag -= real_in[i] * utils_tab_sin_32_2[2 * i];
 	}
@@ -709,21 +862,25 @@
 	*imag /= 16.0;
 }
 
-void utils_fft8_bin0(float *real_in, float *real, float *imag) {
+void utils_fft8_bin0(float* real_in, float* real, float* imag)
+{
 	*real = 0.0;
 	*imag = 0.0;
-
-	for (int i = 0;i < 8;i++) {
+	
+	for (int i = 0; i < 8; i++)
+	{
 		*real += real_in[i];
 	}
-
+	
 	*real /= 8.0;
 }
 
-void utils_fft8_bin1(float *real_in, float *real, float *imag) {
+void utils_fft8_bin1(float* real_in, float* real, float* imag)
+{
 	*real = 0.0;
 	*imag = 0.0;
-	for (int i = 0;i < 8;i++) {
+	for (int i = 0; i < 8; i++)
+	{
 		*real += real_in[i] * utils_tab_cos_32_1[4 * i];
 		*imag -= real_in[i] * utils_tab_sin_32_1[4 * i];
 	}
@@ -731,10 +888,12 @@
 	*imag /= 8.0;
 }
 
-void utils_fft8_bin2(float *real_in, float *real, float *imag) {
+void utils_fft8_bin2(float* real_in, float* real, float* imag)
+{
 	*real = 0.0;
 	*imag = 0.0;
-	for (int i = 0;i < 8;i++) {
+	for (int i = 0; i < 8; i++)
+	{
 		*real += real_in[i] * utils_tab_cos_32_2[4 * i];
 		*imag -= real_in[i] * utils_tab_sin_32_2[4 * i];
 	}
@@ -748,7 +907,8 @@
  * @return
  * id for second motor. -1 if this hardware only has one motor.
  */
-uint8_t utils_second_motor_id(void) {
+uint8_t utils_second_motor_id(void)
+{
 #ifdef HW_HAS_DUAL_MOTORS
 	uint8_t id_next = app_get_configuration()->controller_id + 1;
 	if (id_next == 255) {
@@ -760,60 +920,70 @@
 #endif
 }
 
-int utils_read_hall(bool is_second_motor) {
+int utils_read_hall(bool is_second_motor)
+{
 	int h1, h2, h3;
-
-	if (is_second_motor) {
+	
+	if (is_second_motor)
+	{
 		h1 = READ_HALL1_2();
 		h2 = READ_HALL2_2();
 		h3 = READ_HALL3_2();
-
+		
 		h1 += READ_HALL1_2();
 		h2 += READ_HALL2_2();
 		h3 += READ_HALL3_2();
-
+		
 		h1 += READ_HALL1_2();
 		h2 += READ_HALL2_2();
 		h3 += READ_HALL3_2();
-	} else {
+	}
+	else
+	{
 		h1 = READ_HALL1();
 		h2 = READ_HALL2();
 		h3 = READ_HALL3();
-
+		
 		h1 += READ_HALL1();
 		h2 += READ_HALL2();
 		h3 += READ_HALL3();
-
+		
 		h1 += READ_HALL1();
 		h2 += READ_HALL2();
 		h3 += READ_HALL3();
 	}
-
+	
 	return (h1 > 1) | ((h2 > 1) << 1) | ((h3 > 1) << 2);
 }
 
 // A mapping of a samsung 30q cell for % remaining capacity vs. voltage from
 // 4.2 to 3.2, note that the you lose 15% of the 3Ah rated capacity in this range
-float utils_batt_liion_norm_v_to_capacity(float norm_v) {
+float utils_batt_liion_norm_v_to_capacity(float norm_v)
+{
 	// constants for polynomial fit of lithium ion battery
 	const float li_p[] = {
-						  -2.979767, 5.487810, -3.501286, 1.675683, 0.317147};
-	utils_truncate_number(&norm_v,0.0,1.0);
-	float v2 = norm_v*norm_v;
-	float v3 = v2*norm_v;
-	float v4 = v3*norm_v;
-	float v5 = v4*norm_v;
+		-2.979767, 5.487810, -3.501286, 1.675683, 0.317147
+	};
+	utils_truncate_number(&norm_v, 0.0, 1.0);
+	float v2 = norm_v * norm_v;
+	float v3 = v2 * norm_v;
+	float v4 = v3 * norm_v;
+	float v5 = v4 * norm_v;
 	float capacity = li_p[0] * v5 + li_p[1] * v4 + li_p[2] * v3 +
-			li_p[3] * v2 + li_p[4] * norm_v;
+	                 li_p[3] * v2 + li_p[4] * norm_v;
 	return capacity;
 }
 
-static int uint16_cmp_func (const void *a, const void *b) {
+static int uint16_cmp_func(const void* a, const void* b)
+{
 	return (*(uint16_t*)a - *(uint16_t*)b);
 }
 
-uint16_t utils_median_filter_uint16_run(uint16_t *buffer,
-		unsigned int *buffer_index, unsigned int filter_len, uint16_t sample) {
+uint16_t utils_median_filter_uint16_run(
+	uint16_t* buffer,
+	unsigned int* buffer_index, unsigned int filter_len, uint16_t sample
+)
+{
 	buffer[(*buffer_index)++] = sample;
 	*buffer_index %= filter_len;
 	uint16_t buffer_sorted[filter_len]; // Assume we have enough stack space
@@ -826,22 +996,26 @@
 	0.000000, 0.195090, 0.382683, 0.555570, 0.707107, 0.831470, 0.923880, 0.980785,
 	1.000000, 0.980785, 0.923880, 0.831470, 0.707107, 0.555570, 0.382683, 0.195090,
 	0.000000, -0.195090, -0.382683, -0.555570, -0.707107, -0.831470, -0.923880, -0.980785,
-	-1.000000, -0.980785, -0.923880, -0.831470, -0.707107, -0.555570, -0.382683, -0.195090};
+	-1.000000, -0.980785, -0.923880, -0.831470, -0.707107, -0.555570, -0.382683, -0.195090
+};
 
 const float utils_tab_sin_32_2[] = {
 	0.000000, 0.382683, 0.707107, 0.923880, 1.000000, 0.923880, 0.707107, 0.382683,
 	0.000000, -0.382683, -0.707107, -0.923880, -1.000000, -0.923880, -0.707107, -0.382683,
 	-0.000000, 0.382683, 0.707107, 0.923880, 1.000000, 0.923880, 0.707107, 0.382683,
-	0.000000, -0.382683, -0.707107, -0.923880, -1.000000, -0.923880, -0.707107, -0.382683};
+	0.000000, -0.382683, -0.707107, -0.923880, -1.000000, -0.923880, -0.707107, -0.382683
+};
 
 const float utils_tab_cos_32_1[] = {
 	1.000000, 0.980785, 0.923880, 0.831470, 0.707107, 0.555570, 0.382683, 0.195090,
 	0.000000, -0.195090, -0.382683, -0.555570, -0.707107, -0.831470, -0.923880, -0.980785,
 	-1.000000, -0.980785, -0.923880, -0.831470, -0.707107, -0.555570, -0.382683, -0.195090,
-	-0.000000, 0.195090, 0.382683, 0.555570, 0.707107, 0.831470, 0.923880, 0.980785};
+	-0.000000, 0.195090, 0.382683, 0.555570, 0.707107, 0.831470, 0.923880, 0.980785
+};
 
 const float utils_tab_cos_32_2[] = {
 	1.000000, 0.923880, 0.707107, 0.382683, 0.000000, -0.382683, -0.707107, -0.923880,
 	-1.000000, -0.923880, -0.707107, -0.382683, -0.000000, 0.382683, 0.707107, 0.923880,
 	1.000000, 0.923880, 0.707107, 0.382683, 0.000000, -0.382683, -0.707107, -0.923880,
-	-1.000000, -0.923880, -0.707107, -0.382683, -0.000000, 0.382683, 0.707107, 0.923880};
+	-1.000000, -0.923880, -0.707107, -0.382683, -0.000000, 0.382683, 0.707107, 0.923880
+};
Index: mcpwm_foc.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n\tCopyright 2016 - 2020 Benjamin Vedder\tbenjamin@vedder.se\n\n\tThis file is part of the VESC firmware.\n\n\tThe VESC firmware is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The VESC firmware is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n\n#include \"mcpwm_foc.h\"\n#include \"mc_interface.h\"\n#include \"ch.h\"\n#include \"hal.h\"\n#include \"stm32f4xx_conf.h\"\n#include \"digital_filter.h\"\n#include \"utils.h\"\n#include \"ledpwm.h\"\n#include \"terminal.h\"\n#include \"encoder.h\"\n#include \"commands.h\"\n#include \"timeout.h\"\n#include \"timer.h\"\n#include <math.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"virtual_motor.h\"\n#include \"digital_filter.h\"\n\n// Private types\ntypedef struct {\n\tfloat id_target;\n\tfloat iq_target;\n\tfloat max_duty;\n\tfloat duty_now;\n\tfloat phase;\n\tfloat i_alpha;\n\tfloat i_beta;\n\tfloat i_abs;\n\tfloat i_abs_filter;\n\tfloat i_bus;\n\tfloat v_bus;\n\tfloat v_alpha;\n\tfloat v_beta;\n\tfloat mod_d;\n\tfloat mod_q;\n\tfloat id;\n\tfloat iq;\n\tfloat id_filter;\n\tfloat iq_filter;\n\tfloat vd;\n\tfloat vq;\n\tfloat vd_int;\n\tfloat vq_int;\n\tfloat speed_rad_s;\n\tuint32_t svm_sector;\n} motor_state_t;\n\ntypedef struct {\n\tint sample_num;\n\tfloat avg_current_tot;\n\tfloat avg_voltage_tot;\n} mc_sample_t;\n\ntypedef struct {\n\tvoid(*fft_bin0_func)(float*, float*, float*);\n\tvoid(*fft_bin1_func)(float*, float*, float*);\n\tvoid(*fft_bin2_func)(float*, float*, float*);\n\n\tint samples;\n\tint table_fact;\n\tfloat buffer[32];\n\tfloat buffer_current[32];\n\tbool ready;\n\tint ind;\n\tbool is_samp_n;\n\tfloat prev_sample;\n\tfloat angle;\n\tint est_done_cnt;\n\tfloat observer_zero_time;\n\tint flip_cnt;\n} hfi_state_t;\n\ntypedef struct {\n\tvolatile mc_configuration *m_conf;\n\tmc_state m_state;\n\tmc_control_mode m_control_mode;\n\tmotor_state_t m_motor_state;\n\tint m_curr_unbalance;\n\tbool m_phase_override;\n\tfloat m_phase_now_override;\n\tfloat m_duty_cycle_set;\n\tfloat m_id_set;\n\tfloat m_iq_set;\n\tfloat m_openloop_speed;\n\tfloat m_openloop_phase;\n\tbool m_output_on;\n\tfloat m_pos_pid_set;\n\tfloat m_speed_pid_set_rpm;\n\tfloat m_phase_now_observer;\n\tfloat m_phase_now_observer_override;\n\tbool m_phase_observer_override;\n\tfloat m_phase_now_encoder;\n\tfloat m_phase_now_encoder_no_index;\n\tfloat m_observer_x1;\n\tfloat m_observer_x2;\n\tfloat m_pll_phase;\n\tfloat m_pll_speed;\n\tmc_sample_t m_samples;\n\tint m_tachometer;\n\tint m_tachometer_abs;\n\tfloat m_pos_pid_now;\n\tfloat m_gamma_now;\n\tbool m_using_encoder;\n\tfloat m_speed_est_fast;\n\tfloat m_speed_est_faster;\n\tint m_curr_samples;\n\tint m_curr_sum[3];\n\tint m_curr_ofs[3];\n\tint m_duty1_next, m_duty2_next, m_duty3_next;\n\tbool m_duty_next_set;\n\thfi_state_t m_hfi;\n\tint m_hfi_plot_en;\n\tfloat m_hfi_plot_sample;\n\n\tfloat m_phase_before;\n\tfloat m_duty_filtered;\n\tbool m_was_full_brake;\n\tbool m_was_control_duty;\n\tfloat m_duty_i_term;\n\tfloat m_openloop_angle;\n\tfloat m_x1_prev;\n\tfloat m_x2_prev;\n\tfloat m_phase_before_speed_est;\n\tint m_tacho_step_last;\n\tfloat m_pid_div_angle_last;\n\tfloat m_min_rpm_hyst_timer;\n\tfloat m_min_rpm_timer;\n\tbool m_cc_was_hfi;\n\tfloat m_pos_i_term;\n\tfloat m_pos_prev_error;\n\tfloat m_pos_dt_int;\n\tfloat m_pos_d_filter;\n\tfloat m_speed_i_term;\n\tfloat m_speed_prev_error;\n\tfloat m_speed_d_filter;\n\tint m_ang_hall_int_prev;\n\tbool m_using_hall;\n\tfloat m_ang_hall;\n\tfloat m_hall_dt_diff_last;\n\tfloat m_hall_dt_diff_now;\n} motor_all_state_t;\n\n// Private variables\nstatic volatile bool m_dccal_done = false;\nstatic volatile float m_last_adc_isr_duration;\nstatic volatile bool m_init_done = false;\nstatic volatile motor_all_state_t m_motor_1;\n#ifdef HW_HAS_DUAL_MOTORS\nstatic volatile motor_all_state_t m_motor_2;\n#endif\nstatic volatile int m_isr_motor = 0;\n\n// Private functions\nstatic void do_dc_cal(void);\nvoid observer_update(float v_alpha, float v_beta, float i_alpha, float i_beta,\n\t\t\t\t\t float dt, volatile float *x1, volatile float *x2, volatile float *phase, volatile motor_all_state_t *motor);\nstatic void pll_run(float phase, float dt, volatile float *phase_var,\n\t\t\t\t\tvolatile float *speed_var, volatile mc_configuration *conf);\nstatic void control_current(volatile motor_all_state_t *motor, float dt);\nstatic void svm(float alpha, float beta, uint32_t PWMHalfPeriod,\n\t\t\t\tuint32_t* tAout, uint32_t* tBout, uint32_t* tCout, uint32_t *svm_sector);\nstatic void run_pid_control_pos(float angle_now, float angle_set, float dt, volatile motor_all_state_t *motor);\nstatic void run_pid_control_speed(float dt, volatile motor_all_state_t *motor);\nstatic void stop_pwm_hw(volatile motor_all_state_t *motor);\nstatic void start_pwm_hw(volatile motor_all_state_t *motor);\nstatic float correct_encoder(float obs_angle, float enc_angle, float speed, float sl_erpm, volatile motor_all_state_t *motor);\nstatic float correct_hall(float angle, float dt, volatile motor_all_state_t *motor);\nstatic void terminal_plot_hfi(int argc, const char **argv);\nstatic void timer_update(volatile motor_all_state_t *motor, float dt);\nstatic void hfi_update(volatile motor_all_state_t *motor);\n\n// Threads\nstatic THD_WORKING_AREA(timer_thread_wa, 1024);\nstatic THD_FUNCTION(timer_thread, arg);\nstatic volatile bool timer_thd_stop;\n\nstatic THD_WORKING_AREA(hfi_thread_wa, 1024);\nstatic THD_FUNCTION(hfi_thread, arg);\nstatic volatile bool hfi_thd_stop;\n\n// Macros\n#ifdef HW_HAS_3_SHUNTS\n#define TIMER_UPDATE_DUTY_M1(duty1, duty2, duty3) \\\n\t\tTIM1->CR1 |= TIM_CR1_UDIS; \\\n\t\tTIM1->CCR1 = duty1; \\\n\t\tTIM1->CCR2 = duty2; \\\n\t\tTIM1->CCR3 = duty3; \\\n\t\tTIM1->CR1 &= ~TIM_CR1_UDIS;\n\n#define TIMER_UPDATE_DUTY_M2(duty1, duty2, duty3) \\\n\t\tTIM8->CR1 |= TIM_CR1_UDIS; \\\n\t\tTIM8->CCR1 = duty1; \\\n\t\tTIM8->CCR2 = duty2; \\\n\t\tTIM8->CCR3 = duty3; \\\n\t\tTIM8->CR1 &= ~TIM_CR1_UDIS;\n#else\n#define TIMER_UPDATE_DUTY_M1(duty1, duty2, duty3) \\\n\t\tTIM1->CR1 |= TIM_CR1_UDIS; \\\n\t\tTIM1->CCR1 = duty1; \\\n\t\tTIM1->CCR2 = duty3; \\\n\t\tTIM1->CCR3 = duty2; \\\n\t\tTIM1->CR1 &= ~TIM_CR1_UDIS;\n#define TIMER_UPDATE_DUTY_M2(duty1, duty2, duty3) \\\n\t\tTIM8->CR1 |= TIM_CR1_UDIS; \\\n\t\tTIM8->CCR1 = duty1; \\\n\t\tTIM8->CCR2 = duty3; \\\n\t\tTIM8->CCR3 = duty2; \\\n\t\tTIM8->CR1 &= ~TIM_CR1_UDIS;\n#endif\n\n#define TIMER_UPDATE_SAMP(samp) \\\n\t\tTIM2->CCR2 = (samp / 2);\n\n#define TIMER_UPDATE_SAMP_TOP_M1(samp, top) \\\n\t\tTIM1->CR1 |= TIM_CR1_UDIS; \\\n\t\tTIM2->CR1 |= TIM_CR1_UDIS; \\\n\t\tTIM1->ARR = top; \\\n\t\tTIM2->CCR2 = samp / 2; \\\n\t\tTIM1->CR1 &= ~TIM_CR1_UDIS; \\\n\t\tTIM2->CR1 &= ~TIM_CR1_UDIS;\n#define TIMER_UPDATE_SAMP_TOP_M2(samp, top) \\\n\t\tTIM8->CR1 |= TIM_CR1_UDIS; \\\n\t\tTIM2->CR1 |= TIM_CR1_UDIS; \\\n\t\tTIM8->ARR = top; \\\n\t\tTIM2->CCR2 = samp / 2; \\\n\t\tTIM8->CR1 &= ~TIM_CR1_UDIS; \\\n\t\tTIM2->CR1 &= ~TIM_CR1_UDIS;\n\n#ifdef HW_HAS_3_SHUNTS\n#define TIMER_UPDATE_DUTY_SAMP_M1(duty1, duty2, duty3, samp) \\\n\t\tTIM1->CR1 |= TIM_CR1_UDIS; \\\n\t\tTIM2->CR1 |= TIM_CR1_UDIS; \\\n\t\tTIM1->CCR1 = duty1; \\\n\t\tTIM1->CCR2 = duty2; \\\n\t\tTIM1->CCR3 = duty3; \\\n\t\tTIM2->CCR2 = samp / 2; \\\n\t\tTIM1->CR1 &= ~TIM_CR1_UDIS; \\\n\t\tTIM2->CR1 &= ~TIM_CR1_UDIS;\n#define TIMER_UPDATE_DUTY_SAMP_M2(duty1, duty2, duty3, samp) \\\n\t\tTIM8->CR1 |= TIM_CR1_UDIS; \\\n\t\tTIM2->CR1 |= TIM_CR1_UDIS; \\\n\t\tTIM8->CCR1 = duty1; \\\n\t\tTIM8->CCR2 = duty2; \\\n\t\tTIM8->CCR3 = duty3; \\\n\t\tTIM2->CCR2 = samp / 2; \\\n\t\tTIM8->CR1 &= ~TIM_CR1_UDIS; \\\n\t\tTIM2->CR1 &= ~TIM_CR1_UDIS;\n#else\n#define TIMER_UPDATE_DUTY_SAMP_M1(duty1, duty2, duty3, samp) \\\n\t\tTIM1->CR1 |= TIM_CR1_UDIS; \\\n\t\tTIM2->CR1 |= TIM_CR1_UDIS; \\\n\t\tTIM1->CCR1 = duty1; \\\n\t\tTIM1->CCR2 = duty3; \\\n\t\tTIM1->CCR3 = duty2; \\\n\t\tTIM2->CCR2 = samp / 2; \\\n\t\tTIM1->CR1 &= ~TIM_CR1_UDIS; \\\n\t\tTIM2->CR1 &= ~TIM_CR1_UDIS;\n#define TIMER_UPDATE_DUTY_SAMP_M2(duty1, duty2, duty3, samp) \\\n\t\tTIM8->CR1 |= TIM_CR1_UDIS; \\\n\t\tTIM2->CR1 |= TIM_CR1_UDIS; \\\n\t\tTIM8->CCR1 = duty1; \\\n\t\tTIM8->CCR2 = duty3; \\\n\t\tTIM8->CCR3 = duty2; \\\n\t\tTIM2->CCR2 = samp / 2; \\\n\t\tTIM8->CR1 &= ~TIM_CR1_UDIS; \\\n\t\tTIM2->CR1 &= ~TIM_CR1_UDIS;\n#endif\n\nstatic void update_hfi_samples(foc_hfi_samples samples, volatile motor_all_state_t *motor) {\n\tutils_sys_lock_cnt();\n\n\tmemset((void*)&motor->m_hfi, 0, sizeof(motor->m_hfi));\n\tswitch (samples) {\n\tcase HFI_SAMPLES_8:\n\t\tmotor->m_hfi.samples = 8;\n\t\tmotor->m_hfi.table_fact = 4;\n\t\tmotor->m_hfi.fft_bin0_func = utils_fft8_bin0;\n\t\tmotor->m_hfi.fft_bin1_func = utils_fft8_bin1;\n\t\tmotor->m_hfi.fft_bin2_func = utils_fft8_bin2;\n\t\tbreak;\n\n\tcase HFI_SAMPLES_16:\n\t\tmotor->m_hfi.samples = 16;\n\t\tmotor->m_hfi.table_fact = 2;\n\t\tmotor->m_hfi.fft_bin0_func = utils_fft16_bin0;\n\t\tmotor->m_hfi.fft_bin1_func = utils_fft16_bin1;\n\t\tmotor->m_hfi.fft_bin2_func = utils_fft16_bin2;\n\t\tbreak;\n\n\tcase HFI_SAMPLES_32:\n\t\tmotor->m_hfi.samples = 32;\n\t\tmotor->m_hfi.table_fact = 1;\n\t\tmotor->m_hfi.fft_bin0_func = utils_fft32_bin0;\n\t\tmotor->m_hfi.fft_bin1_func = utils_fft32_bin1;\n\t\tmotor->m_hfi.fft_bin2_func = utils_fft32_bin2;\n\t\tbreak;\n\t}\n\n\tutils_sys_unlock_cnt();\n}\n\nstatic void timer_reinit(int f_sw) {\n\tutils_sys_lock_cnt();\n\n\tTIM_DeInit(TIM1);\n\tTIM_DeInit(TIM8);\n\tTIM_DeInit(TIM2);\n\n\tTIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;\n\tTIM_OCInitTypeDef TIM_OCInitStructure;\n\tTIM_BDTRInitTypeDef TIM_BDTRInitStructure;\n\n\tTIM1->CNT = 0;\n\tTIM2->CNT = 0;\n\tTIM8->CNT = 0;\n\n\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);\n\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM8, ENABLE);\n\n\t// Time Base configuration\n\tTIM_TimeBaseStructure.TIM_Prescaler = 0;\n\tTIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_CenterAligned1;\n\tTIM_TimeBaseStructure.TIM_Period = (SYSTEM_CORE_CLOCK / f_sw);\n\tTIM_TimeBaseStructure.TIM_ClockDivision = 0;\n\tTIM_TimeBaseStructure.TIM_RepetitionCounter = 0;\n\n\tTIM_TimeBaseInit(TIM1, &TIM_TimeBaseStructure);\n\tTIM_TimeBaseInit(TIM8, &TIM_TimeBaseStructure);\n\n\t// Channel 1, 2 and 3 Configuration in PWM mode\n\tTIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;\n\tTIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;\n\tTIM_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Enable;\n\tTIM_OCInitStructure.TIM_Pulse = TIM1->ARR / 2;\n\tTIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;\n\tTIM_OCInitStructure.TIM_OCNPolarity = TIM_OCNPolarity_High;\n\tTIM_OCInitStructure.TIM_OCIdleState = TIM_OCIdleState_Set;\n\tTIM_OCInitStructure.TIM_OCNIdleState = TIM_OCNIdleState_Set;\n\n\tTIM_OC1Init(TIM1, &TIM_OCInitStructure);\n\tTIM_OC2Init(TIM1, &TIM_OCInitStructure);\n\tTIM_OC3Init(TIM1, &TIM_OCInitStructure);\n\tTIM_OC4Init(TIM1, &TIM_OCInitStructure);\n\n\tTIM_OC1PreloadConfig(TIM1, TIM_OCPreload_Enable);\n\tTIM_OC2PreloadConfig(TIM1, TIM_OCPreload_Enable);\n\tTIM_OC3PreloadConfig(TIM1, TIM_OCPreload_Enable);\n\tTIM_OC4PreloadConfig(TIM1, TIM_OCPreload_Enable);\n\n\tTIM_OC1Init(TIM8, &TIM_OCInitStructure);\n\tTIM_OC2Init(TIM8, &TIM_OCInitStructure);\n\tTIM_OC3Init(TIM8, &TIM_OCInitStructure);\n\tTIM_OC4Init(TIM8, &TIM_OCInitStructure);\n\n\tTIM_OC1PreloadConfig(TIM8, TIM_OCPreload_Enable);\n\tTIM_OC2PreloadConfig(TIM8, TIM_OCPreload_Enable);\n\tTIM_OC3PreloadConfig(TIM8, TIM_OCPreload_Enable);\n\tTIM_OC4PreloadConfig(TIM8, TIM_OCPreload_Enable);\n\n\t// Automatic Output enable, Break, dead time and lock configuration\n\tTIM_BDTRInitStructure.TIM_OSSRState = TIM_OSSRState_Enable;\n\tTIM_BDTRInitStructure.TIM_OSSIState = TIM_OSSIState_Enable;\n\tTIM_BDTRInitStructure.TIM_LOCKLevel = TIM_LOCKLevel_OFF;\n\tTIM_BDTRInitStructure.TIM_DeadTime =  conf_general_calculate_deadtime(HW_DEAD_TIME_NSEC, SYSTEM_CORE_CLOCK);\n\tTIM_BDTRInitStructure.TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;\n\n#ifdef HW_USE_BRK\n\t// Enable BRK function. Hardware will asynchronously stop any PWM activity upon an\n\t// external fault signal. PWM outputs remain disabled until MCU is reset.\n\t// software will catch the BRK flag to report the fault code\n\tTIM_BDTRInitStructure.TIM_Break = TIM_Break_Enable;\n\tTIM_BDTRInitStructure.TIM_BreakPolarity = TIM_BreakPolarity_Low;\n#else\n\tTIM_BDTRInitStructure.TIM_Break = TIM_Break_Disable;\n\tTIM_BDTRInitStructure.TIM_BreakPolarity = TIM_BreakPolarity_High;\n#endif\n\n\tTIM_BDTRConfig(TIM1, &TIM_BDTRInitStructure);\n\tTIM_CCPreloadControl(TIM1, ENABLE);\n\tTIM_ARRPreloadConfig(TIM1, ENABLE);\n\n\tTIM_BDTRConfig(TIM8, &TIM_BDTRInitStructure);\n\tTIM_CCPreloadControl(TIM8, ENABLE);\n\tTIM_ARRPreloadConfig(TIM8, ENABLE);\n\n\t// ------------- Timer2 for ADC sampling ------------- //\n\t// Time Base configuration\n\tRCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);\n\n\tTIM_TimeBaseStructure.TIM_Prescaler = 0;\n\tTIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;\n\tTIM_TimeBaseStructure.TIM_Period = 0xFFFF;\n\tTIM_TimeBaseStructure.TIM_ClockDivision = 0;\n\tTIM_TimeBaseStructure.TIM_RepetitionCounter = 0;\n\tTIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);\n\n\tTIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;\n\tTIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;\n\tTIM_OCInitStructure.TIM_Pulse = 250;\n\tTIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;\n\tTIM_OCInitStructure.TIM_OCNPolarity = TIM_OCNPolarity_High;\n\tTIM_OCInitStructure.TIM_OCIdleState = TIM_OCIdleState_Set;\n\tTIM_OCInitStructure.TIM_OCNIdleState = TIM_OCNIdleState_Set;\n\tTIM_OC1Init(TIM2, &TIM_OCInitStructure);\n\tTIM_OC1PreloadConfig(TIM2, TIM_OCPreload_Enable);\n\tTIM_OC2Init(TIM2, &TIM_OCInitStructure);\n\tTIM_OC2PreloadConfig(TIM2, TIM_OCPreload_Enable);\n\tTIM_OC3Init(TIM2, &TIM_OCInitStructure);\n\tTIM_OC3PreloadConfig(TIM2, TIM_OCPreload_Enable);\n\n\tTIM_ARRPreloadConfig(TIM2, ENABLE);\n\tTIM_CCPreloadControl(TIM2, ENABLE);\n\n\t// PWM outputs have to be enabled in order to trigger ADC on CCx\n\tTIM_CtrlPWMOutputs(TIM2, ENABLE);\n\n\t// TIM1 Master and TIM8 slave\n#if defined HW_HAS_DUAL_MOTORS || defined HW_HAS_DUAL_PARALLEL\n\t// TODO: Explain. See: https://www.cnblogs.com/shangdawei/p/4758988.html\n\tTIM_SelectOutputTrigger(TIM1, TIM_TRGOSource_Enable);\n\tTIM_SelectMasterSlaveMode(TIM1, TIM_MasterSlaveMode_Enable);\n\tTIM_SelectInputTrigger(TIM8, TIM_TS_ITR0);\n\tTIM_SelectSlaveMode(TIM8, TIM_SlaveMode_Trigger);\n\tTIM_SelectOutputTrigger(TIM8, TIM_TRGOSource_Enable);\n\tTIM_SelectOutputTrigger(TIM8, TIM_TRGOSource_Update);\n\tTIM_SelectInputTrigger(TIM2, TIM_TS_ITR1);\n\tTIM_SelectSlaveMode(TIM2, TIM_SlaveMode_Reset);\n#else\n\tTIM_SelectOutputTrigger(TIM1, TIM_TRGOSource_Update);\n\tTIM_SelectMasterSlaveMode(TIM1, TIM_MasterSlaveMode_Enable);\n\tTIM_SelectInputTrigger(TIM2, TIM_TS_ITR0);\n\tTIM_SelectSlaveMode(TIM2, TIM_SlaveMode_Reset);\n#endif\n\n\t// Enable TIM1 and TIM2\n#ifdef HW_HAS_DUAL_MOTORS\n\tTIM8->CNT = TIM1->ARR;\n#else\n\tTIM8->CNT = 0;\n#endif\n\tTIM1->CNT = 0;\n\tTIM_Cmd(TIM1, ENABLE);\n\tTIM_Cmd(TIM2, ENABLE);\n\n\t// Prevent all low side FETs from switching on\n\tstop_pwm_hw(&m_motor_1);\n#ifdef HW_HAS_DUAL_MOTORS\n\tstop_pwm_hw(&m_motor_2);\n#endif\n\n\t// Main Output Enable\n\tTIM_CtrlPWMOutputs(TIM1, ENABLE);\n\tTIM_CtrlPWMOutputs(TIM8, ENABLE);\n\n\t// Sample intervals\n\tTIMER_UPDATE_SAMP(MCPWM_FOC_CURRENT_SAMP_OFFSET);\n\n\t// Enable CC2 interrupt, which will be fired in V0 and V7\n\tTIM_ITConfig(TIM2, TIM_IT_CC2, ENABLE);\n\tutils_sys_unlock_cnt();\n\n\tnvicEnableVector(TIM2_IRQn, 6);\n}\n\nvoid mcpwm_foc_init(volatile mc_configuration *conf_m1, volatile mc_configuration *conf_m2) {\n\tutils_sys_lock_cnt();\n\n#ifndef HW_HAS_DUAL_MOTORS\n\t(void)conf_m2;\n#endif\n\n\tm_init_done = false;\n\n\t// Initialize variables\n\tmemset((void*)&m_motor_1, 0, sizeof(motor_all_state_t));\n\tm_isr_motor = 0;\n\n\tm_motor_1.m_conf = conf_m1;\n\tm_motor_1.m_state = MC_STATE_OFF;\n\tm_motor_1.m_control_mode = CONTROL_MODE_NONE;\n\tm_motor_1.m_hall_dt_diff_last = 1.0;\n#ifdef HW_HAS_DUAL_PARALLEL\n\tm_motor_1.m_curr_ofs[0] = 4096;\n\tm_motor_1.m_curr_ofs[1] = 4096;\n\tm_motor_1.m_curr_ofs[2] = 4096;\n#else\n\tm_motor_1.m_curr_ofs[0] = 2048;\n\tm_motor_1.m_curr_ofs[1] = 2048;\n\tm_motor_1.m_curr_ofs[2] = 2048;\n#endif\n\tupdate_hfi_samples(m_motor_1.m_conf->foc_hfi_samples, &m_motor_1);\n\n#ifdef HW_HAS_DUAL_MOTORS\n\tmemset((void*)&m_motor_2, 0, sizeof(motor_all_state_t));\n\tm_motor_2.m_conf = conf_m2;\n\tm_motor_2.m_state = MC_STATE_OFF;\n\tm_motor_2.m_control_mode = CONTROL_MODE_NONE;\n\tm_motor_2.m_hall_dt_diff_last = 1.0;\n\tm_motor_2.m_curr_ofs[0] = 2048;\n\tm_motor_2.m_curr_ofs[1] = 2048;\n\tm_motor_2.m_curr_ofs[2] = 2048;\n\tupdate_hfi_samples(m_motor_2.m_conf->foc_hfi_samples, &m_motor_2);\n#endif\n\n\tvirtual_motor_init();\n\n\tTIM_DeInit(TIM1);\n\tTIM_DeInit(TIM2);\n\tTIM_DeInit(TIM8);\n\tTIM1->CNT = 0;\n\tTIM2->CNT = 0;\n\tTIM8->CNT = 0;\n\n\t// ADC\n\tADC_CommonInitTypeDef ADC_CommonInitStructure;\n\tDMA_InitTypeDef DMA_InitStructure;\n\tADC_InitTypeDef ADC_InitStructure;\n\n\t// Clock\n\tRCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA2 | RCC_AHB1Periph_GPIOA | RCC_AHB1Periph_GPIOC, ENABLE);\n\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 | RCC_APB2Periph_ADC2 | RCC_APB2Periph_ADC3, ENABLE);\n\n\tdmaStreamAllocate(STM32_DMA_STREAM(STM32_DMA_STREAM_ID(2, 4)),\n\t\t\t\t\t  5,\n\t\t\t\t\t  (stm32_dmaisr_t)mcpwm_foc_adc_int_handler,\n\t\t\t\t\t  (void *)0);\n\n\t// DMA for the ADC\n\tDMA_InitStructure.DMA_Channel = DMA_Channel_0;\n\tDMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)&ADC_Value;\n\tDMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&ADC->CDR;\n\tDMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory;\n\tDMA_InitStructure.DMA_BufferSize = HW_ADC_CHANNELS;\n\tDMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;\n\tDMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;\n\tDMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;\n\tDMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;\n\tDMA_InitStructure.DMA_Mode = DMA_Mode_Circular;\n\tDMA_InitStructure.DMA_Priority = DMA_Priority_High;\n\tDMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable;\n\tDMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_1QuarterFull;\n\tDMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;\n\tDMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;\n\tDMA_Init(DMA2_Stream4, &DMA_InitStructure);\n\n\tDMA_Cmd(DMA2_Stream4, ENABLE);\n\tDMA_ITConfig(DMA2_Stream4, DMA_IT_TC, ENABLE);\n\n\t// ADC Common Init\n\t// Note that the ADC is running at 42MHz, which is higher than the\n\t// specified 36MHz in the data sheet, but it works.\n\tADC_CommonInitStructure.ADC_Mode = ADC_TripleMode_RegSimult;\n\tADC_CommonInitStructure.ADC_Prescaler = ADC_Prescaler_Div2;\n\tADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_1;\n\tADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;\n\tADC_CommonInit(&ADC_CommonInitStructure);\n\n\t// Channel-specific settings\n\tADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;\n\tADC_InitStructure.ADC_ScanConvMode = ENABLE;\n\tADC_InitStructure.ADC_ContinuousConvMode = DISABLE;\n\tADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_Falling;\n\tADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_T2_CC2;\n\tADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;\n\tADC_InitStructure.ADC_NbrOfConversion = HW_ADC_NBR_CONV;\n\n\tADC_Init(ADC1, &ADC_InitStructure);\n\tADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;\n\tADC_InitStructure.ADC_ExternalTrigConv = 0;\n\tADC_Init(ADC2, &ADC_InitStructure);\n\tADC_Init(ADC3, &ADC_InitStructure);\n\n\tADC_TempSensorVrefintCmd(ENABLE);\n\tADC_MultiModeDMARequestAfterLastTransferCmd(ENABLE);\n\n\thw_setup_adc_channels();\n\n\tADC_Cmd(ADC1, ENABLE);\n\tADC_Cmd(ADC2, ENABLE);\n\tADC_Cmd(ADC3, ENABLE);\n\n\ttimer_reinit((int)m_motor_1.m_conf->foc_f_sw);\n\n\tstop_pwm_hw(&m_motor_1);\n#ifdef HW_HAS_DUAL_MOTORS\n\tstop_pwm_hw(&m_motor_2);\n#endif\n\n\t// Sample intervals. For now they are fixed with voltage samples in the center of V7\n\t// and current samples in the center of V0\n\tTIMER_UPDATE_SAMP(MCPWM_FOC_CURRENT_SAMP_OFFSET);\n\n\t// Enable CC2 interrupt, which will be fired in V0 and V7\n\tTIM_ITConfig(TIM2, TIM_IT_CC2, ENABLE);\n\tnvicEnableVector(TIM2_IRQn, 6);\n\n\tutils_sys_unlock_cnt();\n\n\tCURRENT_FILTER_ON();\n\n\t// Calibrate current offset\n\tENABLE_GATE();\n\tDCCAL_OFF();\n\tdo_dc_cal();\n\n\t// Start threads\n\ttimer_thd_stop = false;\n\tchThdCreateStatic(timer_thread_wa, sizeof(timer_thread_wa), NORMALPRIO, timer_thread, NULL);\n\n\thfi_thd_stop = false;\n\tchThdCreateStatic(hfi_thread_wa, sizeof(hfi_thread_wa), NORMALPRIO, hfi_thread, NULL);\n\n\t// Check if the system has resumed from IWDG reset\n\tif (timeout_had_IWDG_reset()) {\n\t\tmc_interface_fault_stop(FAULT_CODE_BOOTING_FROM_WATCHDOG_RESET, false, false);\n\t}\n\n\tterminal_register_command_callback(\n\t\t\t\"foc_plot_hfi_en\",\n\t\t\t\"Enable HFI plotting. 0: off, 1: DFT, 2: Raw\",\n\t\t\t\"[en]\",\n\t\t\tterminal_plot_hfi);\n\n\tm_init_done = true;\n}\n\nvoid mcpwm_foc_deinit(void) {\n\tif (!m_init_done) {\n\t\treturn;\n\t}\n\n\tm_init_done = false;\n\n\ttimer_thd_stop = true;\n\twhile (timer_thd_stop) {\n\t\tchThdSleepMilliseconds(1);\n\t}\n\n\thfi_thd_stop = true;\n\twhile (hfi_thd_stop) {\n\t\tchThdSleepMilliseconds(1);\n\t}\n\n\tTIM_DeInit(TIM1);\n\tTIM_DeInit(TIM2);\n\tTIM_DeInit(TIM8);\n\tADC_DeInit();\n\tDMA_DeInit(DMA2_Stream4);\n\tnvicDisableVector(ADC_IRQn);\n\tdmaStreamRelease(STM32_DMA_STREAM(STM32_DMA_STREAM_ID(2, 4)));\n}\n\nstatic volatile motor_all_state_t *motor_now(void) {\n#ifdef HW_HAS_DUAL_MOTORS\n\treturn mc_interface_motor_now() == 1 ? &m_motor_1 : &m_motor_2;\n#else\n\treturn &m_motor_1;\n#endif\n}\n\nbool mcpwm_foc_init_done(void) {\n\treturn m_init_done;\n}\n\nvoid mcpwm_foc_set_configuration(volatile mc_configuration *configuration) {\n\tmotor_now()->m_conf = configuration;\n\n\t// Below we check if anything in the configuration changed that requires stopping the motor.\n\n\tuint32_t top = SYSTEM_CORE_CLOCK / (int)configuration->foc_f_sw;\n\tif (TIM1->ARR != top) {\n#ifdef HW_HAS_DUAL_MOTORS\n\t\tm_motor_1.m_control_mode = CONTROL_MODE_NONE;\n\t\tm_motor_1.m_state = MC_STATE_OFF;\n\t\tstop_pwm_hw(&m_motor_1);\n\n\t\tm_motor_2.m_control_mode = CONTROL_MODE_NONE;\n\t\tm_motor_2.m_state = MC_STATE_OFF;\n\t\tstop_pwm_hw(&m_motor_2);\n\n\t\ttimer_reinit((int)configuration->foc_f_sw);\n#else\n\t\tmotor_now()->m_control_mode = CONTROL_MODE_NONE;\n\t\tmotor_now()->m_state = MC_STATE_OFF;\n\t\tstop_pwm_hw(motor_now());\n\t\tTIMER_UPDATE_SAMP_TOP_M1(MCPWM_FOC_CURRENT_SAMP_OFFSET, top);\n#ifdef  HW_HAS_DUAL_PARALLEL\n\t\tTIMER_UPDATE_SAMP_TOP_M2(MCPWM_FOC_CURRENT_SAMP_OFFSET, top);\n#endif\n#endif\n\t}\n\n\tif (((1 << motor_now()->m_conf->foc_hfi_samples) * 8) != motor_now()->m_hfi.samples) {\n\t\tmotor_now()->m_control_mode = CONTROL_MODE_NONE;\n\t\tmotor_now()->m_state = MC_STATE_OFF;\n\t\tstop_pwm_hw(motor_now());\n\t\tupdate_hfi_samples(motor_now()->m_conf->foc_hfi_samples, motor_now());\n\t}\n}\n\nmc_state mcpwm_foc_get_state(void) {\n\treturn motor_now()->m_state;\n}\n\nbool mcpwm_foc_is_dccal_done(void) {\n\treturn m_dccal_done;\n}\n\n/**\n * Get the current motor used in the mcpwm ISR\n *\n * @return\n * 0: Not in ISR\n * 1: Motor 1\n * 2: Motor 2\n */\nint mcpwm_foc_isr_motor(void) {\n\treturn m_isr_motor;\n}\n\n/**\n * Switch off all FETs.\n */\nvoid mcpwm_foc_stop_pwm(bool is_second_motor) {\n#ifdef HW_HAS_DUAL_MOTORS\n\tvolatile motor_all_state_t *motor = is_second_motor ? &m_motor_2 : &m_motor_1;\n#else\n\t(void)is_second_motor;\n\tvolatile motor_all_state_t *motor = &m_motor_1;\n#endif\n\n\tmotor->m_control_mode = CONTROL_MODE_NONE;\n\tmotor->m_state = MC_STATE_OFF;\n\tstop_pwm_hw(motor);\n}\n\n/**\n * Use duty cycle control. Absolute values less than MCPWM_MIN_DUTY_CYCLE will\n * stop the motor.\n *\n * @param dutyCycle\n * The duty cycle to use.\n */\nvoid mcpwm_foc_set_duty(float dutyCycle) {\n\tmotor_now()->m_control_mode = CONTROL_MODE_DUTY;\n\tmotor_now()->m_duty_cycle_set = dutyCycle;\n\n\tif (motor_now()->m_state != MC_STATE_RUNNING) {\n\t\tmotor_now()->m_state = MC_STATE_RUNNING;\n\t}\n}\n\n/**\n * Use duty cycle control. Absolute values less than MCPWM_MIN_DUTY_CYCLE will\n * stop the motor.\n *\n * WARNING: This function does not use ramping. A too large step with a large motor\n * can destroy hardware.\n *\n * @param dutyCycle\n * The duty cycle to use.\n */\nvoid mcpwm_foc_set_duty_noramp(float dutyCycle) {\n\t// TODO: Actually do this without ramping\n\tmcpwm_foc_set_duty(dutyCycle);\n}\n\n/**\n * Use PID rpm control. Note that this value has to be multiplied by half of\n * the number of motor poles.\n *\n * @param rpm\n * The electrical RPM goal value to use.\n */\nvoid mcpwm_foc_set_pid_speed(float rpm) {\n\tmotor_now()->m_control_mode = CONTROL_MODE_SPEED;\n\tmotor_now()->m_speed_pid_set_rpm = rpm;\n\n\tif (motor_now()->m_state != MC_STATE_RUNNING) {\n\t\tmotor_now()->m_state = MC_STATE_RUNNING;\n\t}\n}\n\n/**\n * Use PID position control. Note that this only works when encoder support\n * is enabled.\n *\n * @param pos\n * The desired position of the motor in degrees.\n */\nvoid mcpwm_foc_set_pid_pos(float pos) {\n\tmotor_now()->m_control_mode = CONTROL_MODE_POS;\n\tmotor_now()->m_pos_pid_set = pos;\n\n\tif (motor_now()->m_state != MC_STATE_RUNNING) {\n\t\tmotor_now()->m_state = MC_STATE_RUNNING;\n\t}\n}\n\n/**\n * Use current control and specify a goal current to use. The sign determines\n * the direction of the torque. Absolute values less than\n * conf->cc_min_current will release the motor.\n *\n * @param current\n * The current to use.\n */\nvoid mcpwm_foc_set_current(float current) {\n\tif (fabsf(current) < motor_now()->m_conf->cc_min_current) {\n\t\tmotor_now()->m_control_mode = CONTROL_MODE_NONE;\n\t\tmotor_now()->m_state = MC_STATE_OFF;\n\t\tstop_pwm_hw(motor_now());\n\t\treturn;\n\t}\n\n\tmotor_now()->m_control_mode = CONTROL_MODE_CURRENT;\n\tmotor_now()->m_iq_set = current;\n\n\tif (motor_now()->m_state != MC_STATE_RUNNING) {\n\t\tmotor_now()->m_state = MC_STATE_RUNNING;\n\t}\n}\n\n/**\n * Brake the motor with a desired current. Absolute values less than\n * conf->cc_min_current will release the motor.\n *\n * @param current\n * The current to use. Positive and negative values give the same effect.\n */\nvoid mcpwm_foc_set_brake_current(float current) {\n\tif (fabsf(current) < motor_now()->m_conf->cc_min_current) {\n\t\tmotor_now()->m_control_mode = CONTROL_MODE_NONE;\n\t\tmotor_now()->m_state = MC_STATE_OFF;\n\t\tstop_pwm_hw(motor_now());\n\t\treturn;\n\t}\n\n\tmotor_now()->m_control_mode = CONTROL_MODE_CURRENT_BRAKE;\n\tmotor_now()->m_iq_set = current;\n\n\tif (motor_now()->m_state != MC_STATE_RUNNING) {\n\t\tmotor_now()->m_state = MC_STATE_RUNNING;\n\t}\n}\n\n/**\n * Apply a fixed static current vector in open loop to emulate an electric\n * handbrake.\n *\n * @param current\n * The brake current to use.\n */\nvoid mcpwm_foc_set_handbrake(float current) {\n\tif (fabsf(current) < motor_now()->m_conf->cc_min_current) {\n\t\tmotor_now()->m_control_mode = CONTROL_MODE_NONE;\n\t\tmotor_now()->m_state = MC_STATE_OFF;\n\t\tstop_pwm_hw(motor_now());\n\t\treturn;\n\t}\n\n\tmotor_now()->m_control_mode = CONTROL_MODE_HANDBRAKE;\n\tmotor_now()->m_iq_set = current;\n\n\tif (motor_now()->m_state != MC_STATE_RUNNING) {\n\t\tmotor_now()->m_state = MC_STATE_RUNNING;\n\t}\n}\n\n/**\n * Produce an openloop rotating current.\n *\n * @param current\n * The current to use.\n *\n * @param rpm\n * The RPM to use.\n */\nvoid mcpwm_foc_set_openloop(float current, float rpm) {\n\tif (fabsf(current) < motor_now()->m_conf->cc_min_current) {\n\t\tmotor_now()->m_control_mode = CONTROL_MODE_NONE;\n\t\tmotor_now()->m_state = MC_STATE_OFF;\n\t\tstop_pwm_hw(motor_now());\n\t\treturn;\n\t}\n\n\tutils_truncate_number(&current, -motor_now()->m_conf->l_current_max * motor_now()->m_conf->l_current_max_scale,\n\t\t\t\t\t\t  motor_now()->m_conf->l_current_max * motor_now()->m_conf->l_current_max_scale);\n\n\tmotor_now()->m_control_mode = CONTROL_MODE_OPENLOOP;\n\tmotor_now()->m_iq_set = current;\n\tmotor_now()->m_openloop_speed = rpm * ((2.0 * M_PI) / 60.0);\n\n\tif (motor_now()->m_state != MC_STATE_RUNNING) {\n\t\tmotor_now()->m_state = MC_STATE_RUNNING;\n\t}\n}\n\n/**\n * Produce an openloop current at a fixed phase.\n *\n * @param current\n * The current to use.\n *\n * @param phase\n * The phase to use in degrees, range [0.0 360.0]\n */\nvoid mcpwm_foc_set_openloop_phase(float current, float phase) {\n\tif (fabsf(current) < motor_now()->m_conf->cc_min_current) {\n\t\tmotor_now()->m_control_mode = CONTROL_MODE_NONE;\n\t\tmotor_now()->m_state = MC_STATE_OFF;\n\t\tstop_pwm_hw(motor_now());\n\t\treturn;\n\t}\n\n\tutils_truncate_number(&current, -motor_now()->m_conf->l_current_max * motor_now()->m_conf->l_current_max_scale,\n\t\t\t\t\t\t  motor_now()->m_conf->l_current_max * motor_now()->m_conf->l_current_max_scale);\n\n\tmotor_now()->m_control_mode = CONTROL_MODE_OPENLOOP_PHASE;\n\tmotor_now()->m_iq_set = current;\n\n\tmotor_now()->m_openloop_phase = phase * M_PI / 180.0;\n\tutils_norm_angle_rad((float*)&motor_now()->m_openloop_phase);\n\n\tif (motor_now()->m_state != MC_STATE_RUNNING) {\n\t\tmotor_now()->m_state = MC_STATE_RUNNING;\n\t}\n}\n\n/**\n * Set current offsets values,\n * this is used by the virtual motor to set the previously saved offsets back,\n * when it is disconnected\n */\nvoid mcpwm_foc_set_current_offsets(volatile int curr0_offset,\n\t\t\t\t\t\t\t\t   volatile int curr1_offset,\n\t\t\t\t\t\t\t\t   volatile int curr2_offset) {\n\tmotor_now()->m_curr_ofs[0] = curr0_offset;\n\tmotor_now()->m_curr_ofs[1] = curr1_offset;\n\tmotor_now()->m_curr_ofs[2] = curr2_offset;\n}\n\n/**\n * Produce an openloop rotating voltage.\n *\n * @param dutyCycle\n * The duty cycle to use.\n *\n * @param rpm\n * The RPM to use.\n */\nvoid mcpwm_foc_set_openloop_duty(float dutyCycle, float rpm) {\n\tmotor_now()->m_control_mode = CONTROL_MODE_OPENLOOP_DUTY;\n\tmotor_now()->m_duty_cycle_set = dutyCycle;\n\tmotor_now()->m_openloop_speed = rpm * ((2.0 * M_PI) / 60.0);\n\n\tif (motor_now()->m_state != MC_STATE_RUNNING) {\n\t\tmotor_now()->m_state = MC_STATE_RUNNING;\n\t}\n}\n\n/**\n * Produce an openloop voltage at a fixed phase.\n *\n * @param dutyCycle\n * The duty cycle to use.\n *\n * @param phase\n * The phase to use in degrees, range [0.0 360.0]\n */\nvoid mcpwm_foc_set_openloop_duty_phase(float dutyCycle, float phase) {\n\tmotor_now()->m_control_mode = CONTROL_MODE_OPENLOOP_DUTY_PHASE;\n\tmotor_now()->m_duty_cycle_set = dutyCycle;\n\tmotor_now()->m_openloop_phase = phase * M_PI / 180.0;\n\tutils_norm_angle_rad((float*)&motor_now()->m_openloop_phase);\n\n\tif (motor_now()->m_state != MC_STATE_RUNNING) {\n\t\tmotor_now()->m_state = MC_STATE_RUNNING;\n\t}\n}\n\nfloat mcpwm_foc_get_duty_cycle_set(void) {\n\treturn motor_now()->m_duty_cycle_set;\n}\n\nfloat mcpwm_foc_get_duty_cycle_now(void) {\n\treturn motor_now()->m_motor_state.duty_now;\n}\n\nfloat mcpwm_foc_get_pid_pos_set(void) {\n\treturn motor_now()->m_pos_pid_set;\n}\n\nfloat mcpwm_foc_get_pid_pos_now(void) {\n\treturn motor_now()->m_pos_pid_now;\n}\n\n/**\n * Get the current switching frequency.\n *\n * @return\n * The switching frequency in Hz.\n */\nfloat mcpwm_foc_get_switching_frequency_now(void) {\n\treturn motor_now()->m_conf->foc_f_sw;\n}\n\n/**\n * Get the current sampling frequency.\n *\n * @return\n * The sampling frequency in Hz.\n */\nfloat mcpwm_foc_get_sampling_frequency_now(void) {\n#ifdef HW_HAS_PHASE_SHUNTS\n\tif (motor_now()->m_conf->foc_sample_v0_v7) {\n\t\treturn motor_now()->m_conf->foc_f_sw;\n\t} else {\n\t\treturn motor_now()->m_conf->foc_f_sw / 2.0;\n\t}\n#else\n\treturn motor_now()->m_conf->foc_f_sw / 2.0;\n#endif\n}\n\n/**\n * Returns Ts used for virtual motor sync\n */\nfloat mcpwm_foc_get_ts(void) {\n#ifdef HW_HAS_PHASE_SHUNTS\n\tif (motor_now()->m_conf->foc_sample_v0_v7) {\n\t\treturn (1.0 / motor_now()->m_conf->foc_f_sw) ;\n\t} else {\n\t\treturn (1.0 / (motor_now()->m_conf->foc_f_sw / 2.0));\n\t}\n#else\n\treturn (1.0 / motor_now()->m_conf->foc_f_sw) ;\n#endif\n}\n\nbool mcpwm_foc_is_using_encoder(void) {\n\treturn motor_now()->m_using_encoder;\n}\n\nfloat mcpwm_foc_get_tot_current_motor(bool is_second_motor) {\n#ifdef HW_HAS_DUAL_MOTORS\n\tvolatile motor_all_state_t *motor = is_second_motor ? &m_motor_2 : &m_motor_1;\n\treturn SIGN(motor->m_motor_state.vq) * motor->m_motor_state.iq;\n#else\n\t(void)is_second_motor;\n\treturn SIGN(m_motor_1.m_motor_state.vq) * m_motor_1.m_motor_state.iq;\n#endif\n}\n\nfloat mcpwm_foc_get_tot_current_filtered_motor(bool is_second_motor) {\n#ifdef HW_HAS_DUAL_MOTORS\n\tvolatile motor_all_state_t *motor = is_second_motor ? &m_motor_2 : &m_motor_1;\n\treturn SIGN(motor->m_motor_state.vq) * motor->m_motor_state.iq_filter;\n#else\n\t(void)is_second_motor;\n\treturn SIGN(m_motor_1.m_motor_state.vq) * m_motor_1.m_motor_state.iq_filter;\n#endif\n}\n\nfloat mcpwm_foc_get_tot_current_in_motor(bool is_second_motor) {\n#ifdef HW_HAS_DUAL_MOTORS\n\treturn (is_second_motor ? &m_motor_2 : &m_motor_1)->m_motor_state.i_bus;\n#else\n\t(void)is_second_motor;\n\treturn m_motor_1.m_motor_state.i_bus;\n#endif\n}\n\nfloat mcpwm_foc_get_tot_current_in_filtered_motor(bool is_second_motor) {\n\t// TODO: Filter current?\n#ifdef HW_HAS_DUAL_MOTORS\n\treturn (is_second_motor ? &m_motor_2 : &m_motor_1)->m_motor_state.i_bus;\n#else\n\t(void)is_second_motor;\n\treturn m_motor_1.m_motor_state.i_bus;\n#endif\n}\n\nfloat mcpwm_foc_get_abs_motor_current_motor(bool is_second_motor) {\n#ifdef HW_HAS_DUAL_MOTORS\n\treturn (is_second_motor ? &m_motor_2 : &m_motor_1)->m_motor_state.i_abs;\n#else\n\t(void)is_second_motor;\n\treturn m_motor_1.m_motor_state.i_abs;\n#endif\n}\n\nfloat mcpwm_foc_get_abs_motor_current_filtered_motor(bool is_second_motor) {\n#ifdef HW_HAS_DUAL_MOTORS\n\treturn (is_second_motor ? &m_motor_2 : &m_motor_1)->m_motor_state.i_abs_filter;\n#else\n\t(void)is_second_motor;\n\treturn m_motor_1.m_motor_state.i_abs_filter;\n#endif\n}\n\nmc_state mcpwm_foc_get_state_motor(bool is_second_motor) {\n#ifdef HW_HAS_DUAL_MOTORS\n\treturn (is_second_motor ? &m_motor_2 : &m_motor_1)->m_state;\n#else\n\t(void)is_second_motor;\n\treturn m_motor_1.m_state;\n#endif\n}\n\n/**\n * Calculate the current RPM of the motor. This is a signed value and the sign\n * depends on the direction the motor is rotating in. Note that this value has\n * to be divided by half the number of motor poles.\n *\n * @return\n * The RPM value.\n */\nfloat mcpwm_foc_get_rpm(void) {\n\treturn motor_now()->m_motor_state.speed_rad_s / ((2.0 * M_PI) / 60.0);\n\t//\treturn motor_now()->m_speed_est_fast / ((2.0 * M_PI) / 60.0);\n}\n\n/**\n * Same as above, but uses the fast and noisier estimator.\n */\nfloat mcpwm_foc_get_rpm_fast(void) {\n\treturn motor_now()->m_speed_est_fast / ((2.0 * M_PI) / 60.0);\n}\n\n/**\n * Same as above, but uses the faster and noisier estimator.\n */\nfloat mcpwm_foc_get_rpm_faster(void) {\n\treturn motor_now()->m_speed_est_faster / ((2.0 * M_PI) / 60.0);\n}\n\n/**\n * Get the motor current. The sign of this value will\n * represent whether the motor is drawing (positive) or generating\n * (negative) current. This is the q-axis current which produces torque.\n *\n * @return\n * The motor current.\n */\nfloat mcpwm_foc_get_tot_current(void) {\n\treturn SIGN(motor_now()->m_motor_state.vq) * motor_now()->m_motor_state.iq;\n}\n\n/**\n * Get the filtered motor current. The sign of this value will\n * represent whether the motor is drawing (positive) or generating\n * (negative) current. This is the q-axis current which produces torque.\n *\n * @return\n * The filtered motor current.\n */\nfloat mcpwm_foc_get_tot_current_filtered(void) {\n\treturn SIGN(motor_now()->m_motor_state.vq) * motor_now()->m_motor_state.iq_filter;\n}\n\n/**\n * Get the magnitude of the motor current, which includes both the\n * D and Q axis.\n *\n * @return\n * The magnitude of the motor current.\n */\nfloat mcpwm_foc_get_abs_motor_current(void) {\n\treturn motor_now()->m_motor_state.i_abs;\n}\n\n/**\n * Get the magnitude of the motor current unbalance\n *\n * @return\n * The magnitude of the phase currents unbalance.\n */\nfloat mcpwm_foc_get_abs_motor_current_unbalance(void) {\n\treturn (float)(motor_now()->m_curr_unbalance) * FAC_CURRENT;\n}\n\n/**\n * Get the magnitude of the motor voltage.\n *\n * @return\n * The magnitude of the motor voltage.\n */\nfloat mcpwm_foc_get_abs_motor_voltage(void) {\n\tconst float vd_tmp = motor_now()->m_motor_state.vd;\n\tconst float vq_tmp = motor_now()->m_motor_state.vq;\n\treturn sqrtf(SQ(vd_tmp) + SQ(vq_tmp));\n}\n\n/**\n * Get the filtered magnitude of the motor current, which includes both the\n * D and Q axis.\n *\n * @return\n * The magnitude of the motor current.\n */\nfloat mcpwm_foc_get_abs_motor_current_filtered(void) {\n\treturn motor_now()->m_motor_state.i_abs_filter;\n}\n\n/**\n * Get the motor current. The sign of this value represents the direction\n * in which the motor generates torque.\n *\n * @return\n * The motor current.\n */\nfloat mcpwm_foc_get_tot_current_directional(void) {\n\treturn motor_now()->m_motor_state.iq;\n}\n\n/**\n * Get the filtered motor current. The sign of this value represents the\n * direction in which the motor generates torque.\n *\n * @return\n * The filtered motor current.\n */\nfloat mcpwm_foc_get_tot_current_directional_filtered(void) {\n\treturn motor_now()->m_motor_state.iq_filter;\n}\n\n/**\n * Get the direct axis motor current.\n *\n * @return\n * The D axis current.\n */\nfloat mcpwm_foc_get_id(void) {\n\treturn motor_now()->m_motor_state.id;\n}\n\n/**\n * Get the quadrature axis motor current.\n *\n * @return\n * The Q axis current.\n */\nfloat mcpwm_foc_get_iq(void) {\n\treturn motor_now()->m_motor_state.iq;\n}\n\n/**\n * Get the input current to the motor controller.\n *\n * @return\n * The input current.\n */\nfloat mcpwm_foc_get_tot_current_in(void) {\n\treturn motor_now()->m_motor_state.i_bus;\n}\n\n/**\n * Get the filtered input current to the motor controller.\n *\n * @return\n * The filtered input current.\n */\nfloat mcpwm_foc_get_tot_current_in_filtered(void) {\n\treturn motor_now()->m_motor_state.i_bus; // TODO: Calculate filtered current?\n}\n\n/**\n * Set the number of steps the motor has rotated. This number is signed and\n * becomes a negative when the motor is rotating backwards.\n *\n * @param steps\n * New number of steps will be set after this call.\n *\n * @return\n * The previous tachometer value in motor steps. The number of motor revolutions will\n * be this number divided by (3 * MOTOR_POLE_NUMBER).\n */\nint mcpwm_foc_set_tachometer_value(int steps) {\n\tint val = motor_now()->m_tachometer;\n\tmotor_now()->m_tachometer = steps;\n\treturn val;\n}\n\n/**\n * Read the number of steps the motor has rotated. This number is signed and\n * will return a negative number when the motor is rotating backwards.\n *\n * @param reset\n * If true, the tachometer counter will be reset after this call.\n *\n * @return\n * The tachometer value in motor steps. The number of motor revolutions will\n * be this number divided by (3 * MOTOR_POLE_NUMBER).\n */\nint mcpwm_foc_get_tachometer_value(bool reset) {\n\tint val = motor_now()->m_tachometer;\n\n\tif (reset) {\n\t\tmotor_now()->m_tachometer = 0;\n\t}\n\n\treturn val;\n}\n\n/**\n * Read the absolute number of steps the motor has rotated.\n *\n * @param reset\n * If true, the tachometer counter will be reset after this call.\n *\n * @return\n * The tachometer value in motor steps. The number of motor revolutions will\n * be this number divided by (3 * MOTOR_POLE_NUMBER).\n */\nint mcpwm_foc_get_tachometer_abs_value(bool reset) {\n\tint val = motor_now()->m_tachometer_abs;\n\n\tif (reset) {\n\t\tmotor_now()->m_tachometer_abs = 0;\n\t}\n\n\treturn val;\n}\n\n/**\n * Read the motor phase.\n *\n * @return\n * The phase angle in degrees.\n */\nfloat mcpwm_foc_get_phase(void) {\n\tfloat angle = motor_now()->m_motor_state.phase * (180.0 / M_PI);\n\tutils_norm_angle(&angle);\n\treturn angle;\n}\n\n/**\n * Read the phase that the observer has calculated.\n *\n * @return\n * The phase angle in degrees.\n */\nfloat mcpwm_foc_get_phase_observer(void) {\n\tfloat angle = motor_now()->m_phase_now_observer * (180.0 / M_PI);\n\tutils_norm_angle(&angle);\n\treturn angle;\n}\n\n/**\n * Read the phase from based on the encoder.\n *\n * @return\n * The phase angle in degrees.\n */\nfloat mcpwm_foc_get_phase_encoder(void) {\n\tfloat angle = motor_now()->m_phase_now_encoder * (180.0 / M_PI);\n\tutils_norm_angle(&angle);\n\treturn angle;\n}\n\nfloat mcpwm_foc_get_vd(void) {\n\treturn motor_now()->m_motor_state.vd;\n}\n\nfloat mcpwm_foc_get_vq(void) {\n\treturn motor_now()->m_motor_state.vq;\n}\n\n/**\n * Get current offsets,\n * this is used by the virtual motor to save the current offsets,\n * when it is connected\n */\nvoid mcpwm_foc_get_current_offsets(\n\t\tvolatile int *curr0_offset,\n\t\tvolatile int *curr1_offset,\n\t\tvolatile int *curr2_offset,\n\t\tbool is_second_motor) {\n#ifdef HW_HAS_DUAL_MOTORS\n\tvolatile motor_all_state_t *motor = is_second_motor ? &m_motor_2 : &m_motor_1;\n#else\n\t(void)is_second_motor;\n\tvolatile motor_all_state_t *motor = &m_motor_1;\n#endif\n\t*curr0_offset = motor->m_curr_ofs[0];\n\t*curr1_offset = motor->m_curr_ofs[1];\n\t*curr2_offset = motor->m_curr_ofs[2];\n}\n\n/**\n * Measure encoder offset and direction.\n *\n * @param current\n * The locking open loop current for the motor.\n *\n * @param offset\n * The detected offset.\n *\n * @param ratio\n * The ratio between electrical and mechanical revolutions\n *\n * @param direction\n * The detected direction.\n */\nvoid mcpwm_foc_encoder_detect(float current, bool print, float *offset, float *ratio, bool *inverted) {\n\tmc_interface_lock();\n\n\tvolatile motor_all_state_t *motor = motor_now();\n\n\tmotor->m_phase_override = true;\n\tmotor->m_id_set = current;\n\tmotor->m_iq_set = 0.0;\n\tmotor->m_control_mode = CONTROL_MODE_CURRENT;\n\tmotor->m_state = MC_STATE_RUNNING;\n\n\t// Disable timeout\n\tsystime_t tout = timeout_get_timeout_msec();\n\tfloat tout_c = timeout_get_brake_current();\n\ttimeout_reset();\n\ttimeout_configure(600000, 0.0);\n\n\t// Save configuration\n\tfloat offset_old = motor->m_conf->foc_encoder_offset;\n\tfloat inverted_old = motor->m_conf->foc_encoder_inverted;\n\tfloat ratio_old = motor->m_conf->foc_encoder_ratio;\n\n\tmotor->m_conf->foc_encoder_offset = 0.0;\n\tmotor->m_conf->foc_encoder_inverted = false;\n\tmotor->m_conf->foc_encoder_ratio = 1.0;\n\n\t// Find index\n\tint cnt = 0;\n\twhile(!encoder_index_found()) {\n\t\tfor (float i = 0.0;i < 2.0 * M_PI;i += (2.0 * M_PI) / 500.0) {\n\t\t\tmotor->m_phase_now_override = i;\n\t\t\tchThdSleepMilliseconds(1);\n\t\t}\n\n\t\tcnt++;\n\t\tif (cnt > 30) {\n\t\t\t// Give up\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (print) {\n\t\tcommands_printf(\"Index found\");\n\t}\n\n\t// Rotate\n\tfor (float i = 0.0;i < 2.0 * M_PI;i += (2.0 * M_PI) / 500.0) {\n\t\tmotor->m_phase_now_override = i;\n\t\tchThdSleepMilliseconds(1);\n\t}\n\n\tif (print) {\n\t\tcommands_printf(\"Rotated for sync\");\n\t}\n\n\t// Inverted and ratio\n\tchThdSleepMilliseconds(1000);\n\n\tconst int it_rat = 20;\n\tfloat s_sum = 0.0;\n\tfloat c_sum = 0.0;\n\tfloat first = motor->m_phase_now_encoder;\n\n\tfor (int i = 0; i < it_rat; i++) {\n\t\tfloat phase_old = motor->m_phase_now_encoder;\n\t\tfloat phase_ovr_tmp = motor->m_phase_now_override;\n\t\tfor (float j = phase_ovr_tmp; j < phase_ovr_tmp + (2.0 / 3.0) * M_PI;\n\t\t\t\tj += (2.0 * M_PI) / 500.0) {\n\t\t\tmotor->m_phase_now_override = j;\n\t\t\tchThdSleepMilliseconds(1);\n\t\t}\n\t\tutils_norm_angle_rad((float*)&motor->m_phase_now_override);\n\t\tchThdSleepMilliseconds(300);\n\t\tfloat diff = utils_angle_difference_rad(motor->m_phase_now_encoder, phase_old);\n\n\t\tfloat s, c;\n\t\tsincosf(diff, &s, &c);\n\t\ts_sum += s;\n\t\tc_sum += c;\n\n\t\tif (print) {\n\t\t\tcommands_printf(\"%.2f\", (double)(diff * 180.0 / M_PI));\n\t\t}\n\n\t\tif (i > 3 && fabsf(utils_angle_difference_rad(motor->m_phase_now_encoder, first)) < fabsf(diff / 2.0)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfirst = motor->m_phase_now_encoder;\n\n\tfor (int i = 0; i < it_rat; i++) {\n\t\tfloat phase_old = motor->m_phase_now_encoder;\n\t\tfloat phase_ovr_tmp = motor->m_phase_now_override;\n\t\tfor (float j = phase_ovr_tmp; j > phase_ovr_tmp - (2.0 / 3.0) * M_PI;\n\t\t\t\tj -= (2.0 * M_PI) / 500.0) {\n\t\t\tmotor->m_phase_now_override = j;\n\t\t\tchThdSleepMilliseconds(1);\n\t\t}\n\t\tutils_norm_angle_rad((float*)&motor->m_phase_now_override);\n\t\tchThdSleepMilliseconds(300);\n\t\tfloat diff = utils_angle_difference_rad(phase_old, motor->m_phase_now_encoder);\n\n\t\tfloat s, c;\n\t\tsincosf(diff, &s, &c);\n\t\ts_sum += s;\n\t\tc_sum += c;\n\n\t\tif (print) {\n\t\t\tcommands_printf(\"%.2f\", (double)(diff * 180.0 / M_PI));\n\t\t}\n\n\t\tif (i > 3 && fabsf(utils_angle_difference_rad(motor->m_phase_now_encoder, first)) < fabsf(diff / 2.0)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfloat diff = atan2f(s_sum, c_sum) * 180.0 / M_PI;\n\t*inverted = diff < 0.0;\n\t*ratio = roundf(((2.0 / 3.0) * 180.0) / fabsf(diff));\n\n\tmotor->m_conf->foc_encoder_inverted = *inverted;\n\tmotor->m_conf->foc_encoder_ratio = *ratio;\n\n\tif (print) {\n\t\tcommands_printf(\"Inversion and ratio detected\");\n\t}\n\n\t// Rotate\n\tfor (float i = motor->m_phase_now_override;i < 2.0 * M_PI;i += (2.0 * M_PI) / 500.0) {\n\t\tmotor->m_phase_now_override = i;\n\t\tchThdSleepMilliseconds(2);\n\t}\n\n\tif (print) {\n\t\tcommands_printf(\"Rotated for sync\");\n\t\tcommands_printf(\"Enc: %.2f\", (double)encoder_read_deg());\n\t}\n\n\tconst int it_ofs = motor->m_conf->foc_encoder_ratio * 3.0;\n\ts_sum = 0.0;\n\tc_sum = 0.0;\n\n\tfor (int i = 0;i < it_ofs;i++) {\n\t\tfloat step = (2.0 * M_PI * motor->m_conf->foc_encoder_ratio) / ((float)it_ofs);\n\t\tfloat override = (float)i * step;\n\n\t\twhile (motor->m_phase_now_override != override) {\n\t\t\tutils_step_towards((float*)&motor->m_phase_now_override, override, step / 100.0);\n\t\t\tchThdSleepMilliseconds(4);\n\t\t}\n\n\t\tchThdSleepMilliseconds(100);\n\n\t\tfloat angle_diff = utils_angle_difference_rad(motor->m_phase_now_encoder, motor->m_phase_now_override);\n\t\tfloat s, c;\n\t\tsincosf(angle_diff, &s, &c);\n\t\ts_sum += s;\n\t\tc_sum += c;\n\n\t\tif (print) {\n\t\t\tcommands_printf(\"%.2f\", (double)(angle_diff * 180.0 / M_PI));\n\t\t}\n\t}\n\n\tfor (int i = it_ofs;i > 0;i--) {\n\t\tfloat step = (2.0 * M_PI * motor->m_conf->foc_encoder_ratio) / ((float)it_ofs);\n\t\tfloat override = (float)i * step;\n\n\t\twhile (motor->m_phase_now_override != override) {\n\t\t\tutils_step_towards((float*)&motor->m_phase_now_override, override, step / 100.0);\n\t\t\tchThdSleepMilliseconds(4);\n\t\t}\n\n\t\tchThdSleepMilliseconds(100);\n\n\t\tfloat angle_diff = utils_angle_difference_rad(motor->m_phase_now_encoder, motor->m_phase_now_override);\n\t\tfloat s, c;\n\t\tsincosf(angle_diff, &s, &c);\n\t\ts_sum += s;\n\t\tc_sum += c;\n\n\t\tif (print) {\n\t\t\tcommands_printf(\"%.2f\", (double)(angle_diff * 180.0 / M_PI));\n\t\t}\n\t}\n\n\t*offset = atan2f(s_sum, c_sum) * 180.0 / M_PI;\n\n\tif (print) {\n\t\tcommands_printf(\"Avg: %.2f\", (double)*offset);\n\t}\n\n\tutils_norm_angle(offset);\n\n\tif (print) {\n\t\tcommands_printf(\"Offset detected\");\n\t}\n\n\tmotor->m_id_set = 0.0;\n\tmotor->m_iq_set = 0.0;\n\tmotor->m_phase_override = false;\n\tmotor->m_control_mode = CONTROL_MODE_NONE;\n\tmotor->m_state = MC_STATE_OFF;\n\tstop_pwm_hw(motor);\n\n\t// Restore configuration\n\tmotor->m_conf->foc_encoder_inverted = inverted_old;\n\tmotor->m_conf->foc_encoder_offset = offset_old;\n\tmotor->m_conf->foc_encoder_ratio = ratio_old;\n\n\t// Enable timeout\n\ttimeout_configure(tout, tout_c);\n\n\tmc_interface_unlock();\n}\n\n/**\n * Lock the motor with a current and sample the voiltage and current to\n * calculate the motor resistance.\n *\n * @param current\n * The locking current.\n *\n * @param samples\n * The number of samples to take.\n *\n * @param stop_after\n * Stop motor after finishing the measurement. Otherwise, the current will\n * still be applied after returning. Setting this to false is useful if you want\n * to run this function again right away, without stopping the motor in between.\n *\n * @return\n * The calculated motor resistance.\n */\nfloat mcpwm_foc_measure_resistance(float current, int samples, bool stop_after) {\n\tmc_interface_lock();\n\n\tvolatile motor_all_state_t *motor = motor_now();\n\n\tmotor->m_phase_override = true;\n\tmotor->m_phase_now_override = 0.0;\n\tmotor->m_id_set = 0.0;\n\tmotor->m_control_mode = CONTROL_MODE_CURRENT;\n\tmotor->m_state = MC_STATE_RUNNING;\n\n\t// Disable timeout\n\tsystime_t tout = timeout_get_timeout_msec();\n\tfloat tout_c = timeout_get_brake_current();\n\ttimeout_reset();\n\ttimeout_configure(60000, 0.0);\n\n\t// Ramp up the current slowly\n\twhile (fabsf(motor->m_iq_set - current) > 0.001) {\n\t\tutils_step_towards((float*)&motor->m_iq_set, current, fabsf(current) / 500.0);\n\t\tchThdSleepMilliseconds(1);\n\t}\n\n\t// Wait for the current to rise and the motor to lock.\n\tchThdSleepMilliseconds(100);\n\n\t// Sample\n\tmotor->m_samples.avg_current_tot = 0.0;\n\tmotor->m_samples.avg_voltage_tot = 0.0;\n\tmotor->m_samples.sample_num = 0;\n\n\tint cnt = 0;\n\twhile (motor->m_samples.sample_num < samples) {\n\t\tchThdSleepMilliseconds(1);\n\t\tcnt++;\n\t\t// Timeout\n\t\tif (cnt > 10000) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (mc_interface_get_fault() != FAULT_CODE_NONE) {\n\t\t\tmotor->m_id_set = 0.0;\n\t\t\tmotor->m_iq_set = 0.0;\n\t\t\tmotor->m_phase_override = false;\n\t\t\tmotor->m_control_mode = CONTROL_MODE_NONE;\n\t\t\tmotor->m_state = MC_STATE_OFF;\n\t\t\tstop_pwm_hw(motor);\n\n\t\t\ttimeout_configure(tout, tout_c);\n\t\t\tmc_interface_unlock();\n\n\t\t\treturn 0.0;\n\t\t}\n\t}\n\n\tconst float current_avg = motor->m_samples.avg_current_tot / (float)motor->m_samples.sample_num;\n\tconst float voltage_avg = motor->m_samples.avg_voltage_tot / (float)motor->m_samples.sample_num;\n\n\t// Stop\n\tif (stop_after) {\n\t\tmotor->m_id_set = 0.0;\n\t\tmotor->m_iq_set = 0.0;\n\t\tmotor->m_phase_override = false;\n\t\tmotor->m_control_mode = CONTROL_MODE_NONE;\n\t\tmotor->m_state = MC_STATE_OFF;\n\t\tstop_pwm_hw(motor);\n\t}\n\n\t// Enable timeout\n\ttimeout_configure(tout, tout_c);\n\tmc_interface_unlock();\n\n\treturn (voltage_avg / current_avg) * (2.0 / 3.0);\n}\n\n/**\n * Measure the motor inductance with short voltage pulses.\n *\n * @param duty\n * The duty cycle to use in the pulses.\n *\n * @param samples\n * The number of samples to average over.\n *\n * @param\n * The current that was used for this measurement.\n *\n * @return\n * The average d and q axis inductance in uH.\n */\nfloat mcpwm_foc_measure_inductance(float duty, int samples, float *curr, float *ld_lq_diff) {\n\tvolatile motor_all_state_t *motor = motor_now();\n\n\tmc_sensor_mode sensor_mode_old = motor->m_conf->sensor_mode;\n\tfloat f_sw_old = motor->m_conf->foc_f_sw;\n\tfloat hfi_voltage_start_old = motor->m_conf->foc_hfi_voltage_start;\n\tfloat hfi_voltage_run_old = motor->m_conf->foc_hfi_voltage_run;\n\tfloat hfi_voltage_max_old = motor->m_conf->foc_hfi_voltage_max;\n\tbool sample_v0_v7_old = motor->m_conf->foc_sample_v0_v7;\n\tfoc_hfi_samples samples_old = motor->m_conf->foc_hfi_samples;\n\tbool sample_high_current_old = motor->m_conf->foc_sample_high_current;\n\n\tmc_interface_lock();\n\tmotor->m_control_mode = CONTROL_MODE_NONE;\n\tmotor->m_state = MC_STATE_OFF;\n\tstop_pwm_hw(motor);\n\n\tmotor->m_conf->foc_sensor_mode = FOC_SENSOR_MODE_HFI;\n\tmotor->m_conf->foc_hfi_voltage_start = duty * GET_INPUT_VOLTAGE() * (2.0 / 3.0);\n\tmotor->m_conf->foc_hfi_voltage_run = duty * GET_INPUT_VOLTAGE() * (2.0 / 3.0);\n\tmotor->m_conf->foc_hfi_voltage_max = duty * GET_INPUT_VOLTAGE() * (2.0 / 3.0);\n\tmotor->m_conf->foc_sample_v0_v7 = false;\n\tmotor->m_conf->foc_hfi_samples = HFI_SAMPLES_32;\n\tmotor->m_conf->foc_sample_high_current = false;\n\n\tupdate_hfi_samples(motor->m_conf->foc_hfi_samples, motor);\n\n\tchThdSleepMilliseconds(1);\n\n\ttimeout_reset();\n\tmcpwm_foc_set_duty(0.0);\n\tchThdSleepMilliseconds(1);\n\n\tint ready_cnt = 0;\n\twhile (!motor->m_hfi.ready) {\n\t\tchThdSleepMilliseconds(1);\n\t\tready_cnt++;\n\t\tif (ready_cnt > 100) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (samples < 10) {\n\t\tsamples = 10;\n\t}\n\n\tfloat l_sum = 0.0;\n\tfloat ld_lq_diff_sum = 0.0;\n\tfloat i_sum = 0.0;\n\tfloat iterations = 0.0;\n\n\tfor (int i = 0;i < (samples / 10);i++) {\n\t\tif (mc_interface_get_fault() != FAULT_CODE_NONE) {\n\t\t\tmotor->m_id_set = 0.0;\n\t\t\tmotor->m_iq_set = 0.0;\n\t\t\tmotor->m_control_mode = CONTROL_MODE_NONE;\n\t\t\tmotor->m_state = MC_STATE_OFF;\n\t\t\tstop_pwm_hw(motor);\n\n\t\t\tmotor->m_conf->foc_sensor_mode = sensor_mode_old;\n\t\t\tmotor->m_conf->foc_f_sw = f_sw_old;\n\t\t\tmotor->m_conf->foc_hfi_voltage_start = hfi_voltage_start_old;\n\t\t\tmotor->m_conf->foc_hfi_voltage_run = hfi_voltage_run_old;\n\t\t\tmotor->m_conf->foc_hfi_voltage_max = hfi_voltage_max_old;\n\t\t\tmotor->m_conf->foc_sample_v0_v7 = sample_v0_v7_old;\n\t\t\tmotor->m_conf->foc_hfi_samples = samples_old;\n\t\t\tmotor->m_conf->foc_sample_high_current = sample_high_current_old;\n\n\t\t\tupdate_hfi_samples(motor->m_conf->foc_hfi_samples, motor);\n\n\t\t\tmc_interface_unlock();\n\n\t\t\treturn 0.0;\n\t\t}\n\n\t\ttimeout_reset();\n\t\tmcpwm_foc_set_duty(0.0);\n\t\tchThdSleepMilliseconds(10);\n\n\t\tfloat real_bin0, imag_bin0;\n\t\tfloat real_bin2, imag_bin2;\n\t\tfloat real_bin0_i, imag_bin0_i;\n\n\t\tmotor->m_hfi.fft_bin0_func((float*)motor->m_hfi.buffer, &real_bin0, &imag_bin0);\n\t\tmotor->m_hfi.fft_bin2_func((float*)motor->m_hfi.buffer, &real_bin2, &imag_bin2);\n\t\tmotor->m_hfi.fft_bin0_func((float*)motor->m_hfi.buffer_current, &real_bin0_i, &imag_bin0_i);\n\n\t\tl_sum += real_bin0;\n\t\tld_lq_diff_sum += 2.0 * sqrtf(SQ(real_bin2) + SQ(imag_bin2));\n\t\ti_sum += real_bin0_i;\n\n\t\titerations++;\n\t}\n\n\tmcpwm_foc_set_current(0.0);\n\n\tmotor->m_conf->foc_sensor_mode = sensor_mode_old;\n\tmotor->m_conf->foc_f_sw = f_sw_old;\n\tmotor->m_conf->foc_hfi_voltage_start = hfi_voltage_start_old;\n\tmotor->m_conf->foc_hfi_voltage_run = hfi_voltage_run_old;\n\tmotor->m_conf->foc_hfi_voltage_max = hfi_voltage_max_old;\n\tmotor->m_conf->foc_sample_v0_v7 = sample_v0_v7_old;\n\tmotor->m_conf->foc_hfi_samples = samples_old;\n\tmotor->m_conf->foc_sample_high_current = sample_high_current_old;\n\n\tupdate_hfi_samples(motor->m_conf->foc_hfi_samples, motor);\n\n\tmc_interface_unlock();\n\n\tif (curr) {\n\t\t*curr = i_sum / iterations;\n\t}\n\n\tif (ld_lq_diff) {\n\t\t*ld_lq_diff = (ld_lq_diff_sum / iterations) * 1e6 * (2.0 / 3.0);\n\t}\n\n\treturn (l_sum / iterations) * 1e6 * (2.0 / 3.0);\n}\n\n/**\n * Measure the motor inductance with short voltage pulses. The difference from the\n * other function is that this one will aim for a specific measurement current. It\n * will also use an appropriate switching frequency.\n *\n * @param curr_goal\n * The measurement current to aim for.\n *\n * @param samples\n * The number of samples to average over.\n *\n * @param *curr\n * The current that was used for this measurement.\n *\n * @return\n * The average d and q axis inductance in uH.\n */\nfloat mcpwm_foc_measure_inductance_current(float curr_goal, int samples, float *curr, float *ld_lq_diff) {\n\tfloat duty_last = 0.0;\n\tfor (float i = 0.02;i < 0.5;i *= 1.5) {\n\t\tfloat i_tmp;\n\t\tmcpwm_foc_measure_inductance(i, 10, &i_tmp, 0);\n\n\t\tduty_last = i;\n\t\tif (i_tmp >= curr_goal) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfloat ind = mcpwm_foc_measure_inductance(duty_last, samples, curr, ld_lq_diff);\n\treturn ind;\n}\n\n/**\n * Automatically measure the resistance and inductance of the motor with small steps.\n *\n * @param res\n * The measured resistance in ohm.\n *\n * @param ind\n * The measured inductance in microhenry.\n *\n * @return\n * True if the measurement succeeded, false otherwise.\n */\nbool mcpwm_foc_measure_res_ind(float *res, float *ind) {\n\tvolatile motor_all_state_t *motor = motor_now();\n\n\tconst float f_sw_old = motor->m_conf->foc_f_sw;\n\tconst float kp_old = motor->m_conf->foc_current_kp;\n\tconst float ki_old = motor->m_conf->foc_current_ki;\n\tconst float res_old = motor->m_conf->foc_motor_r;\n\n\tmotor->m_conf->foc_current_kp = 0.001;\n\tmotor->m_conf->foc_current_ki = 1.0;\n\n\tfloat i_last = 0.0;\n\tfor (float i = 2.0;i < (motor->m_conf->l_current_max / 2.0);i *= 1.5) {\n\t\tif (i > (1.0 / mcpwm_foc_measure_resistance(i, 20, false))) {\n\t\t\ti_last = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i_last < 0.01) {\n\t\ti_last = (motor->m_conf->l_current_max / 2.0);\n\t}\n\n#ifdef HW_AXIOM_FORCE_HIGH_CURRENT_MEASUREMENTS\n\ti_last = (motor->m_conf->l_current_max / 2.0);\n#endif\n\n\t*res = mcpwm_foc_measure_resistance(i_last, 200, true);\n\tmotor->m_conf->foc_motor_r = *res;\n\t*ind = mcpwm_foc_measure_inductance_current(i_last, 200, 0, 0);\n\n\tmotor->m_conf->foc_f_sw = f_sw_old;\n\tmotor->m_conf->foc_current_kp = kp_old;\n\tmotor->m_conf->foc_current_ki = ki_old;\n\tmotor->m_conf->foc_motor_r = res_old;\n\n\treturn true;\n}\n\n/**\n * Run the motor in open loop and figure out at which angles the hall sensors are.\n *\n * @param current\n * Current to use.\n *\n * @param hall_table\n * Table to store the result to.\n *\n * @return\n * true: Success\n * false: Something went wrong\n */\nbool mcpwm_foc_hall_detect(float current, uint8_t *hall_table) {\n\tvolatile motor_all_state_t *motor = motor_now();\n\n\tmc_interface_lock();\n\n\tmotor->m_phase_override = true;\n\tmotor->m_id_set = 0.0;\n\tmotor->m_iq_set = 0.0;\n\tmotor->m_control_mode = CONTROL_MODE_CURRENT;\n\tmotor->m_state = MC_STATE_RUNNING;\n\n\t// Disable timeout\n\tsystime_t tout = timeout_get_timeout_msec();\n\tfloat tout_c = timeout_get_brake_current();\n\ttimeout_reset();\n\ttimeout_configure(60000, 0.0);\n\n\t// Lock the motor\n\tmotor->m_phase_now_override = 0;\n\n\tfor (int i = 0;i < 1000;i++) {\n\t\tmotor->m_id_set = (float)i * current / 1000.0;\n\t\tchThdSleepMilliseconds(1);\n\t}\n\n\tfloat sin_hall[8];\n\tfloat cos_hall[8];\n\tint hall_iterations[8];\n\tmemset(sin_hall, 0, sizeof(sin_hall));\n\tmemset(cos_hall, 0, sizeof(cos_hall));\n\tmemset(hall_iterations, 0, sizeof(hall_iterations));\n\n\t// Forwards\n\tfor (int i = 0;i < 3;i++) {\n\t\tfor (int j = 0;j < 360;j++) {\n\t\t\tmotor->m_phase_now_override = (float)j * M_PI / 180.0;\n\t\t\tchThdSleepMilliseconds(5);\n\n\t\t\tint hall = utils_read_hall(motor != &m_motor_1);\n\t\t\tfloat s, c;\n\t\t\tsincosf(motor->m_phase_now_override, &s, &c);\n\t\t\tsin_hall[hall] += s;\n\t\t\tcos_hall[hall] += c;\n\t\t\thall_iterations[hall]++;\n\t\t}\n\t}\n\n\t// Reverse\n\tfor (int i = 0;i < 3;i++) {\n\t\tfor (int j = 360;j >= 0;j--) {\n\t\t\tmotor->m_phase_now_override = (float)j * M_PI / 180.0;\n\t\t\tchThdSleepMilliseconds(5);\n\n\t\t\tint hall = utils_read_hall(motor != &m_motor_1);\n\t\t\tfloat s, c;\n\t\t\tsincosf(motor->m_phase_now_override, &s, &c);\n\t\t\tsin_hall[hall] += s;\n\t\t\tcos_hall[hall] += c;\n\t\t\thall_iterations[hall]++;\n\t\t}\n\t}\n\n\tmotor->m_id_set = 0.0;\n\tmotor->m_iq_set = 0.0;\n\tmotor->m_phase_override = false;\n\tmotor->m_control_mode = CONTROL_MODE_NONE;\n\tmotor->m_state = MC_STATE_OFF;\n\tstop_pwm_hw(motor);\n\n\t// Enable timeout\n\ttimeout_configure(tout, tout_c);\n\n\tint fails = 0;\n\tfor(int i = 0;i < 8;i++) {\n\t\tif (hall_iterations[i] > 30) {\n\t\t\tfloat ang = atan2f(sin_hall[i], cos_hall[i]) * 180.0 / M_PI;\n\t\t\tutils_norm_angle(&ang);\n\t\t\thall_table[i] = (uint8_t)(ang * 200.0 / 360.0);\n\t\t} else {\n\t\t\thall_table[i] = 255;\n\t\t\tfails++;\n\t\t}\n\t}\n\n\tmc_interface_unlock();\n\n\treturn fails == 2;\n}\n\nvoid mcpwm_foc_print_state(void) {\n\tcommands_printf(\"Mod d:        %.2f\", (double)motor_now()->m_motor_state.mod_d);\n\tcommands_printf(\"Mod q:        %.2f\", (double)motor_now()->m_motor_state.mod_q);\n\tcommands_printf(\"Duty:         %.2f\", (double)motor_now()->m_motor_state.duty_now);\n\tcommands_printf(\"Vd:           %.2f\", (double)motor_now()->m_motor_state.vd);\n\tcommands_printf(\"Vq:           %.2f\", (double)motor_now()->m_motor_state.vq);\n\tcommands_printf(\"Phase:        %.2f\", (double)motor_now()->m_motor_state.phase);\n\tcommands_printf(\"V_alpha:      %.2f\", (double)motor_now()->m_motor_state.v_alpha);\n\tcommands_printf(\"V_beta:       %.2f\", (double)motor_now()->m_motor_state.v_beta);\n\tcommands_printf(\"id:           %.2f\", (double)motor_now()->m_motor_state.id);\n\tcommands_printf(\"iq:           %.2f\", (double)motor_now()->m_motor_state.iq);\n\tcommands_printf(\"id_filter:    %.2f\", (double)motor_now()->m_motor_state.id_filter);\n\tcommands_printf(\"iq_filter:    %.2f\", (double)motor_now()->m_motor_state.iq_filter);\n\tcommands_printf(\"id_target:    %.2f\", (double)motor_now()->m_motor_state.id_target);\n\tcommands_printf(\"iq_target:    %.2f\", (double)motor_now()->m_motor_state.iq_target);\n\tcommands_printf(\"i_abs:        %.2f\", (double)motor_now()->m_motor_state.i_abs);\n\tcommands_printf(\"i_abs_filter: %.2f\", (double)motor_now()->m_motor_state.i_abs_filter);\n\tcommands_printf(\"Obs_x1:       %.2f\", (double)motor_now()->m_observer_x1);\n\tcommands_printf(\"Obs_x2:       %.2f\", (double)motor_now()->m_observer_x2);\n\tcommands_printf(\"vd_int:       %.2f\", (double)motor_now()->m_motor_state.vd_int);\n\tcommands_printf(\"vq_int:       %.2f\", (double)motor_now()->m_motor_state.vq_int);\n}\n\nfloat mcpwm_foc_get_last_adc_isr_duration(void) {\n\treturn m_last_adc_isr_duration;\n}\n\nvoid mcpwm_foc_tim_sample_int_handler(void) {\n\tif (m_init_done) {\n\t\t// Generate COM event here for synchronization\n\t\tTIM_GenerateEvent(TIM1, TIM_EventSource_COM);\n\t\tTIM_GenerateEvent(TIM8, TIM_EventSource_COM);\n\n\t\tvirtual_motor_int_handler(\n\t\t\t\tm_motor_1.m_motor_state.v_alpha,\n\t\t\t\tm_motor_1.m_motor_state.v_beta);\n\t}\n}\n\nvoid mcpwm_foc_adc_int_handler(void *p, uint32_t flags) {\n\t(void)p;\n\t(void)flags;\n\n\tstatic int skip = 0;\n\tif (++skip == FOC_CONTROL_LOOP_FREQ_DIVIDER) {\n\t\tskip = 0;\n\t} else {\n\t\treturn;\n\t}\n\n\tuint32_t t_start = timer_time_now();\n\n\tbool is_v7 = !(TIM1->CR1 & TIM_CR1_DIR);\n\tint norm_curr_ofs = 0;\n\n#ifdef HW_HAS_DUAL_MOTORS\n\tbool is_second_motor = is_v7;\n\tnorm_curr_ofs = is_second_motor ? 3 : 0;\n\tvolatile motor_all_state_t *motor_now = is_second_motor ? &m_motor_2 : &m_motor_1;\n\tvolatile motor_all_state_t *motor_other = is_second_motor ? &m_motor_1 : &m_motor_2;\n\tm_isr_motor = is_second_motor ? 2 : 1;\n#ifdef HW_HAS_3_SHUNTS\n\tvolatile TIM_TypeDef *tim = is_second_motor ? TIM8 : TIM1;\n#endif\n#else\n\tvolatile motor_all_state_t *motor_other = &m_motor_1;\n\tvolatile motor_all_state_t *motor_now = &m_motor_1;;\n\tm_isr_motor = 1;\n#ifdef HW_HAS_3_SHUNTS\n\tvolatile TIM_TypeDef *tim = TIM1;\n#endif\n#endif\n\n\tvolatile mc_configuration *conf_now = motor_now->m_conf;\n\n\tif (motor_other->m_duty_next_set) {\n\t\tmotor_other->m_duty_next_set = false;\n#ifdef HW_HAS_DUAL_MOTORS\n\t\tif (is_second_motor) {\n\t\t\tTIMER_UPDATE_DUTY_M1(motor_other->m_duty1_next, motor_other->m_duty2_next, motor_other->m_duty3_next);\n\t\t} else {\n\t\t\tTIMER_UPDATE_DUTY_M2(motor_other->m_duty1_next, motor_other->m_duty2_next, motor_other->m_duty3_next);\n\t\t}\n#else\n\t\tTIMER_UPDATE_DUTY_M1(motor_now->m_duty1_next, motor_now->m_duty2_next, motor_now->m_duty3_next);\n#ifdef HW_HAS_DUAL_PARALLEL\n\t\tTIMER_UPDATE_DUTY_M2(motor_now->m_duty1_next, motor_now->m_duty2_next, motor_now->m_duty3_next);\n#endif\n#endif\n\t}\n\n#ifndef HW_HAS_DUAL_MOTORS\n#ifdef HW_HAS_PHASE_SHUNTS\n\tif (!conf_now->foc_sample_v0_v7 && is_v7) {\n\t\treturn;\n\t}\n#else\n\tif (is_v7) {\n\t\treturn;\n\t}\n#endif\n#endif\n\n\t// Reset the watchdog\n\ttimeout_feed_WDT(THREAD_MCPWM);\n\n#ifdef AD2S1205_SAMPLE_GPIO\n\t// force a position sample in the AD2S1205 resolver IC (falling edge)\n\tpalClearPad(AD2S1205_SAMPLE_GPIO, AD2S1205_SAMPLE_PIN);\n#endif\n\n#ifdef HW_HAS_DUAL_MOTORS\n\tint curr0 = 0;\n\tint curr1 = 0;\n\n\tif (is_second_motor) {\n\t\tcurr0 = GET_CURRENT1_M2();\n\t\tcurr1 = GET_CURRENT2_M2();\n\t} else {\n\t\tcurr0 = GET_CURRENT1();\n\t\tcurr1 = GET_CURRENT2();\n\t}\n#else\n\tint curr0 = GET_CURRENT1();\n\tint curr1 = GET_CURRENT2();\n#ifdef HW_HAS_DUAL_PARALLEL\n\tcurr0 += GET_CURRENT1_M2();\n\tcurr1 += GET_CURRENT2_M2();\n#endif\n#endif\n\n#ifdef HW_HAS_3_SHUNTS\n#ifdef HW_HAS_DUAL_MOTORS\n\tint curr2 = is_second_motor ? GET_CURRENT3_M2() : GET_CURRENT3();\n#else\n\tint curr2 = GET_CURRENT3();\n#ifdef HW_HAS_DUAL_PARALLEL\n\tcurr2 += GET_CURRENT3_M2();\n#endif\n#endif\n#endif\n\n\tmotor_now->m_curr_sum[0] += curr0;\n\tmotor_now->m_curr_sum[1] += curr1;\n#ifdef HW_HAS_3_SHUNTS\n\tmotor_now->m_curr_sum[2] += curr2;\n#endif\n\n\tcurr0 -= motor_now->m_curr_ofs[0];\n\tcurr1 -= motor_now->m_curr_ofs[1];\n#ifdef HW_HAS_3_SHUNTS\n\tcurr2 -= motor_now->m_curr_ofs[2];\n\tmotor_now->m_curr_unbalance = curr0 + curr1 + curr2;\n#endif\n\n\tmotor_now->m_curr_samples++;\n\n\tADC_curr_norm_value[0 + norm_curr_ofs] = curr0;\n\tADC_curr_norm_value[1 + norm_curr_ofs] = curr1;\n#ifdef HW_HAS_3_SHUNTS\n\tADC_curr_norm_value[2 + norm_curr_ofs] = curr2;\n#else\n\tADC_curr_norm_value[2 + norm_curr_ofs] = -(ADC_curr_norm_value[0] + ADC_curr_norm_value[1]);\n#endif\n\n\t// Use the best current samples depending on the modulation state.\n#ifdef HW_HAS_3_SHUNTS\n\tif (conf_now->foc_sample_high_current) {\n\t\t// High current sampling mode. Choose the lower currents to derive the highest one\n\t\t// in order to be able to measure higher currents.\n\t\tconst float i0_abs = fabsf(ADC_curr_norm_value[0 + norm_curr_ofs]);\n\t\tconst float i1_abs = fabsf(ADC_curr_norm_value[1 + norm_curr_ofs]);\n\t\tconst float i2_abs = fabsf(ADC_curr_norm_value[2 + norm_curr_ofs]);\n\n\t\tif (i0_abs > i1_abs && i0_abs > i2_abs) {\n\t\t\tADC_curr_norm_value[0 + norm_curr_ofs] = -(ADC_curr_norm_value[1 + norm_curr_ofs] + ADC_curr_norm_value[2 + norm_curr_ofs]);\n\t\t} else if (i1_abs > i0_abs && i1_abs > i2_abs) {\n\t\t\tADC_curr_norm_value[1 + norm_curr_ofs] = -(ADC_curr_norm_value[0 + norm_curr_ofs] + ADC_curr_norm_value[2 + norm_curr_ofs]);\n\t\t} else if (i2_abs > i0_abs && i2_abs > i1_abs) {\n\t\t\tADC_curr_norm_value[2 + norm_curr_ofs] = -(ADC_curr_norm_value[0 + norm_curr_ofs] + ADC_curr_norm_value[1 + norm_curr_ofs]);\n\t\t}\n\t} else {\n#ifdef HW_HAS_PHASE_SHUNTS\n\t\tif (is_v7) {\n\t\t\tif (tim->CCR1 > 500 && tim->CCR2 > 500) {\n\t\t\t\t// Use the same 2 shunts on low modulation, as that will avoid jumps in the current reading.\n\t\t\t\t// This is especially important when using HFI.\n\t\t\t\tADC_curr_norm_value[2 + norm_curr_ofs] = -(ADC_curr_norm_value[0 + norm_curr_ofs] + ADC_curr_norm_value[1 + norm_curr_ofs]);\n\t\t\t} else {\n\t\t\t\tif (tim->CCR1 < tim->CCR2 && tim->CCR1 < tim->CCR3) {\n\t\t\t\t\tADC_curr_norm_value[0 + norm_curr_ofs] = -(ADC_curr_norm_value[1 + norm_curr_ofs] + ADC_curr_norm_value[2 + norm_curr_ofs]);\n\t\t\t\t} else if (tim->CCR2 < tim->CCR1 && tim->CCR2 < tim->CCR3) {\n\t\t\t\t\tADC_curr_norm_value[1 + norm_curr_ofs] = -(ADC_curr_norm_value[0 + norm_curr_ofs] + ADC_curr_norm_value[2 + norm_curr_ofs]);\n\t\t\t\t} else if (tim->CCR3 < tim->CCR1 && tim->CCR3 < tim->CCR2) {\n\t\t\t\t\tADC_curr_norm_value[2 + norm_curr_ofs] = -(ADC_curr_norm_value[0 + norm_curr_ofs] + ADC_curr_norm_value[1 + norm_curr_ofs]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (tim->CCR1 < (tim->ARR - 500) && tim->CCR2 < (tim->ARR - 500)) {\n\t\t\t\t// Use the same 2 shunts on low modulation, as that will avoid jumps in the current reading.\n\t\t\t\t// This is especially important when using HFI.\n\t\t\t\tADC_curr_norm_value[2 + norm_curr_ofs] = -(ADC_curr_norm_value[0 + norm_curr_ofs] + ADC_curr_norm_value[1 + norm_curr_ofs]);\n\t\t\t} else {\n\t\t\t\tif (tim->CCR1 > tim->CCR2 && tim->CCR1 > tim->CCR3) {\n\t\t\t\t\tADC_curr_norm_value[0 + norm_curr_ofs] = -(ADC_curr_norm_value[1 + norm_curr_ofs] + ADC_curr_norm_value[2 + norm_curr_ofs]);\n\t\t\t\t} else if (tim->CCR2 > tim->CCR1 && tim->CCR2 > tim->CCR3) {\n\t\t\t\t\tADC_curr_norm_value[1 + norm_curr_ofs] = -(ADC_curr_norm_value[0 + norm_curr_ofs] + ADC_curr_norm_value[2 + norm_curr_ofs]);\n\t\t\t\t} else if (tim->CCR3 > tim->CCR1 && tim->CCR3 > tim->CCR2) {\n\t\t\t\t\tADC_curr_norm_value[2 + norm_curr_ofs] = -(ADC_curr_norm_value[0 + norm_curr_ofs] + ADC_curr_norm_value[1 + norm_curr_ofs]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#else\n\t\tif (tim->CCR1 < (tim->ARR - 500) && tim->CCR2 < (tim->ARR - 500)) {\n\t\t\t// Use the same 2 shunts on low modulation, as that will avoid jumps in the current reading.\n\t\t\t// This is especially important when using HFI.\n\t\t\tADC_curr_norm_value[2 + norm_curr_ofs] = -(ADC_curr_norm_value[0 + norm_curr_ofs] + ADC_curr_norm_value[1 + norm_curr_ofs]);\n\t\t} else {\n\t\t\tif (tim->CCR1 > tim->CCR2 && tim->CCR1 > tim->CCR3) {\n\t\t\t\tADC_curr_norm_value[0 + norm_curr_ofs] = -(ADC_curr_norm_value[1 + norm_curr_ofs] + ADC_curr_norm_value[2 + norm_curr_ofs]);\n\t\t\t} else if (tim->CCR2 > tim->CCR1 && tim->CCR2 > tim->CCR3) {\n\t\t\t\tADC_curr_norm_value[1 + norm_curr_ofs] = -(ADC_curr_norm_value[0 + norm_curr_ofs] + ADC_curr_norm_value[2 + norm_curr_ofs]);\n\t\t\t} else if (tim->CCR3 > tim->CCR1 && tim->CCR3 > tim->CCR2) {\n\t\t\t\tADC_curr_norm_value[2 + norm_curr_ofs] = -(ADC_curr_norm_value[0 + norm_curr_ofs] + ADC_curr_norm_value[1 + norm_curr_ofs]);\n\t\t\t}\n\t\t}\n#endif\n\t}\n#endif\n\n\tfloat ia = (float)ADC_curr_norm_value[0 + norm_curr_ofs] * FAC_CURRENT;\n\tfloat ib = (float)ADC_curr_norm_value[1 + norm_curr_ofs] * FAC_CURRENT;\n//\tfloat ic = -(ia + ib);\n\n#ifdef HW_HAS_PHASE_SHUNTS\n\tfloat dt;\n\tif (conf_now->foc_sample_v0_v7) {\n\t\tdt = 1.0 / conf_now->foc_f_sw;\n\t} else {\n\t\tdt = 1.0 / (conf_now->foc_f_sw / 2.0);\n\t}\n#else\n\tfloat dt = 1.0 / (conf_now->foc_f_sw / 2.0);\n#endif\n\n\t// This has to be done for the skip function to have any chance at working with the\n\t// observer and control loops.\n\t// TODO: Test this.\n\tdt /= (float)FOC_CONTROL_LOOP_FREQ_DIVIDER;\n\n\tUTILS_LP_FAST(motor_now->m_motor_state.v_bus, GET_INPUT_VOLTAGE(), 0.1);\n\n\tfloat enc_ang = 0;\n\tif (encoder_is_configured()) {\n\t\tif (virtual_motor_is_connected()){\n\t\t\tenc_ang = virtual_motor_get_angle_deg();\n\t\t} else {\n\t\t\tenc_ang = encoder_read_deg();\n\t\t}\n\n\t\tfloat phase_tmp = enc_ang;\n\t\tif (conf_now->foc_encoder_inverted) {\n\t\t\tphase_tmp = 360.0 - phase_tmp;\n\t\t}\n\t\tphase_tmp *= conf_now->foc_encoder_ratio;\n\t\tphase_tmp -= conf_now->foc_encoder_offset;\n\t\tutils_norm_angle((float*)&phase_tmp);\n\t\tmotor_now->m_phase_now_encoder = phase_tmp * (M_PI / 180.0);\n\t}\n\n\tconst float phase_diff = utils_angle_difference_rad(motor_now->m_motor_state.phase, motor_now->m_phase_before);\n\tmotor_now->m_phase_before = motor_now->m_motor_state.phase;\n\n\tif (motor_now->m_state == MC_STATE_RUNNING) {\n\t\t// Clarke transform assuming balanced currents\n\t\tmotor_now->m_motor_state.i_alpha = ia;\n\t\tmotor_now->m_motor_state.i_beta = ONE_BY_SQRT3 * ia + TWO_BY_SQRT3 * ib;\n\n\t\t// Full Clarke transform in case there are current offsets\n//\t\tm_motor_state.i_alpha = (2.0 / 3.0) * ia - (1.0 / 3.0) * ib - (1.0 / 3.0) * ic;\n//\t\tm_motor_state.i_beta = ONE_BY_SQRT3 * ib - ONE_BY_SQRT3 * ic;\n\n\t\tconst float duty_abs = fabsf(motor_now->m_motor_state.duty_now);\n\t\tfloat id_set_tmp = motor_now->m_id_set;\n\t\tfloat iq_set_tmp = motor_now->m_iq_set;\n\t\tmotor_now->m_motor_state.max_duty = conf_now->l_max_duty;\n\n\t\tUTILS_LP_FAST(motor_now->m_duty_filtered, motor_now->m_motor_state.duty_now, 0.1);\n\t\tutils_truncate_number((float*)&motor_now->m_duty_filtered, -1.0, 1.0);\n\n\t\tfloat duty_set = motor_now->m_duty_cycle_set;\n\t\tbool control_duty = motor_now->m_control_mode == CONTROL_MODE_DUTY ||\n\t\t\t\tmotor_now->m_control_mode == CONTROL_MODE_OPENLOOP_DUTY ||\n\t\t\t\tmotor_now->m_control_mode == CONTROL_MODE_OPENLOOP_DUTY_PHASE;\n\n\t\t// When the modulation is low in brake mode and the set brake current\n\t\t// cannot be reached, short all phases to get more braking without\n\t\t// applying active braking. Use a bit of hysteresis when leaving\n\t\t// the shorted mode.\n\t\tif (motor_now->m_control_mode == CONTROL_MODE_CURRENT_BRAKE &&\n\t\t\t\tfabsf(motor_now->m_duty_filtered) < conf_now->l_min_duty * 1.5 &&\n\t\t\t\t(motor_now->m_motor_state.i_abs * (motor_now->m_was_full_brake ? 1.0 : 1.5)) < fabsf(motor_now->m_iq_set)) {\n\t\t\tcontrol_duty = true;\n\t\t\tduty_set = 0.0;\n\t\t\tmotor_now->m_was_full_brake = true;\n\t\t} else {\n\t\t\tmotor_now->m_was_full_brake = false;\n\t\t}\n\n\t\t// Brake when set ERPM is below min ERPM\n\t\tif (motor_now->m_control_mode == CONTROL_MODE_SPEED &&\n\t\t\t\tfabsf(motor_now->m_speed_pid_set_rpm) < conf_now->s_pid_min_erpm) {\n\t\t\tcontrol_duty = true;\n\t\t\tduty_set = 0.0;\n\t\t}\n\n\t\t// Reset integrator when leaving duty cycle mode, as the windup protection is not too fast. Making\n\t\t// better windup protection is probably better, but not easy.\n\t\tif (!control_duty && motor_now->m_was_control_duty) {\n\t\t\tmotor_now->m_motor_state.vq_int = motor_now->m_motor_state.vq;\n\t\t\tif (conf_now->foc_cc_decoupling == FOC_CC_DECOUPLING_BEMF ||\n\t\t\t\t\tconf_now->foc_cc_decoupling == FOC_CC_DECOUPLING_CROSS_BEMF) {\n\t\t\t\tmotor_now->m_motor_state.vq_int -= motor_now->m_motor_state.speed_rad_s * conf_now->foc_motor_flux_linkage;\n\t\t\t}\n\t\t}\n\t\tmotor_now->m_was_control_duty = control_duty;\n\n\t\tif (control_duty) {\n\t\t\t// Duty cycle control\n\t\t\tif (fabsf(duty_set) < (duty_abs - 0.05) ||\n\t\t\t\t\t(SIGN(motor_now->m_motor_state.vq) * motor_now->m_motor_state.iq) < conf_now->lo_current_min) {\n\t\t\t\t// Truncating the duty cycle here would be dangerous, so run a PID controller.\n\n\t\t\t\t// Compensation for supply voltage variations\n\t\t\t\tfloat scale = 1.0 / GET_INPUT_VOLTAGE();\n\n\t\t\t\t// Compute error\n\t\t\t\tfloat error = duty_set - motor_now->m_motor_state.duty_now;\n\n\t\t\t\t// Compute parameters\n\t\t\t\tfloat p_term = error * conf_now->foc_duty_dowmramp_kp * scale;\n\t\t\t\tmotor_now->m_duty_i_term += error * (conf_now->foc_duty_dowmramp_ki * dt) * scale;\n\n\t\t\t\t// I-term wind-up protection\n\t\t\t\tutils_truncate_number((float*)&motor_now->m_duty_i_term, -1.0, 1.0);\n\n\t\t\t\t// Calculate output\n\t\t\t\tfloat output = p_term + motor_now->m_duty_i_term;\n\t\t\t\tutils_truncate_number(&output, -1.0, 1.0);\n\t\t\t\tiq_set_tmp = output * conf_now->lo_current_max;\n\t\t\t} else {\n\t\t\t\t// If the duty cycle is less than or equal to the set duty cycle just limit\n\t\t\t\t// the modulation and use the maximum allowed current.\n\t\t\t\tmotor_now->m_duty_i_term = 0.0;\n\t\t\t\tmotor_now->m_motor_state.max_duty = duty_set;\n\t\t\t\tif (duty_set > 0.0) {\n\t\t\t\t\tiq_set_tmp = conf_now->lo_current_max;\n\t\t\t\t} else {\n\t\t\t\t\tiq_set_tmp = -conf_now->lo_current_max;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (motor_now->m_control_mode == CONTROL_MODE_CURRENT_BRAKE) {\n\t\t\t// Braking\n\t\t\tiq_set_tmp = fabsf(iq_set_tmp);\n\n\t\t\tif (phase_diff > 0.0) {\n\t\t\t\tiq_set_tmp = -iq_set_tmp;\n\t\t\t} else if (phase_diff == 0.0) {\n\t\t\t\tiq_set_tmp = 0.0;\n\t\t\t}\n\t\t}\n\n\t\t// Run observer\n\t\tif (!motor_now->m_phase_override) {\n\t\t\tobserver_update(motor_now->m_motor_state.v_alpha, motor_now->m_motor_state.v_beta,\n\t\t\t\t\t\t\tmotor_now->m_motor_state.i_alpha, motor_now->m_motor_state.i_beta, dt,\n\t\t\t\t\t\t\t&motor_now->m_observer_x1, &motor_now->m_observer_x2, &motor_now->m_phase_now_observer, motor_now);\n\t\t\tmotor_now->m_phase_now_observer += motor_now->m_pll_speed * dt * 0.5;\n\t\t\tutils_norm_angle_rad((float*)&motor_now->m_phase_now_observer);\n\t\t}\n\n\t\tswitch (conf_now->foc_sensor_mode) {\n\t\tcase FOC_SENSOR_MODE_ENCODER:\n\t\t\tif (encoder_index_found()) {\n\t\t\t\tmotor_now->m_motor_state.phase = correct_encoder(\n\t\t\t\t\t\tmotor_now->m_phase_now_observer,\n\t\t\t\t\t\tmotor_now->m_phase_now_encoder,\n\t\t\t\t\t\tmotor_now->m_speed_est_fast,\n\t\t\t\t\t\tconf_now->foc_sl_erpm,\n\t\t\t\t\t\tmotor_now);\n\t\t\t} else {\n\t\t\t\t// Rotate the motor in open loop if the index isn't found.\n\t\t\t\tmotor_now->m_motor_state.phase = motor_now->m_phase_now_encoder_no_index;\n\t\t\t}\n\n\t\t\tif (!motor_now->m_phase_override) {\n\t\t\t\tid_set_tmp = 0.0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FOC_SENSOR_MODE_HALL:\n\t\t\tmotor_now->m_phase_now_observer = correct_hall(motor_now->m_phase_now_observer, dt, motor_now);\n\t\t\tmotor_now->m_motor_state.phase = motor_now->m_phase_now_observer;\n\n\t\t\tif (!motor_now->m_phase_override) {\n\t\t\t\tid_set_tmp = 0.0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FOC_SENSOR_MODE_SENSORLESS:\n\t\t\tif (motor_now->m_phase_observer_override) {\n\t\t\t\tmotor_now->m_motor_state.phase = motor_now->m_phase_now_observer_override;\n\t\t\t} else {\n\t\t\t\tmotor_now->m_motor_state.phase = motor_now->m_phase_now_observer;\n\t\t\t}\n\n\t\t\t// Inject D axis current at low speed to make the observer track\n\t\t\t// better. This does not seem to be necessary with dead time\n\t\t\t// compensation.\n\t\t\t// Note: this is done at high rate prevent noise.\n\t\t\tif (!motor_now->m_phase_override) {\n\t\t\t\tif (duty_abs < conf_now->foc_sl_d_current_duty) {\n\t\t\t\t\tid_set_tmp = utils_map(duty_abs, 0.0, conf_now->foc_sl_d_current_duty,\n\t\t\t\t\t\t\t\t\t\t   fabsf(motor_now->m_motor_state.iq_target) * conf_now->foc_sl_d_current_factor, 0.0);\n\t\t\t\t} else {\n\t\t\t\t\tid_set_tmp = 0.0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase FOC_SENSOR_MODE_HFI:\n\t\t\tif (fabsf(motor_now->m_speed_est_fast * (60.0 / (2.0 * M_PI))) > conf_now->foc_sl_erpm_hfi) {\n\t\t\t\tmotor_now->m_hfi.observer_zero_time = 0;\n\t\t\t} else {\n\t\t\t\tmotor_now->m_hfi.observer_zero_time += dt;\n\t\t\t}\n\n\t\t\tif (motor_now->m_hfi.observer_zero_time < conf_now->foc_hfi_obs_ovr_sec) {\n\t\t\t\tmotor_now->m_hfi.angle = motor_now->m_phase_now_observer;\n\t\t\t}\n\n\t\t\tmotor_now->m_motor_state.phase = correct_encoder(\n\t\t\t\t\tmotor_now->m_phase_now_observer,\n\t\t\t\t\tmotor_now->m_hfi.angle,\n\t\t\t\t\tmotor_now->m_speed_est_fast,\n\t\t\t\t\tconf_now->foc_sl_erpm_hfi,\n\t\t\t\t\tmotor_now);\n\n\t\t\tif (!motor_now->m_phase_override) {\n\t\t\t\tid_set_tmp = 0.0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (motor_now->m_control_mode == CONTROL_MODE_HANDBRAKE) {\n\t\t\t// Force the phase to 0 in handbrake mode so that the current simply locks the rotor.\n\t\t\tmotor_now->m_motor_state.phase = 0.0;\n\t\t} else if (motor_now->m_control_mode == CONTROL_MODE_OPENLOOP ||\n\t\t\t\tmotor_now->m_control_mode == CONTROL_MODE_OPENLOOP_DUTY) {\n\t\t\tmotor_now->m_openloop_angle += dt * motor_now->m_openloop_speed;\n\t\t\tutils_norm_angle_rad((float*)&motor_now->m_openloop_angle);\n\t\t\tmotor_now->m_motor_state.phase = motor_now->m_openloop_angle;\n\t\t} else if (motor_now->m_control_mode == CONTROL_MODE_OPENLOOP_PHASE ||\n\t\t\t\tmotor_now->m_control_mode == CONTROL_MODE_OPENLOOP_DUTY_PHASE) {\n\t\t\tmotor_now->m_motor_state.phase = motor_now->m_openloop_phase;\n\t\t}\n\n\t\tif (motor_now->m_phase_override) {\n\t\t\tmotor_now->m_motor_state.phase = motor_now->m_phase_now_override;\n\t\t}\n\n\t\t// Apply current limits\n\t\t// TODO: Consider D axis current for the input current as well.\n\t\tconst float mod_q = motor_now->m_motor_state.mod_q;\n\t\tif (mod_q > 0.001) {\n\t\t\tutils_truncate_number(&iq_set_tmp, conf_now->lo_in_current_min / mod_q, conf_now->lo_in_current_max / mod_q);\n\t\t} else if (mod_q < -0.001) {\n\t\t\tutils_truncate_number(&iq_set_tmp, conf_now->lo_in_current_max / mod_q, conf_now->lo_in_current_min / mod_q);\n\t\t}\n\n\t\tif (mod_q > 0.0) {\n\t\t\tutils_truncate_number(&iq_set_tmp, conf_now->lo_current_min, conf_now->lo_current_max);\n\t\t} else {\n\t\t\tutils_truncate_number(&iq_set_tmp, -conf_now->lo_current_max, -conf_now->lo_current_min);\n\t\t}\n\n\t\tutils_saturate_vector_2d(&id_set_tmp, &iq_set_tmp,\n\t\t\t\t\t\t\t\t utils_max_abs(conf_now->lo_current_max, conf_now->lo_current_min));\n\n\t\tmotor_now->m_motor_state.id_target = id_set_tmp;\n\t\tmotor_now->m_motor_state.iq_target = iq_set_tmp;\n\n\t\tcontrol_current(motor_now, dt);\n\t} else {\n\t\t// The current is 0 when the motor is undriven\n\t\tmotor_now->m_motor_state.i_alpha = 0.0;\n\t\tmotor_now->m_motor_state.i_beta = 0.0;\n\t\tmotor_now->m_motor_state.id = 0.0;\n\t\tmotor_now->m_motor_state.iq = 0.0;\n\t\tmotor_now->m_motor_state.id_filter = 0.0;\n\t\tmotor_now->m_motor_state.iq_filter = 0.0;\n\t\tmotor_now->m_motor_state.i_bus = 0.0;\n\t\tmotor_now->m_motor_state.i_abs = 0.0;\n\t\tmotor_now->m_motor_state.i_abs_filter = 0.0;\n\n\t\t// Track back emf\n#ifdef HW_HAS_DUAL_MOTORS\n#ifdef HW_HAS_3_SHUNTS\n\t\tfloat Va, Vb, Vc;\n\t\tif (is_second_motor) {\n\t\t\tVa = ADC_VOLTS(ADC_IND_SENS4) * ((VIN_R1 + VIN_R2) / VIN_R2);\n\t\t\tVb = ADC_VOLTS(ADC_IND_SENS5) * ((VIN_R1 + VIN_R2) / VIN_R2);\n\t\t\tVc = ADC_VOLTS(ADC_IND_SENS6) * ((VIN_R1 + VIN_R2) / VIN_R2);\n\t\t} else {\n\t\t\tVa = ADC_VOLTS(ADC_IND_SENS1) * ((VIN_R1 + VIN_R2) / VIN_R2);\n\t\t\tVb = ADC_VOLTS(ADC_IND_SENS2) * ((VIN_R1 + VIN_R2) / VIN_R2);\n\t\t\tVc = ADC_VOLTS(ADC_IND_SENS3) * ((VIN_R1 + VIN_R2) / VIN_R2);\n\t\t}\n#else\n\t\tfloat Va, Vb, Vc;\n\t\tif (is_second_motor) {\n\t\t\tVa = ADC_VOLTS(ADC_IND_SENS4) * ((VIN_R1 + VIN_R2) / VIN_R2);\n\t\t\tVb = ADC_VOLTS(ADC_IND_SENS6) * ((VIN_R1 + VIN_R2) / VIN_R2);\n\t\t\tVc = ADC_VOLTS(ADC_IND_SENS5) * ((VIN_R1 + VIN_R2) / VIN_R2);\n\t\t} else {\n\t\t\tVa = ADC_VOLTS(ADC_IND_SENS1) * ((VIN_R1 + VIN_R2) / VIN_R2);\n\t\t\tVb = ADC_VOLTS(ADC_IND_SENS3) * ((VIN_R1 + VIN_R2) / VIN_R2);\n\t\t\tVc = ADC_VOLTS(ADC_IND_SENS2) * ((VIN_R1 + VIN_R2) / VIN_R2);\n\t\t}\n#endif\n#else\n#ifdef HW_HAS_3_SHUNTS\n\t\tfloat Va = ADC_VOLTS(ADC_IND_SENS1) * ((VIN_R1 + VIN_R2) / VIN_R2);\n\t\tfloat Vb = ADC_VOLTS(ADC_IND_SENS2) * ((VIN_R1 + VIN_R2) / VIN_R2);\n\t\tfloat Vc = ADC_VOLTS(ADC_IND_SENS3) * ((VIN_R1 + VIN_R2) / VIN_R2);\n#else\n\t\tfloat Va = ADC_VOLTS(ADC_IND_SENS1) * ((VIN_R1 + VIN_R2) / VIN_R2);\n\t\tfloat Vb = ADC_VOLTS(ADC_IND_SENS3) * ((VIN_R1 + VIN_R2) / VIN_R2);\n\t\tfloat Vc = ADC_VOLTS(ADC_IND_SENS2) * ((VIN_R1 + VIN_R2) / VIN_R2);\n#endif\n#endif\n\n\t\t// Full Clarke transform (no balanced voltages)\n\t\tmotor_now->m_motor_state.v_alpha = (2.0 / 3.0) * Va - (1.0 / 3.0) * Vb - (1.0 / 3.0) * Vc;\n\t\tmotor_now->m_motor_state.v_beta = ONE_BY_SQRT3 * Vb - ONE_BY_SQRT3 * Vc;\n\n#ifdef HW_USE_LINE_TO_LINE\n\t\t// rotate alpha-beta 30 degrees to compensate for line-to-line phase voltage sensing\n\t\tfloat x_tmp = motor_now->m_motor_state.v_alpha;\n\t\tfloat y_tmp = motor_now->m_motor_state.v_beta;\n\n\t\tmotor_now->m_motor_state.v_alpha = x_tmp * COS_MINUS_30_DEG - y_tmp * SIN_MINUS_30_DEG;\n\t\tmotor_now->m_motor_state.v_beta = x_tmp * SIN_MINUS_30_DEG + y_tmp * COS_MINUS_30_DEG;\n\n\t\t// compensate voltage amplitude\n\t\tmotor_now->m_motor_state.v_alpha *= ONE_BY_SQRT3;\n\t\tmotor_now->m_motor_state.v_beta *= ONE_BY_SQRT3;\n#endif\n\n\t\t// Run observer\n\t\tobserver_update(motor_now->m_motor_state.v_alpha, motor_now->m_motor_state.v_beta,\n\t\t\t\t\t\tmotor_now->m_motor_state.i_alpha, motor_now->m_motor_state.i_beta, dt,\n\t\t\t\t\t\t&motor_now->m_observer_x1, &motor_now->m_observer_x2, 0, motor_now);\n\t\tmotor_now->m_phase_now_observer = utils_fast_atan2(motor_now->m_x2_prev + motor_now->m_observer_x2,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   motor_now->m_x1_prev + motor_now->m_observer_x1);\n\n\t\tmotor_now->m_x1_prev = motor_now->m_observer_x1;\n\t\tmotor_now->m_x2_prev = motor_now->m_observer_x2;\n\n\t\tswitch (conf_now->foc_sensor_mode) {\n\t\tcase FOC_SENSOR_MODE_ENCODER:\n\t\t\tmotor_now->m_motor_state.phase = correct_encoder(\n\t\t\t\t\tmotor_now->m_phase_now_observer,\n\t\t\t\t\tmotor_now->m_phase_now_encoder,\n\t\t\t\t\tmotor_now->m_speed_est_fast,\n\t\t\t\t\tconf_now->foc_sl_erpm,\n\t\t\t\t\tmotor_now);\n\t\t\tbreak;\n\t\tcase FOC_SENSOR_MODE_HALL:\n\t\t\tmotor_now->m_phase_now_observer = correct_hall(motor_now->m_phase_now_observer, dt, motor_now);\n\t\t\tmotor_now->m_motor_state.phase = motor_now->m_phase_now_observer;\n\t\t\tbreak;\n\t\tcase FOC_SENSOR_MODE_SENSORLESS:\n\t\t\tmotor_now->m_motor_state.phase = motor_now->m_phase_now_observer;\n\t\t\tbreak;\n\t\tcase FOC_SENSOR_MODE_HFI: {\n\t\t\tmotor_now->m_motor_state.phase = motor_now->m_phase_now_observer;\n\t\t\tif (fabsf(motor_now->m_pll_speed * (60.0 / (2.0 * M_PI))) < (conf_now->foc_sl_erpm_hfi * 1.1)) {\n\t\t\t\tmotor_now->m_hfi.est_done_cnt = 0;\n\t\t\t}\n\t\t} break;\n\t\t}\n\n\t\t// HFI Restore\n\t\tCURRENT_FILTER_ON();\n\t\tmotor_now->m_hfi.ind = 0;\n\t\tmotor_now->m_hfi.ready = false;\n\t\tmotor_now->m_hfi.is_samp_n = false;\n\t\tmotor_now->m_hfi.prev_sample = 0.0;\n\t\tmotor_now->m_hfi.angle = motor_now->m_motor_state.phase;\n\n\t\tfloat c, s;\n\t\tutils_fast_sincos_better(motor_now->m_motor_state.phase, &s, &c);\n\n\t\t// Park transform\n\t\tfloat vd_tmp = c * motor_now->m_motor_state.v_alpha + s * motor_now->m_motor_state.v_beta;\n\t\tfloat vq_tmp = c * motor_now->m_motor_state.v_beta  - s * motor_now->m_motor_state.v_alpha;\n\n\t\tUTILS_NAN_ZERO(motor_now->m_motor_state.vd);\n\t\tUTILS_NAN_ZERO(motor_now->m_motor_state.vq);\n\n\t\tUTILS_LP_FAST(motor_now->m_motor_state.vd, vd_tmp, 0.2);\n\t\tUTILS_LP_FAST(motor_now->m_motor_state.vq, vq_tmp, 0.2);\n\n\t\t// Set the current controller integrator to the BEMF voltage to avoid\n\t\t// a current spike when the motor is driven again. Notice that we have\n\t\t// to take decoupling into account.\n\t\tmotor_now->m_motor_state.vd_int = motor_now->m_motor_state.vd;\n\t\tmotor_now->m_motor_state.vq_int = motor_now->m_motor_state.vq;\n\n\t\tif (conf_now->foc_cc_decoupling == FOC_CC_DECOUPLING_BEMF ||\n\t\t\t\tconf_now->foc_cc_decoupling == FOC_CC_DECOUPLING_CROSS_BEMF) {\n\t\t\tmotor_now->m_motor_state.vq_int -= motor_now->m_motor_state.speed_rad_s * conf_now->foc_motor_flux_linkage;\n\t\t}\n\n\t\t// Update corresponding modulation\n\t\tmotor_now->m_motor_state.mod_d = motor_now->m_motor_state.vd / ((2.0 / 3.0) * motor_now->m_motor_state.v_bus);\n\t\tmotor_now->m_motor_state.mod_q = motor_now->m_motor_state.vq / ((2.0 / 3.0) * motor_now->m_motor_state.v_bus);\n\t}\n\n\t// Calculate duty cycle\n\tmotor_now->m_motor_state.duty_now = SIGN(motor_now->m_motor_state.vq) *\n\t\t\tsqrtf(SQ(motor_now->m_motor_state.mod_d) + SQ(motor_now->m_motor_state.mod_q))\n\t\t\t/ SQRT3_BY_2;\n\n\t// Run PLL for speed estimation\n\tpll_run(motor_now->m_motor_state.phase, dt, &motor_now->m_pll_phase, &motor_now->m_pll_speed, conf_now);\n\tmotor_now->m_motor_state.speed_rad_s = motor_now->m_pll_speed;\n\n\t// Low latency speed estimation, for e.g. HFI.\n\t{\n\t\t// Based on back emf and motor parameters. This could be useful for a resistance observer in the future.\n//\t\tUTILS_LP_FAST(m_speed_est_fast, (m_motor_state.vq - (3.0 / 2.0) * m_conf->foc_motor_r * m_motor_state.iq) / m_conf->foc_motor_flux_linkage, 0.05);\n\n\t\t// Based on angle difference\n\t\tfloat diff = utils_angle_difference_rad(motor_now->m_motor_state.phase, motor_now->m_phase_before_speed_est);\n\t\tutils_truncate_number(&diff, -M_PI / 3.0, M_PI / 3.0);\n\n\t\tUTILS_LP_FAST(motor_now->m_speed_est_fast, diff / dt, 0.01);\n\t\tUTILS_NAN_ZERO(motor_now->m_speed_est_fast);\n\n\t\tUTILS_LP_FAST(motor_now->m_speed_est_faster, diff / dt, 0.2);\n\t\tUTILS_NAN_ZERO(motor_now->m_speed_est_faster);\n\n\t\tmotor_now->m_phase_before_speed_est = motor_now->m_motor_state.phase;\n\t}\n\n\t// Update tachometer (resolution = 60 deg as for BLDC)\n\tfloat ph_tmp = motor_now->m_motor_state.phase;\n\tutils_norm_angle_rad(&ph_tmp);\n\tint step = (int)floorf((ph_tmp + M_PI) / (2.0 * M_PI) * 6.0);\n\tutils_truncate_number_int(&step, 0, 5);\n\tint diff = step - motor_now->m_tacho_step_last;\n\tmotor_now->m_tacho_step_last = step;\n\n\tif (diff > 3) {\n\t\tdiff -= 6;\n\t} else if (diff < -2) {\n\t\tdiff += 6;\n\t}\n\n\tmotor_now->m_tachometer += diff;\n\tmotor_now->m_tachometer_abs += abs(diff);\n\n\t// Track position control angle\n\t// TODO: Have another look at this.\n\tfloat angle_now = 0.0;\n\tif (encoder_is_configured()) {\n\t\tif (conf_now->m_sensor_port_mode == SENSOR_PORT_MODE_TS5700N8501_MULTITURN) {\n\t\t\tangle_now = encoder_read_deg_multiturn();\n\t\t} else {\n\t\t\tangle_now = enc_ang;\n\t\t}\n\t} else {\n\t\tangle_now = motor_now->m_motor_state.phase * (180.0 / M_PI);\n\t}\n\n\tif (conf_now->p_pid_ang_div > 0.98 && conf_now->p_pid_ang_div < 1.02) {\n\t\tmotor_now->m_pos_pid_now = angle_now;\n\t} else {\n\t\tfloat diff_f = utils_angle_difference(angle_now, motor_now->m_pid_div_angle_last);\n\t\tmotor_now->m_pid_div_angle_last = angle_now;\n\t\tmotor_now->m_pos_pid_now += diff_f / conf_now->p_pid_ang_div;\n\t\tutils_norm_angle((float*)&motor_now->m_pos_pid_now);\n\t}\n\n\t// Run position control\n\tif (motor_now->m_state == MC_STATE_RUNNING) {\n\t\trun_pid_control_pos(motor_now->m_pos_pid_now, motor_now->m_pos_pid_set, dt, motor_now);\n\t}\n\n#ifdef AD2S1205_SAMPLE_GPIO\n\t// Release sample in the AD2S1205 resolver IC.\n\tpalSetPad(AD2S1205_SAMPLE_GPIO, AD2S1205_SAMPLE_PIN);\n#endif\n\n#ifdef HW_HAS_DUAL_MOTORS\n\tmc_interface_mc_timer_isr(is_second_motor);\n#else\n\tmc_interface_mc_timer_isr(false);\n#endif\n\n\tm_isr_motor = 0;\n\tm_last_adc_isr_duration = timer_seconds_elapsed_since(t_start);\n}\n\n// Private functions\n\nstatic void timer_update(volatile motor_all_state_t *motor, float dt) {\n\tfloat openloop_rpm = utils_map(fabsf(motor->m_motor_state.iq_target),\n\t\t\t\t\t\t\t\t   0.0, motor->m_conf->l_current_max,\n\t\t\t\t\t\t\t\t   0.0, motor->m_conf->foc_openloop_rpm);\n\n\tutils_truncate_number_abs(&openloop_rpm, motor->m_conf->foc_openloop_rpm);\n\n\tconst float min_rads = (openloop_rpm * 2.0 * M_PI) / 60.0;\n\n\tfloat add_min_speed = 0.0;\n\tif (motor->m_motor_state.duty_now > 0.0) {\n\t\tadd_min_speed = min_rads * dt;\n\t} else {\n\t\tadd_min_speed = -min_rads * dt;\n\t}\n\n\t// Open loop encoder angle for when the index is not found\n\tmotor->m_phase_now_encoder_no_index += add_min_speed;\n\tutils_norm_angle_rad((float*)&motor->m_phase_now_encoder_no_index);\n\n\t// Output a minimum speed from the observer\n\tif (fabsf(motor->m_pll_speed) < min_rads) {\n\t\tmotor->m_min_rpm_hyst_timer += dt;\n\t} else if (motor->m_min_rpm_hyst_timer > 0.0) {\n\t\tmotor->m_min_rpm_hyst_timer -= dt;\n\t}\n\n\t// Don't use this in brake mode.\n\tif (motor->m_control_mode == CONTROL_MODE_CURRENT_BRAKE || fabsf(motor->m_motor_state.duty_now) < 0.001) {\n\t\tmotor->m_min_rpm_hyst_timer = 0.0;\n\t\tmotor->m_phase_observer_override = false;\n\t}\n\n\tbool started_now = false;\n\tif (motor->m_min_rpm_hyst_timer > motor->m_conf->foc_sl_openloop_hyst && motor->m_min_rpm_timer <= 0.0001) {\n\t\tmotor->m_min_rpm_timer = motor->m_conf->foc_sl_openloop_time;\n\t\tstarted_now = true;\n\t}\n\n\tif (motor->m_min_rpm_timer > 0.0) {\n\t\tmotor->m_phase_now_observer_override += add_min_speed;\n\n\t\t// When the motor gets stuck it tends to be 90 degrees off, so start the open loop\n\t\t// sequence by correcting with 90 degrees.\n\t\tif (started_now) {\n\t\t\tif (motor->m_motor_state.duty_now > 0.0) {\n\t\t\t\tmotor->m_phase_now_observer_override += M_PI / 2.0;\n\t\t\t} else {\n\t\t\t\tmotor->m_phase_now_observer_override -= M_PI / 2.0;\n\t\t\t}\n\t\t}\n\n\t\tutils_norm_angle_rad((float*)&motor->m_phase_now_observer_override);\n\t\tmotor->m_phase_observer_override = true;\n\t\tmotor->m_min_rpm_timer -= dt;\n\t\tmotor->m_min_rpm_hyst_timer = 0.0;\n\t} else {\n\t\tmotor->m_phase_now_observer_override = motor->m_phase_now_observer;\n\t\tmotor->m_phase_observer_override = false;\n\t}\n\n\t// Samples\n\tif (motor->m_state == MC_STATE_RUNNING) {\n\t\tconst volatile float vd_tmp = motor->m_motor_state.vd;\n\t\tconst volatile float vq_tmp = motor->m_motor_state.vq;\n\t\tconst volatile float id_tmp = motor->m_motor_state.id;\n\t\tconst volatile float iq_tmp = motor->m_motor_state.iq;\n\n\t\tmotor->m_samples.avg_current_tot += sqrtf(SQ(id_tmp) + SQ(iq_tmp));\n\t\tmotor->m_samples.avg_voltage_tot += sqrtf(SQ(vd_tmp) + SQ(vq_tmp));\n\t\tmotor->m_samples.sample_num++;\n\t}\n\n\t// Update and the observer gain.\n\n\t// Old gain scaling, based on duty cycle\n//\tmotor->m_gamma_now = utils_map(fabsf(motor->m_motor_state.duty_now), 0.0, 1.0,\n//\t\t\tmotor->m_conf->foc_observer_gain * motor->m_conf->foc_observer_gain_slow,\n//\t\t\tmotor->m_conf->foc_observer_gain);\n\n\t// Observer gain scaling, based on bus voltage and duty cycle\n\tfloat gamma_tmp = utils_map(fabsf(motor->m_motor_state.duty_now),\n\t\t\t\t\t\t\t\t0.0, 40.0 / motor->m_motor_state.v_bus,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tmotor->m_conf->foc_observer_gain);\n\tif (gamma_tmp < (motor->m_conf->foc_observer_gain_slow * motor->m_conf->foc_observer_gain)) {\n\t\tgamma_tmp = motor->m_conf->foc_observer_gain_slow * motor->m_conf->foc_observer_gain;\n\t}\n\n\t// 4.0 scaling is kind of arbitrary, but it should make configs from old VESC Tools more likely to work.\n\tmotor->m_gamma_now = gamma_tmp * 4.0;\n}\n\nstatic THD_FUNCTION(timer_thread, arg) {\n\t(void)arg;\n\n\tchRegSetThreadName(\"foc timer\");\n\n\tfor(;;) {\n\t\tconst float dt = 0.001;\n\n\t\tif (timer_thd_stop) {\n\t\t\ttimer_thd_stop = false;\n\t\t\treturn;\n\t\t}\n\n\t\ttimer_update(&m_motor_1, dt);\n#ifdef HW_HAS_DUAL_MOTORS\n\t\ttimer_update(&m_motor_2, dt);\n#endif\n\n\t\trun_pid_control_speed(dt, &m_motor_1);\n#ifdef HW_HAS_DUAL_MOTORS\n\t\trun_pid_control_speed(dt, &m_motor_2);\n#endif\n\n\t\tchThdSleepMilliseconds(1);\n\t}\n}\n\nstatic void hfi_update(volatile motor_all_state_t *motor) {\n\tfloat rpm_abs = fabsf(motor->m_speed_est_fast * (60.0 / (2.0 * M_PI)));\n\n\tif (rpm_abs > motor->m_conf->foc_sl_erpm_hfi) {\n\t\tmotor->m_hfi.angle = motor->m_phase_now_observer;\n\t}\n\n\tif (motor->m_hfi.ready) {\n\t\tfloat real_bin1, imag_bin1, real_bin2, imag_bin2;\n\t\tmotor->m_hfi.fft_bin1_func((float*)motor->m_hfi.buffer, &real_bin1, &imag_bin1);\n\t\tmotor->m_hfi.fft_bin2_func((float*)motor->m_hfi.buffer, &real_bin2, &imag_bin2);\n\n\t\tfloat mag_bin_1 = sqrtf(SQ(imag_bin1) + SQ(real_bin1));\n\t\tfloat angle_bin_1 = -utils_fast_atan2(imag_bin1, real_bin1);\n\n\t\tangle_bin_1 += M_PI / 1.7; // Why 1.7??\n\t\tutils_norm_angle_rad(&angle_bin_1);\n\n\t\tfloat mag_bin_2 = sqrtf(SQ(imag_bin2) + SQ(real_bin2));\n\t\tfloat angle_bin_2 = -utils_fast_atan2(imag_bin2, real_bin2) / 2.0;\n\n\t\t// Assuming this thread is much faster than it takes to fill the HFI buffer completely,\n\t\t// we should lag 1/2 HFI buffer behind in phase. Compensate for that here.\n\t\tfloat dt_sw;\n\t\tif (motor->m_conf->foc_sample_v0_v7) {\n\t\t\tdt_sw = 1.0 / motor->m_conf->foc_f_sw;\n\t\t} else {\n\t\t\tdt_sw = 1.0 / (motor->m_conf->foc_f_sw / 2.0);\n\t\t}\n\t\tangle_bin_2 += motor->m_motor_state.speed_rad_s * ((float)motor->m_hfi.samples / 2.0) * dt_sw;\n\n\t\tif (fabsf(utils_angle_difference_rad(angle_bin_2 + M_PI, motor->m_hfi.angle)) <\n\t\t\t\tfabsf(utils_angle_difference_rad(angle_bin_2, motor->m_hfi.angle))) {\n\t\t\tangle_bin_2 += M_PI;\n\t\t}\n\n\t\tif (motor->m_hfi.est_done_cnt < motor->m_conf->foc_hfi_start_samples) {\n\t\t\tmotor->m_hfi.est_done_cnt++;\n\n\t\t\tif (fabsf(utils_angle_difference_rad(angle_bin_2, angle_bin_1)) > (M_PI / 2.0)) {\n\t\t\t\tmotor->m_hfi.flip_cnt++;\n\t\t\t}\n\t\t} else {\n\t\t\tif (motor->m_hfi.flip_cnt >= (motor->m_conf->foc_hfi_start_samples / 2)) {\n\t\t\t\tangle_bin_2 += M_PI;\n\t\t\t}\n\t\t\tmotor->m_hfi.flip_cnt = 0;\n\t\t}\n\n\t\tmotor->m_hfi.angle = angle_bin_2;\n\t\tutils_norm_angle_rad((float*)&motor->m_hfi.angle);\n\n\t\t// As angle_bin_1 is based on saturation, it is only accurate when the motor current is low. It\n\t\t// might be possible to compensate for that, which would allow HFI on non-salient motors.\n\t\t//\t\t\tm_hfi.angle = angle_bin_1;\n\n\t\tif (motor->m_hfi_plot_en == 1) {\n\t\t\tstatic float hfi_plot_div = 0;\n\t\t\thfi_plot_div++;\n\n\t\t\tif (hfi_plot_div >= 8) {\n\t\t\t\thfi_plot_div = 0;\n\n\t\t\t\tfloat real_bin0, imag_bin0;\n\t\t\t\tmotor->m_hfi.fft_bin0_func((float*)motor->m_hfi.buffer, &real_bin0, &imag_bin0);\n\n\t\t\t\tcommands_plot_set_graph(0);\n\t\t\t\tcommands_send_plot_points(motor->m_hfi_plot_sample, motor->m_hfi.angle);\n\n\t\t\t\tcommands_plot_set_graph(1);\n\t\t\t\tcommands_send_plot_points(motor->m_hfi_plot_sample, angle_bin_1);\n\n\t\t\t\tcommands_plot_set_graph(2);\n\t\t\t\tcommands_send_plot_points(motor->m_hfi_plot_sample, 2.0 * mag_bin_2 * 1e6);\n\n\t\t\t\tcommands_plot_set_graph(3);\n\t\t\t\tcommands_send_plot_points(motor->m_hfi_plot_sample, 2.0 * mag_bin_1 * 1e6);\n\n\t\t\t\tcommands_plot_set_graph(4);\n\t\t\t\tcommands_send_plot_points(motor->m_hfi_plot_sample, real_bin0 * 1e6);\n\n//\t\t\t\t\tcommands_plot_set_graph(0);\n//\t\t\t\t\tcommands_send_plot_points(motor->m_hfi_plot_sample, motor->m_motor_state.speed_rad_s);\n//\n//\t\t\t\t\tcommands_plot_set_graph(1);\n//\t\t\t\t\tcommands_send_plot_points(motor->m_hfi_plot_sample, motor->m_speed_est_fast);\n\n\t\t\t\tmotor->m_hfi_plot_sample++;\n\t\t\t}\n\t\t} else if (motor->m_hfi_plot_en == 2) {\n\t\t\tstatic float hfi_plot_div = 0;\n\t\t\thfi_plot_div++;\n\n\t\t\tif (hfi_plot_div >= 8) {\n\t\t\t\thfi_plot_div = 0;\n\n\t\t\t\tif (motor->m_hfi_plot_sample >= motor->m_hfi.samples) {\n\t\t\t\t\tmotor->m_hfi_plot_sample = 0;\n\t\t\t\t}\n\n\t\t\t\tcommands_plot_set_graph(0);\n\t\t\t\tcommands_send_plot_points(motor->m_hfi_plot_sample, motor->m_hfi.buffer_current[(int)motor->m_hfi_plot_sample]);\n\n\t\t\t\tcommands_plot_set_graph(1);\n\t\t\t\tcommands_send_plot_points(motor->m_hfi_plot_sample, motor->m_hfi.buffer[(int)motor->m_hfi_plot_sample] * 1e6);\n\n\t\t\t\tmotor->m_hfi_plot_sample++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tmotor->m_hfi.angle = motor->m_phase_now_observer;\n\t}\n}\n\nstatic THD_FUNCTION(hfi_thread, arg) {\n\t(void)arg;\n\n\tchRegSetThreadName(\"foc hfi\");\n\n\tfor(;;) {\n\t\tif (hfi_thd_stop) {\n\t\t\thfi_thd_stop = false;\n\t\t\treturn;\n\t\t}\n\n\t\thfi_update(&m_motor_1);\n#ifdef HW_HAS_DUAL_MOTORS\n\t\thfi_update(&m_motor_2);\n#endif\n\n\t\tchThdSleepMicroseconds(500);\n\t}\n}\n\nstatic void do_dc_cal(void) {\n\tDCCAL_ON();\n\n\t// Wait max 5 seconds\n\tint cnt = 0;\n\twhile(IS_DRV_FAULT()){\n\t\tchThdSleepMilliseconds(1);\n\t\tcnt++;\n\t\tif (cnt > 5000) {\n\t\t\tbreak;\n\t\t}\n\t};\n\n\tchThdSleepMilliseconds(1000);\n\n\tmemset((int*)m_motor_1.m_curr_sum, 0, sizeof(m_motor_1.m_curr_sum));\n\tm_motor_1.m_curr_samples = 0;\n\twhile(m_motor_1.m_curr_samples < 4000) {};\n\tm_motor_1.m_curr_ofs[0] = m_motor_1.m_curr_sum[0] / m_motor_1.m_curr_samples;\n\tm_motor_1.m_curr_ofs[1] = m_motor_1.m_curr_sum[1] / m_motor_1.m_curr_samples;\n#ifdef HW_HAS_3_SHUNTS\n\tm_motor_1.m_curr_ofs[2] = m_motor_1.m_curr_sum[2] / m_motor_1.m_curr_samples;\n#endif\n\n#ifdef HW_HAS_DUAL_MOTORS\n\tmemset((int*)m_motor_2.m_curr_sum, 0, sizeof(m_motor_2.m_curr_sum));\n\tm_motor_2.m_curr_samples = 0;\n\twhile(m_motor_2.m_curr_samples < 4000) {};\n\tm_motor_2.m_curr_ofs[0] = m_motor_2.m_curr_sum[0] / m_motor_2.m_curr_samples;\n\tm_motor_2.m_curr_ofs[1] = m_motor_2.m_curr_sum[1] / m_motor_2.m_curr_samples;\n#ifdef HW_HAS_3_SHUNTS\n\tm_motor_2.m_curr_ofs[2] = m_motor_2.m_curr_sum[2] / m_motor_2.m_curr_samples;\n#endif\n#endif\n\n\tDCCAL_OFF();\n\tm_dccal_done = true;\n}\n\n// See http://cas.ensmp.fr/~praly/Telechargement/Journaux/2010-IEEE_TPEL-Lee-Hong-Nam-Ortega-Praly-Astolfi.pdf\nvoid observer_update(float v_alpha, float v_beta, float i_alpha, float i_beta,\n\t\t\t\t\t float dt, volatile float *x1, volatile float *x2, volatile float *phase, volatile motor_all_state_t *motor) {\n\n\tvolatile mc_configuration *conf_now = motor->m_conf;\n\n\tconst float L = (3.0 / 2.0) * conf_now->foc_motor_l;\n\tfloat R = (3.0 / 2.0) * conf_now->foc_motor_r;\n\n\t// Saturation compensation\n\tconst float sign = (motor->m_motor_state.iq * motor->m_motor_state.vq) >= 0.0 ? 1.0 : -1.0;\n\tR -= R * sign * conf_now->foc_sat_comp * (motor->m_motor_state.i_abs_filter / conf_now->l_current_max);\n\n\t// Temperature compensation\n\tconst float t = mc_interface_temp_motor_filtered();\n\tif (conf_now->foc_temp_comp && t > -25.0) {\n\t\tR += R * 0.00386 * (t - conf_now->foc_temp_comp_base_temp);\n\t}\n\n\tconst float L_ia = L * i_alpha;\n\tconst float L_ib = L * i_beta;\n\tconst float R_ia = R * i_alpha;\n\tconst float R_ib = R * i_beta;\n\tconst float lambda_2 = SQ(conf_now->foc_motor_flux_linkage);\n\tconst float gamma_half = motor->m_gamma_now * 0.5;\n\n\tswitch (conf_now->foc_observer_type) {\n\tcase FOC_OBSERVER_ORTEGA_ORIGINAL: {\n\t\tfloat err = lambda_2 - (SQ(*x1 - L_ia) + SQ(*x2 - L_ib));\n\t\tfloat x1_dot = -R_ia + v_alpha + gamma_half * (*x1 - L_ia) * err;\n\t\tfloat x2_dot = -R_ib + v_beta + gamma_half * (*x2 - L_ib) * err;\n\t\t*x1 += x1_dot * dt;\n\t\t*x2 += x2_dot * dt;\n\t} break;\n\n\tcase FOC_OBSERVER_ORTEGA_ITERATIVE: {\n\t\t// Iterative with some trial and error\n\t\tconst int iterations = 6;\n\t\tconst float dt_iteration = dt / (float)iterations;\n\t\tfor (int i = 0;i < iterations;i++) {\n\t\t\tfloat err = lambda_2 - (SQ(*x1 - L_ia) + SQ(*x2 - L_ib));\n\t\t\tfloat gamma_tmp = gamma_half;\n\t\t\tif (utils_truncate_number_abs(&err, lambda_2 * 0.2)) {\n\t\t\t\tgamma_tmp *= 10.0;\n\t\t\t}\n\t\t\tfloat x1_dot = -R_ia + v_alpha + gamma_tmp * (*x1 - L_ia) * err;\n\t\t\tfloat x2_dot = -R_ib + v_beta + gamma_tmp * (*x2 - L_ib) * err;\n\n\t\t\t*x1 += x1_dot * dt_iteration;\n\t\t\t*x2 += x2_dot * dt_iteration;\n\t\t}\n\t} break;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\t// Same as iterative, but without iterations.\n//\tfloat err = lambda_2 - (SQ(*x1 - L_ia) + SQ(*x2 - L_ib));\n//\tfloat gamma_tmp = gamma_half;\n//\tif (utils_truncate_number_abs(&err, lambda_2 * 0.2)) {\n//\t\tgamma_tmp *= 10.0;\n//\t}\n//\tfloat x1_dot = -R_ia + v_alpha + gamma_tmp * (*x1 - L_ia) * err;\n//\tfloat x2_dot = -R_ib + v_beta + gamma_tmp * (*x2 - L_ib) * err;\n//\t*x1 += x1_dot * dt;\n//\t*x2 += x2_dot * dt;\n\n\tUTILS_NAN_ZERO(*x1);\n\tUTILS_NAN_ZERO(*x2);\n\n\tif (phase) {\n\t\t*phase = utils_fast_atan2(*x2 - L_ib, *x1 - L_ia);\n\t}\n}\n\nstatic void pll_run(float phase, float dt, volatile float *phase_var,\n\t\t\t\t\tvolatile float *speed_var, volatile mc_configuration *conf) {\n\tUTILS_NAN_ZERO(*phase_var);\n\tfloat delta_theta = phase - *phase_var;\n\tutils_norm_angle_rad(&delta_theta);\n\tUTILS_NAN_ZERO(*speed_var);\n\t*phase_var += (*speed_var + conf->foc_pll_kp * delta_theta) * dt;\n\tutils_norm_angle_rad((float*)phase_var);\n\t*speed_var += conf->foc_pll_ki * delta_theta * dt;\n}\n\n/**\n * Run the current control loop.\n *\n * @param state_m\n * The motor state.\n *\n * Parameters that shall be set before calling this function:\n * id_target\n * iq_target\n * max_duty\n * phase\n * i_alpha\n * i_beta\n * v_bus\n * speed_rad_s\n *\n * Parameters that will be updated in this function:\n * i_bus\n * i_abs\n * i_abs_filter\n * v_alpha\n * v_beta\n * mod_d\n * mod_q\n * id\n * iq\n * id_filter\n * iq_filter\n * vd\n * vq\n * vd_int\n * vq_int\n * svm_sector\n *\n * @param dt\n * The time step in seconds.\n */\nstatic void control_current(volatile motor_all_state_t *motor, float dt) {\n\tvolatile motor_state_t *state_m = &motor->m_motor_state;\n\tvolatile mc_configuration *conf_now = motor->m_conf;\n\n\tfloat c,s;\n\tutils_fast_sincos_better(state_m->phase, &s, &c);\n\n\tfloat abs_rpm = fabsf(motor->m_speed_est_fast * 60 / (2 * M_PI));\n\n\tbool do_hfi = conf_now->foc_sensor_mode == FOC_SENSOR_MODE_HFI &&\n\t\t\t!motor->m_phase_override &&\n\t\t\tabs_rpm < (conf_now->foc_sl_erpm_hfi * (motor->m_cc_was_hfi ? 1.8 : 1.5));\n\tmotor->m_cc_was_hfi = do_hfi;\n\n\t// Only allow Q axis current after the HFI ambiguity is resolved. This causes\n\t// a short delay when starting.\n\tif (do_hfi && motor->m_hfi.est_done_cnt < conf_now->foc_hfi_start_samples) {\n\t\tstate_m->iq_target = 0;\n\t}\n\n\tfloat max_duty = fabsf(state_m->max_duty);\n\tutils_truncate_number(&max_duty, 0.0, conf_now->l_max_duty);\n\n\tstate_m->id = c * state_m->i_alpha + s * state_m->i_beta;\n\tstate_m->iq = c * state_m->i_beta  - s * state_m->i_alpha;\n\tUTILS_LP_FAST(state_m->id_filter, state_m->id, conf_now->foc_current_filter_const);\n\tUTILS_LP_FAST(state_m->iq_filter, state_m->iq, conf_now->foc_current_filter_const);\n\n\tfloat Ierr_d = state_m->id_target - state_m->id;\n\tfloat Ierr_q = state_m->iq_target - state_m->iq;\n\n\tstate_m->vd = state_m->vd_int + Ierr_d * conf_now->foc_current_kp;\n\tstate_m->vq = state_m->vq_int + Ierr_q * conf_now->foc_current_kp;\n\n\t// Temperature compensation\n\tconst float t = mc_interface_temp_motor_filtered();\n\tfloat ki = conf_now->foc_current_ki;\n\tif (conf_now->foc_temp_comp && t > -5.0) {\n\t\tki += ki * 0.00386 * (t - conf_now->foc_temp_comp_base_temp);\n\t}\n\n\tstate_m->vd_int += Ierr_d * (ki * dt);\n\tstate_m->vq_int += Ierr_q * (ki * dt);\n\n\t// Decoupling\n\tfloat dec_vd = 0.0;\n\tfloat dec_vq = 0.0;\n\tfloat dec_bemf = 0.0;\n\n\tif (motor->m_control_mode < CONTROL_MODE_HANDBRAKE && conf_now->foc_cc_decoupling != FOC_CC_DECOUPLING_DISABLED) {\n\t\tswitch (conf_now->foc_cc_decoupling) {\n\t\tcase FOC_CC_DECOUPLING_CROSS:\n\t\t\tdec_vd = state_m->iq * state_m->speed_rad_s * conf_now->foc_motor_l * (3.0 / 2.0);\n\t\t\tdec_vq = state_m->id * state_m->speed_rad_s * conf_now->foc_motor_l * (3.0 / 2.0);\n\t\t\tbreak;\n\n\t\tcase FOC_CC_DECOUPLING_BEMF:\n\t\t\tdec_bemf = state_m->speed_rad_s * conf_now->foc_motor_flux_linkage;\n\t\t\tbreak;\n\n\t\tcase FOC_CC_DECOUPLING_CROSS_BEMF:\n\t\t\tdec_vd = state_m->iq * state_m->speed_rad_s * conf_now->foc_motor_l * (3.0 / 2.0);\n\t\t\tdec_vq = state_m->id * state_m->speed_rad_s * conf_now->foc_motor_l * (3.0 / 2.0);\n\t\t\tdec_bemf = state_m->speed_rad_s * conf_now->foc_motor_flux_linkage;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tstate_m->vd -= dec_vd;\n\tstate_m->vq += dec_vq + dec_bemf;\n\n\tfloat max_v_mag = (2.0 / 3.0) * max_duty * SQRT3_BY_2 * state_m->v_bus;\n\n\t// Saturation\n\tutils_saturate_vector_2d((float*)&state_m->vd, (float*)&state_m->vq, max_v_mag);\n\tstate_m->mod_d = state_m->vd / ((2.0 / 3.0) * state_m->v_bus);\n\tstate_m->mod_q = state_m->vq / ((2.0 / 3.0) * state_m->v_bus);\n\n\t// Integrator windup protection\n\t// This is important, tricky and probably needs improvement.\n\t// Currently we start by truncating the d-axis and then the q-axis with the magnitude that is\n\t// left. Axis decoupling is taken into account in the truncation. How to do that best is also\n\t// an open question...\n\n\t// Take both cross and back emf decoupling into consideration. Seems to make the control\n\t// noisy at full modulation.\n//\tutils_truncate_number((float*)&state_m->vd_int, -max_v_mag + dec_vd, max_v_mag + dec_vd);\n//\tfloat mag_left = sqrtf(SQ(max_v_mag) - SQ(state_m->vd_int - dec_vd));\n//\tutils_truncate_number((float*)&state_m->vq_int, -mag_left - (dec_vq + dec_bemf), mag_left - (dec_vq + dec_bemf));\n\n\t// Take only back emf decoupling into consideration. Seems to work best.\n\tutils_truncate_number((float*)&state_m->vd_int, -max_v_mag, max_v_mag);\n\tfloat mag_left = sqrtf(SQ(max_v_mag) - SQ(state_m->vd_int));\n\tutils_truncate_number((float*)&state_m->vq_int, -mag_left - dec_bemf, mag_left - dec_bemf);\n\n\t// Ignore decoupling. Works badly when back emf decoupling is used, probably not\n\t// the best way to go.\n//\tutils_truncate_number((float*)&state_m->vd_int, -max_v_mag, max_v_mag);\n//\tfloat mag_left = sqrtf(SQ(max_v_mag) - SQ(state_m->vd_int));\n//\tutils_truncate_number((float*)&state_m->vq_int, -mag_left, mag_left);\n\n\t// This is how anti-windup was done in FW < 4.0. Does not work well when there is too much D axis voltage.\n//\tutils_truncate_number((float*)&state_m->vd_int, -max_v_mag, max_v_mag);\n//\tutils_truncate_number((float*)&state_m->vq_int, -max_v_mag, max_v_mag);\n\n\t// TODO: Have a look at this?\n\tstate_m->i_bus = state_m->mod_d * state_m->id + state_m->mod_q * state_m->iq;\n\tstate_m->i_abs = sqrtf(SQ(state_m->id) + SQ(state_m->iq));\n\tstate_m->i_abs_filter = sqrtf(SQ(state_m->id_filter) + SQ(state_m->iq_filter));\n\n\tfloat mod_alpha = c * state_m->mod_d - s * state_m->mod_q;\n\tfloat mod_beta  = c * state_m->mod_q + s * state_m->mod_d;\n\n\t// Deadtime compensation\n\tconst float i_alpha_filter = c * state_m->id_target - s * state_m->iq_target;\n\tconst float i_beta_filter = c * state_m->iq_target + s * state_m->id_target;\n\tconst float ia_filter = i_alpha_filter;\n\tconst float ib_filter = -0.5 * i_alpha_filter + SQRT3_BY_2 * i_beta_filter;\n\tconst float ic_filter = -0.5 * i_alpha_filter - SQRT3_BY_2 * i_beta_filter;\n\tconst float mod_alpha_filter_sgn = (2.0 / 3.0) * SIGN(ia_filter) - (1.0 / 3.0) * SIGN(ib_filter) - (1.0 / 3.0) * SIGN(ic_filter);\n\tconst float mod_beta_filter_sgn = ONE_BY_SQRT3 * SIGN(ib_filter) - ONE_BY_SQRT3 * SIGN(ic_filter);\n\tconst float mod_comp_fact = conf_now->foc_dt_us * 1e-6 * conf_now->foc_f_sw;\n\tconst float mod_alpha_comp = mod_alpha_filter_sgn * mod_comp_fact;\n\tconst float mod_beta_comp = mod_beta_filter_sgn * mod_comp_fact;\n\n\t// Apply compensation here so that 0 duty cycle has no glitches.\n\tstate_m->v_alpha = (mod_alpha - mod_alpha_comp) * (2.0 / 3.0) * state_m->v_bus;\n\tstate_m->v_beta = (mod_beta - mod_beta_comp) * (2.0 / 3.0) * state_m->v_bus;\n\tstate_m->vd = c * motor->m_motor_state.v_alpha + s * motor->m_motor_state.v_beta;\n\tstate_m->vq = c * motor->m_motor_state.v_beta  - s * motor->m_motor_state.v_alpha;\n\n\t// HFI\n\tif (do_hfi) {\n\t\tCURRENT_FILTER_OFF();\n\n\t\tfloat mod_alpha_tmp = mod_alpha;\n\t\tfloat mod_beta_tmp = mod_beta;\n\n\t\tfloat hfi_voltage;\n\t\tif (motor->m_hfi.est_done_cnt < conf_now->foc_hfi_start_samples) {\n\t\t\thfi_voltage = conf_now->foc_hfi_voltage_start;\n\t\t} else {\n\t\t\thfi_voltage = utils_map(fabsf(state_m->iq), 0.0, conf_now->l_current_max,\n\t\t\t\t\t\t\t\t\tconf_now->foc_hfi_voltage_run, conf_now->foc_hfi_voltage_max);\n\t\t}\n\n\t\tutils_truncate_number_abs(&hfi_voltage, state_m->v_bus * (2.0 / 3.0) * 0.9);\n\n\t\tif (motor->m_hfi.is_samp_n) {\n\t\t\tfloat sample_now = (utils_tab_sin_32_1[motor->m_hfi.ind * motor->m_hfi.table_fact] * state_m->i_alpha -\n\t\t\t\t\tutils_tab_cos_32_1[motor->m_hfi.ind * motor->m_hfi.table_fact] * state_m->i_beta);\n\t\t\tfloat current_sample = sample_now - motor->m_hfi.prev_sample;\n\n\t\t\tmotor->m_hfi.buffer_current[motor->m_hfi.ind] = current_sample;\n\n\t\t\tif (current_sample > 0.01) {\n\t\t\t\tmotor->m_hfi.buffer[motor->m_hfi.ind] = ((hfi_voltage / 2.0 - conf_now->foc_motor_r *\n\t\t\t\t\t\tcurrent_sample) / (conf_now->foc_f_sw * current_sample));\n\t\t\t}\n\n\t\t\tmotor->m_hfi.ind++;\n\t\t\tif (motor->m_hfi.ind == motor->m_hfi.samples) {\n\t\t\t\tmotor->m_hfi.ind = 0;\n\t\t\t\tmotor->m_hfi.ready = true;\n\t\t\t}\n\n\t\t\tmod_alpha_tmp += hfi_voltage * utils_tab_sin_32_1[motor->m_hfi.ind * motor->m_hfi.table_fact] / ((2.0 / 3.0) * state_m->v_bus);\n\t\t\tmod_beta_tmp -= hfi_voltage * utils_tab_cos_32_1[motor->m_hfi.ind * motor->m_hfi.table_fact] / ((2.0 / 3.0) * state_m->v_bus);\n\t\t} else {\n\t\t\tmotor->m_hfi.prev_sample = utils_tab_sin_32_1[motor->m_hfi.ind * motor->m_hfi.table_fact] * state_m->i_alpha -\n\t\t\t\t\tutils_tab_cos_32_1[motor->m_hfi.ind * motor->m_hfi.table_fact] * state_m->i_beta;\n\n\t\t\tmod_alpha_tmp -= hfi_voltage * utils_tab_sin_32_1[motor->m_hfi.ind * motor->m_hfi.table_fact] / ((2.0 / 3.0) * state_m->v_bus);\n\t\t\tmod_beta_tmp += hfi_voltage * utils_tab_cos_32_1[motor->m_hfi.ind * motor->m_hfi.table_fact] / ((2.0 / 3.0) * state_m->v_bus);\n\t\t}\n\n\t\tutils_saturate_vector_2d(&mod_alpha_tmp, &mod_beta_tmp, SQRT3_BY_2 * 0.95);\n\t\tmotor->m_hfi.is_samp_n = !motor->m_hfi.is_samp_n;\n\n\t\tif (conf_now->foc_sample_v0_v7) {\n\t\t\tmod_alpha = mod_alpha_tmp;\n\t\t\tmod_beta = mod_beta_tmp;\n\t\t} else {\n\t\t\t// Delay adding the HFI voltage when not sampling in both 0 vectors, as it will cancel\n\t\t\t// itself with the opposite pulse from the previous HFI sample. This makes more sense\n\t\t\t// when drawing the SVM waveform.\n\t\t\tsvm(-mod_alpha_tmp, -mod_beta_tmp, TIM1->ARR,\n\t\t\t\t(uint32_t*)&motor->m_duty1_next,\n\t\t\t\t(uint32_t*)&motor->m_duty2_next,\n\t\t\t\t(uint32_t*)&motor->m_duty3_next,\n\t\t\t\t(uint32_t*)&state_m->svm_sector);\n\t\t\tmotor->m_duty_next_set = true;\n\t\t}\n\t} else {\n\t\tCURRENT_FILTER_ON();\n\t\tmotor->m_hfi.ind = 0;\n\t\tmotor->m_hfi.ready = false;\n\t\tmotor->m_hfi.is_samp_n = false;\n\t\tmotor->m_hfi.prev_sample = 0.0;\n\t}\n\n\t// Set output (HW Dependent)\n\tuint32_t duty1, duty2, duty3, top;\n\ttop = TIM1->ARR;\n\tsvm(-mod_alpha, -mod_beta, top, &duty1, &duty2, &duty3, (uint32_t*)&state_m->svm_sector);\n\n\tif (motor == &m_motor_1) {\n\t\tTIMER_UPDATE_DUTY_M1(duty1, duty2, duty3);\n#ifdef HW_HAS_DUAL_PARALLEL\n\t\tTIMER_UPDATE_DUTY_M2(duty1, duty2, duty3);\n#endif\n\t} else {\n#ifndef HW_HAS_DUAL_PARALLEL\n\t\tTIMER_UPDATE_DUTY_M2(duty1, duty2, duty3);\n#endif\n\t}\n\n\t// do not allow to turn on PWM outputs if virtual motor is used\n\tif(virtual_motor_is_connected() == false) {\n\t\tif (!motor->m_output_on) {\n\t\t\tstart_pwm_hw(motor);\n\t\t}\n\t}\n}\n\n// Magnitude must not be larger than sqrt(3)/2, or 0.866\nstatic void svm(float alpha, float beta, uint32_t PWMHalfPeriod,\n\t\t\t\tuint32_t* tAout, uint32_t* tBout, uint32_t* tCout, uint32_t *svm_sector) {\n\tuint32_t sector;\n\n\tif (beta >= 0.0f) {\n\t\tif (alpha >= 0.0f) {\n\t\t\t//quadrant I\n\t\t\tif (ONE_BY_SQRT3 * beta > alpha) {\n\t\t\t\tsector = 2;\n\t\t\t} else {\n\t\t\t\tsector = 1;\n\t\t\t}\n\t\t} else {\n\t\t\t//quadrant II\n\t\t\tif (-ONE_BY_SQRT3 * beta > alpha) {\n\t\t\t\tsector = 3;\n\t\t\t} else {\n\t\t\t\tsector = 2;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (alpha >= 0.0f) {\n\t\t\t//quadrant IV5\n\t\t\tif (-ONE_BY_SQRT3 * beta > alpha) {\n\t\t\t\tsector = 5;\n\t\t\t} else {\n\t\t\t\tsector = 6;\n\t\t\t}\n\t\t} else {\n\t\t\t//quadrant III\n\t\t\tif (ONE_BY_SQRT3 * beta > alpha) {\n\t\t\t\tsector = 4;\n\t\t\t} else {\n\t\t\t\tsector = 5;\n\t\t\t}\n\t\t}\n\t}\n\n\t// PWM timings\n\tuint32_t tA, tB, tC;\n\n\tswitch (sector) {\n\n\t// sector 1-2\n\tcase 1: {\n\t\t// Vector on-times\n\t\tuint32_t t1 = (alpha - ONE_BY_SQRT3 * beta) * PWMHalfPeriod;\n\t\tuint32_t t2 = (TWO_BY_SQRT3 * beta) * PWMHalfPeriod;\n\n\t\t// PWM timings\n\t\ttA = (PWMHalfPeriod - t1 - t2) / 2;\n\t\ttB = tA + t1;\n\t\ttC = tB + t2;\n\n\t\tbreak;\n\t}\n\n\t// sector 2-3\n\tcase 2: {\n\t\t// Vector on-times\n\t\tuint32_t t2 = (alpha + ONE_BY_SQRT3 * beta) * PWMHalfPeriod;\n\t\tuint32_t t3 = (-alpha + ONE_BY_SQRT3 * beta) * PWMHalfPeriod;\n\n\t\t// PWM timings\n\t\ttB = (PWMHalfPeriod - t2 - t3) / 2;\n\t\ttA = tB + t3;\n\t\ttC = tA + t2;\n\n\t\tbreak;\n\t}\n\n\t// sector 3-4\n\tcase 3: {\n\t\t// Vector on-times\n\t\tuint32_t t3 = (TWO_BY_SQRT3 * beta) * PWMHalfPeriod;\n\t\tuint32_t t4 = (-alpha - ONE_BY_SQRT3 * beta) * PWMHalfPeriod;\n\n\t\t// PWM timings\n\t\ttB = (PWMHalfPeriod - t3 - t4) / 2;\n\t\ttC = tB + t3;\n\t\ttA = tC + t4;\n\n\t\tbreak;\n\t}\n\n\t// sector 4-5\n\tcase 4: {\n\t\t// Vector on-times\n\t\tuint32_t t4 = (-alpha + ONE_BY_SQRT3 * beta) * PWMHalfPeriod;\n\t\tuint32_t t5 = (-TWO_BY_SQRT3 * beta) * PWMHalfPeriod;\n\n\t\t// PWM timings\n\t\ttC = (PWMHalfPeriod - t4 - t5) / 2;\n\t\ttB = tC + t5;\n\t\ttA = tB + t4;\n\n\t\tbreak;\n\t}\n\n\t// sector 5-6\n\tcase 5: {\n\t\t// Vector on-times\n\t\tuint32_t t5 = (-alpha - ONE_BY_SQRT3 * beta) * PWMHalfPeriod;\n\t\tuint32_t t6 = (alpha - ONE_BY_SQRT3 * beta) * PWMHalfPeriod;\n\n\t\t// PWM timings\n\t\ttC = (PWMHalfPeriod - t5 - t6) / 2;\n\t\ttA = tC + t5;\n\t\ttB = tA + t6;\n\n\t\tbreak;\n\t}\n\n\t// sector 6-1\n\tcase 6: {\n\t\t// Vector on-times\n\t\tuint32_t t6 = (-TWO_BY_SQRT3 * beta) * PWMHalfPeriod;\n\t\tuint32_t t1 = (alpha + ONE_BY_SQRT3 * beta) * PWMHalfPeriod;\n\n\t\t// PWM timings\n\t\ttA = (PWMHalfPeriod - t6 - t1) / 2;\n\t\ttC = tA + t1;\n\t\ttB = tC + t6;\n\n\t\tbreak;\n\t}\n\t}\n\n\t*tAout = tA;\n\t*tBout = tB;\n\t*tCout = tC;\n\t*svm_sector = sector;\n}\n\nstatic void run_pid_control_pos(float angle_now, float angle_set, float dt, volatile motor_all_state_t *motor) {\n\tvolatile mc_configuration *conf_now = motor->m_conf;\n\tfloat p_term;\n\tfloat d_term;\n\n\t// PID is off. Return.\n\tif (motor->m_control_mode != CONTROL_MODE_POS) {\n\t\tmotor->m_pos_i_term = 0;\n\t\tmotor->m_pos_prev_error = 0;\n\t\treturn;\n\t}\n\n\t// Compute parameters\n\tfloat error = utils_angle_difference(angle_set, angle_now);\n\n\tif (encoder_is_configured()) {\n\t\tif (conf_now->foc_encoder_inverted) {\n\t\t\terror = -error;\n\t\t}\n\t}\n\n\tp_term = error * conf_now->p_pid_kp;\n\tmotor->m_pos_i_term += error * (conf_now->p_pid_ki * dt);\n\n\t// Average DT for the D term when the error does not change. This likely\n\t// happens at low speed when the position resolution is low and several\n\t// control iterations run without position updates.\n\t// TODO: Are there problems with this approach?\n\tmotor->m_pos_dt_int += dt;\n\tif (error == motor->m_pos_prev_error) {\n\t\td_term = 0.0;\n\t} else {\n\t\td_term = (error - motor->m_pos_prev_error) * (conf_now->p_pid_kd / motor->m_pos_dt_int);\n\t\tmotor->m_pos_dt_int = 0.0;\n\t}\n\n\t// Filter D\n\tUTILS_LP_FAST(motor->m_pos_d_filter, d_term, conf_now->p_pid_kd_filter);\n\td_term = motor->m_pos_d_filter;\n\n\n\t// I-term wind-up protection\n\tfloat p_tmp = p_term;\n\tutils_truncate_number_abs(&p_tmp, 1.0);\n\tutils_truncate_number_abs((float*)&motor->m_pos_i_term, 1.0 - fabsf(p_tmp));\n\n\t// Store previous error\n\tmotor->m_pos_prev_error = error;\n\n\t// Calculate output\n\tfloat output = p_term + motor->m_pos_i_term + d_term;\n\tutils_truncate_number(&output, -1.0, 1.0);\n\n\tif (encoder_is_configured()) {\n\t\tif (encoder_index_found()) {\n\t\t\tmotor->m_iq_set = output * conf_now->lo_current_max;\n\t\t} else {\n\t\t\t// Rotate the motor with 40 % power until the encoder index is found.\n\t\t\tmotor->m_iq_set = 0.4 * conf_now->lo_current_max;\n\t\t}\n\t} else {\n\t\tmotor->m_iq_set = output * conf_now->lo_current_max;\n\t}\n}\n\nstatic void run_pid_control_speed(float dt, volatile motor_all_state_t *motor) {\n\tvolatile mc_configuration *conf_now = motor->m_conf;\n\tfloat p_term;\n\tfloat d_term;\n\n\t// PID is off. Return.\n\tif (motor->m_control_mode != CONTROL_MODE_SPEED) {\n\t\tmotor->m_speed_i_term = 0.0;\n\t\tmotor->m_speed_prev_error = 0.0;\n\t\treturn;\n\t}\n\n\tconst float rpm = mcpwm_foc_get_rpm();\n\tfloat error = motor->m_speed_pid_set_rpm - rpm;\n\n\t// Too low RPM set. Reset state and return.\n\tif (fabsf(motor->m_speed_pid_set_rpm) < conf_now->s_pid_min_erpm) {\n\t\tmotor->m_speed_i_term = 0.0;\n\t\tmotor->m_speed_prev_error = error;\n\t\treturn;\n\t}\n\n\t// Compute parameters\n\tp_term = error * conf_now->s_pid_kp * (1.0 / 20.0);\n\tmotor->m_speed_i_term += error * (conf_now->s_pid_ki * dt) * (1.0 / 20.0);\n\td_term = (error - motor->m_speed_prev_error) * (conf_now->s_pid_kd / dt) * (1.0 / 20.0);\n\n\t// Filter D\n\tUTILS_LP_FAST(motor->m_speed_d_filter, d_term, conf_now->s_pid_kd_filter);\n\td_term = motor->m_speed_d_filter;\n\n\t// I-term wind-up protection\n\tutils_truncate_number((float*)&motor->m_speed_i_term, -1.0, 1.0);\n\n\t// Store previous error\n\tmotor->m_speed_prev_error = error;\n\n\t// Calculate output\n\tfloat output = p_term + motor->m_speed_i_term + d_term;\n\tutils_truncate_number(&output, -1.0, 1.0);\n\n\t// Optionally disable braking\n\tif (!conf_now->s_pid_allow_braking) {\n\t\tif (rpm > 20.0 && output < 0.0) {\n\t\t\toutput = 0.0;\n\t\t}\n\n\t\tif (rpm < -20.0 && output > 0.0) {\n\t\t\toutput = 0.0;\n\t\t}\n\t}\n\n\tmotor->m_iq_set = output * conf_now->lo_current_max;\n}\n\nstatic void stop_pwm_hw(volatile motor_all_state_t *motor) {\n\tmotor->m_id_set = 0.0;\n\tmotor->m_iq_set = 0.0;\n\n\tif (motor == &m_motor_1) {\n\t\tTIM_SelectOCxM(TIM1, TIM_Channel_1, TIM_ForcedAction_InActive);\n\t\tTIM_CCxCmd(TIM1, TIM_Channel_1, TIM_CCx_Enable);\n\t\tTIM_CCxNCmd(TIM1, TIM_Channel_1, TIM_CCxN_Disable);\n\n\t\tTIM_SelectOCxM(TIM1, TIM_Channel_2, TIM_ForcedAction_InActive);\n\t\tTIM_CCxCmd(TIM1, TIM_Channel_2, TIM_CCx_Enable);\n\t\tTIM_CCxNCmd(TIM1, TIM_Channel_2, TIM_CCxN_Disable);\n\n\t\tTIM_SelectOCxM(TIM1, TIM_Channel_3, TIM_ForcedAction_InActive);\n\t\tTIM_CCxCmd(TIM1, TIM_Channel_3, TIM_CCx_Enable);\n\t\tTIM_CCxNCmd(TIM1, TIM_Channel_3, TIM_CCxN_Disable);\n\n\t\tTIM_GenerateEvent(TIM1, TIM_EventSource_COM);\n\n#ifdef HW_HAS_DUAL_PARALLEL\n\t\tTIM_SelectOCxM(TIM8, TIM_Channel_1, TIM_ForcedAction_InActive);\n\t\tTIM_CCxCmd(TIM8, TIM_Channel_1, TIM_CCx_Enable);\n\t\tTIM_CCxNCmd(TIM8, TIM_Channel_1, TIM_CCxN_Disable);\n\n\t\tTIM_SelectOCxM(TIM8, TIM_Channel_2, TIM_ForcedAction_InActive);\n\t\tTIM_CCxCmd(TIM8, TIM_Channel_2, TIM_CCx_Enable);\n\t\tTIM_CCxNCmd(TIM8, TIM_Channel_2, TIM_CCxN_Disable);\n\n\t\tTIM_SelectOCxM(TIM8, TIM_Channel_3, TIM_ForcedAction_InActive);\n\t\tTIM_CCxCmd(TIM8, TIM_Channel_3, TIM_CCx_Enable);\n\t\tTIM_CCxNCmd(TIM8, TIM_Channel_3, TIM_CCxN_Disable);\n\n\t\tTIM_GenerateEvent(TIM8, TIM_EventSource_COM);\n#endif\n\n#ifdef HW_HAS_DRV8313\n\t\tDISABLE_BR();\n#endif\n\n\t\tmotor->m_output_on = false;\n\t} else {\n\t\tTIM_SelectOCxM(TIM8, TIM_Channel_1, TIM_ForcedAction_InActive);\n\t\tTIM_CCxCmd(TIM8, TIM_Channel_1, TIM_CCx_Enable);\n\t\tTIM_CCxNCmd(TIM8, TIM_Channel_1, TIM_CCxN_Disable);\n\n\t\tTIM_SelectOCxM(TIM8, TIM_Channel_2, TIM_ForcedAction_InActive);\n\t\tTIM_CCxCmd(TIM8, TIM_Channel_2, TIM_CCx_Enable);\n\t\tTIM_CCxNCmd(TIM8, TIM_Channel_2, TIM_CCxN_Disable);\n\n\t\tTIM_SelectOCxM(TIM8, TIM_Channel_3, TIM_ForcedAction_InActive);\n\t\tTIM_CCxCmd(TIM8, TIM_Channel_3, TIM_CCx_Enable);\n\t\tTIM_CCxNCmd(TIM8, TIM_Channel_3, TIM_CCxN_Disable);\n\n\t\tTIM_GenerateEvent(TIM8, TIM_EventSource_COM);\n\n#ifdef HW_HAS_DRV8313_2\n\t\tDISABLE_BR_2();\n#endif\n\n\t\tmotor->m_output_on = false;\n\t}\n}\n\nstatic void start_pwm_hw(volatile motor_all_state_t *motor) {\n\tif (motor == &m_motor_1) {\n\t\tTIM_SelectOCxM(TIM1, TIM_Channel_1, TIM_OCMode_PWM1);\n\t\tTIM_CCxCmd(TIM1, TIM_Channel_1, TIM_CCx_Enable);\n\t\tTIM_CCxNCmd(TIM1, TIM_Channel_1, TIM_CCxN_Enable);\n\n\t\tTIM_SelectOCxM(TIM1, TIM_Channel_2, TIM_OCMode_PWM1);\n\t\tTIM_CCxCmd(TIM1, TIM_Channel_2, TIM_CCx_Enable);\n\t\tTIM_CCxNCmd(TIM1, TIM_Channel_2, TIM_CCxN_Enable);\n\n\t\tTIM_SelectOCxM(TIM1, TIM_Channel_3, TIM_OCMode_PWM1);\n\t\tTIM_CCxCmd(TIM1, TIM_Channel_3, TIM_CCx_Enable);\n\t\tTIM_CCxNCmd(TIM1, TIM_Channel_3, TIM_CCxN_Enable);\n\n#ifdef HW_HAS_DUAL_PARALLEL\n\t\tTIM_SelectOCxM(TIM8, TIM_Channel_1, TIM_OCMode_PWM1);\n\t\tTIM_CCxCmd(TIM8, TIM_Channel_1, TIM_CCx_Enable);\n\t\tTIM_CCxNCmd(TIM8, TIM_Channel_1, TIM_CCxN_Enable);\n\n\t\tTIM_SelectOCxM(TIM8, TIM_Channel_2, TIM_OCMode_PWM1);\n\t\tTIM_CCxCmd(TIM8, TIM_Channel_2, TIM_CCx_Enable);\n\t\tTIM_CCxNCmd(TIM8, TIM_Channel_2, TIM_CCxN_Enable);\n\n\t\tTIM_SelectOCxM(TIM8, TIM_Channel_3, TIM_OCMode_PWM1);\n\t\tTIM_CCxCmd(TIM8, TIM_Channel_3, TIM_CCx_Enable);\n\t\tTIM_CCxNCmd(TIM8, TIM_Channel_3, TIM_CCxN_Enable);\n#endif\n\n\t\t// Generate COM event in ADC interrupt to get better synchronization\n\t\t//\tTIM_GenerateEvent(TIM1, TIM_EventSource_COM);\n\n#ifdef HW_HAS_DRV8313\n\t\tENABLE_BR();\n#endif\n\t\tmotor->m_output_on = true;\n\t} else {\n\t\tTIM_SelectOCxM(TIM8, TIM_Channel_1, TIM_OCMode_PWM1);\n\t\tTIM_CCxCmd(TIM8, TIM_Channel_1, TIM_CCx_Enable);\n\t\tTIM_CCxNCmd(TIM8, TIM_Channel_1, TIM_CCxN_Enable);\n\n\t\tTIM_SelectOCxM(TIM8, TIM_Channel_2, TIM_OCMode_PWM1);\n\t\tTIM_CCxCmd(TIM8, TIM_Channel_2, TIM_CCx_Enable);\n\t\tTIM_CCxNCmd(TIM8, TIM_Channel_2, TIM_CCxN_Enable);\n\n\t\tTIM_SelectOCxM(TIM8, TIM_Channel_3, TIM_OCMode_PWM1);\n\t\tTIM_CCxCmd(TIM8, TIM_Channel_3, TIM_CCx_Enable);\n\t\tTIM_CCxNCmd(TIM8, TIM_Channel_3, TIM_CCxN_Enable);\n\n#ifdef HW_HAS_DRV8313_2\n\t\tENABLE_BR_2();\n#endif\n\t\tmotor->m_output_on = true;\n\t}\n}\n\nstatic float correct_encoder(float obs_angle, float enc_angle, float speed,\n\t\t\t\t\t\t\t float sl_erpm, volatile motor_all_state_t *motor) {\n\tfloat rpm_abs = fabsf(speed / ((2.0 * M_PI) / 60.0));\n\n\t// Hysteresis 5 % of total speed\n\tfloat hyst = sl_erpm * 0.05;\n\tif (motor->m_using_encoder) {\n\t\tif (rpm_abs > (sl_erpm + hyst)) {\n\t\t\tmotor->m_using_encoder = false;\n\t\t}\n\t} else {\n\t\tif (rpm_abs < (sl_erpm- hyst)) {\n\t\t\tmotor->m_using_encoder = true;\n\t\t}\n\t}\n\n\treturn motor->m_using_encoder ? enc_angle : obs_angle;\n}\n\nstatic float correct_hall(float angle, float dt, volatile motor_all_state_t *motor) {\n\tvolatile mc_configuration *conf_now = motor->m_conf;\n\tmotor->m_hall_dt_diff_now += dt;\n\n\tfloat rad_per_sec = (M_PI / 3.0) / motor->m_hall_dt_diff_last;\n\tfloat rpm_abs_fast = fabsf(motor->m_speed_est_fast / ((2.0 * M_PI) / 60.0));\n\tfloat rpm_abs_hall = fabsf(rad_per_sec / ((2.0 * M_PI) / 60.0));\n\n\t// Hysteresis 5 % of total speed\n\tfloat hyst = conf_now->foc_sl_erpm * 0.1;\n\tif (motor->m_using_hall) {\n\t\tif (fminf(rpm_abs_fast, rpm_abs_hall) > (conf_now->foc_sl_erpm + hyst)) {\n\t\t\tmotor->m_using_hall = false;\n\t\t}\n\t} else {\n\t\tif (rpm_abs_fast < (conf_now->foc_sl_erpm - hyst)) {\n\t\t\tmotor->m_using_hall = true;\n\t\t}\n\t}\n\n\tint ang_hall_int = conf_now->foc_hall_table[utils_read_hall(motor != &m_motor_1)];\n\n\t// Only override the observer if the hall sensor value is valid.\n\tif (ang_hall_int < 201) {\n\t\tfloat ang_hall_now = (((float)ang_hall_int / 200.0) * 360.0) * M_PI / 180.0;\n\n\t\tif (motor->m_ang_hall_int_prev < 0) {\n\t\t\t// Previous angle not valid\n\t\t\tmotor->m_ang_hall_int_prev = ang_hall_int;\n\t\t\tmotor->m_ang_hall = ang_hall_now;\n\t\t} else if (ang_hall_int != motor->m_ang_hall_int_prev) {\n\t\t\tint diff = ang_hall_int - motor->m_ang_hall_int_prev;\n\t\t\tif (diff > 100) {\n\t\t\t\tdiff -= 200;\n\t\t\t} else if (diff < -100) {\n\t\t\t\tdiff += 200;\n\t\t\t}\n\n\t\t\t// This is only valid if the direction did not just change. If it did, we use the\n\t\t\t// last speed together with the sign right now.\n\t\t\tif (SIGN(diff) == SIGN(motor->m_hall_dt_diff_last)) {\n\t\t\t\tif (diff > 0) {\n\t\t\t\t\tmotor->m_hall_dt_diff_last = motor->m_hall_dt_diff_now;\n\t\t\t\t} else {\n\t\t\t\t\tmotor->m_hall_dt_diff_last = -motor->m_hall_dt_diff_now;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmotor->m_hall_dt_diff_last = -motor->m_hall_dt_diff_last;\n\t\t\t}\n\n\t\t\tmotor->m_hall_dt_diff_now = 0.0;\n\n\t\t\t// A transition was just made. The angle is in the middle of the new and old angle.\n\t\t\tint ang_avg = motor->m_ang_hall_int_prev + diff / 2;\n\t\t\tang_avg %= 200;\n\t\t\tmotor->m_ang_hall = (((float)ang_avg / 200.0) * 360.0) * M_PI / 180.0;\n\t\t}\n\n\t\tmotor->m_ang_hall_int_prev = ang_hall_int;\n\n\t\tif (((60.0 / (2.0 * M_PI)) * ((M_PI / 3.0) / motor->m_hall_dt_diff_now)) < 100) {\n\t\t\t// Don't interpolate on very low speed, just use the closest hall sensor. The reason is that we might\n\t\t\t// get stuck at 60 degrees off if a direction change happens between two steps.\n\t\t\tmotor->m_ang_hall = ang_hall_now;\n\t\t} else {\n\t\t\t// Interpolate\n\t\t\tfloat diff = utils_angle_difference_rad(motor->m_ang_hall, ang_hall_now);\n\t\t\tif (fabsf(diff) < ((2.0 * M_PI) / 12.0)) {\n\t\t\t\t// Do interpolation\n\t\t\t\tmotor->m_ang_hall += rad_per_sec * dt;\n\t\t\t} else {\n\t\t\t\t// We are too far away with the interpolation\n\t\t\t\tmotor->m_ang_hall -= diff / 100.0;\n\t\t\t}\n\t\t}\n\n\t\tutils_norm_angle_rad((float*)&motor->m_ang_hall);\n\t\tif (motor->m_using_hall) {\n\t\t\tangle = motor->m_ang_hall;\n\t\t}\n\t} else {\n\t\t// Invalid hall reading. Don't update angle.\n\t\tmotor->m_ang_hall_int_prev = -1;\n\n\t\t// Also allow open loop in order to behave like normal sensorless\n\t\t// operation. Then the motor works even if the hall sensor cable\n\t\t// gets disconnected (when the sensor spacing is 120 degrees).\n\t\tif (motor->m_phase_observer_override && motor->m_state == MC_STATE_RUNNING) {\n\t\t\tangle = motor->m_phase_now_observer_override;\n\t\t}\n\t}\n\n\treturn angle;\n}\n\nstatic void terminal_plot_hfi(int argc, const char **argv) {\n\tif (argc == 2) {\n\t\tint d = -1;\n\t\tsscanf(argv[1], \"%d\", &d);\n\n\t\tif (d == 0 || d == 1 || d == 2) {\n\t\t\tmotor_now()->m_hfi_plot_en = d;\n\t\t\tif (motor_now()->m_hfi_plot_en == 1) {\n\t\t\t\tmotor_now()->m_hfi_plot_sample = 0.0;\n\t\t\t\tcommands_init_plot(\"Sample\", \"Value\");\n\t\t\t\tcommands_plot_add_graph(\"Phase\");\n\t\t\t\tcommands_plot_add_graph(\"Phase bin2\");\n\t\t\t\tcommands_plot_add_graph(\"Ld - Lq (uH\");\n\t\t\t\tcommands_plot_add_graph(\"L Diff Sat (uH)\");\n\t\t\t\tcommands_plot_add_graph(\"L Avg (uH)\");\n\t\t\t} else if (motor_now()->m_hfi_plot_en == 2) {\n\t\t\t\tmotor_now()->m_hfi_plot_sample = 0.0;\n\t\t\t\tcommands_init_plot(\"Sample Index\", \"Value\");\n\t\t\t\tcommands_plot_add_graph(\"Current (A)\");\n\t\t\t\tcommands_plot_add_graph(\"Inductance (uH)\");\n\t\t\t}\n\n\t\t\tcommands_printf(motor_now()->m_hfi_plot_en ?\n\t\t\t\t\t\"HFI plot enabled\" :\n\t\t\t\t\t\"HFI plot disabled\");\n\t\t} else {\n\t\t\tcommands_printf(\"Invalid Argument. en has to be 0, 1 or 2.\\n\");\n\t\t}\n\t} else {\n\t\tcommands_printf(\"This command requires one argument.\\n\");\n\t}\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/mcpwm_foc.c b/mcpwm_foc.c
--- a/mcpwm_foc.c	
+++ b/mcpwm_foc.c	
@@ -42,7 +42,8 @@
 #include "digital_filter.h"
 
 // Private types
-typedef struct {
+typedef struct
+{
 	float id_target;
 	float iq_target;
 	float max_duty;
@@ -68,19 +69,21 @@
 	float vq_int;
 	float speed_rad_s;
 	uint32_t svm_sector;
-} motor_state_t;
+}motor_state_t;
 
-typedef struct {
+typedef struct
+{
 	int sample_num;
 	float avg_current_tot;
 	float avg_voltage_tot;
-} mc_sample_t;
+}mc_sample_t;
 
-typedef struct {
-	void(*fft_bin0_func)(float*, float*, float*);
-	void(*fft_bin1_func)(float*, float*, float*);
-	void(*fft_bin2_func)(float*, float*, float*);
-
+typedef struct
+{
+	void (* fft_bin0_func)(float*, float*, float*);
+	void (* fft_bin1_func)(float*, float*, float*);
+	void (* fft_bin2_func)(float*, float*, float*);
+	
 	int samples;
 	int table_fact;
 	float buffer[32];
@@ -93,10 +96,11 @@
 	int est_done_cnt;
 	float observer_zero_time;
 	int flip_cnt;
-} hfi_state_t;
+}hfi_state_t;
 
-typedef struct {
-	volatile mc_configuration *m_conf;
+typedef struct
+{
+	volatile mc_configuration* m_conf;
 	mc_state m_state;
 	mc_control_mode m_control_mode;
 	motor_state_t m_motor_state;
@@ -136,7 +140,7 @@
 	hfi_state_t m_hfi;
 	int m_hfi_plot_en;
 	float m_hfi_plot_sample;
-
+	
 	float m_phase_before;
 	float m_duty_filtered;
 	bool m_was_full_brake;
@@ -163,7 +167,7 @@
 	float m_ang_hall;
 	float m_hall_dt_diff_last;
 	float m_hall_dt_diff_now;
-} motor_all_state_t;
+}motor_all_state_t;
 
 // Private variables
 static volatile bool m_dccal_done = false;
@@ -177,22 +181,34 @@
 
 // Private functions
 static void do_dc_cal(void);
-void observer_update(float v_alpha, float v_beta, float i_alpha, float i_beta,
-					 float dt, volatile float *x1, volatile float *x2, volatile float *phase, volatile motor_all_state_t *motor);
-static void pll_run(float phase, float dt, volatile float *phase_var,
-					volatile float *speed_var, volatile mc_configuration *conf);
-static void control_current(volatile motor_all_state_t *motor, float dt);
-static void svm(float alpha, float beta, uint32_t PWMHalfPeriod,
-				uint32_t* tAout, uint32_t* tBout, uint32_t* tCout, uint32_t *svm_sector);
-static void run_pid_control_pos(float angle_now, float angle_set, float dt, volatile motor_all_state_t *motor);
-static void run_pid_control_speed(float dt, volatile motor_all_state_t *motor);
-static void stop_pwm_hw(volatile motor_all_state_t *motor);
-static void start_pwm_hw(volatile motor_all_state_t *motor);
-static float correct_encoder(float obs_angle, float enc_angle, float speed, float sl_erpm, volatile motor_all_state_t *motor);
-static float correct_hall(float angle, float dt, volatile motor_all_state_t *motor);
-static void terminal_plot_hfi(int argc, const char **argv);
-static void timer_update(volatile motor_all_state_t *motor, float dt);
-static void hfi_update(volatile motor_all_state_t *motor);
+void observer_update(
+	float v_alpha, float v_beta, float i_alpha, float i_beta,
+	float dt, volatile float* x1, volatile float* x2, volatile float* phase, volatile motor_all_state_t* motor
+);
+static void pll_run(
+	float phase, float dt, volatile float* phase_var,
+	volatile float* speed_var, volatile mc_configuration* conf
+);
+static void control_current(volatile motor_all_state_t* motor, float dt);
+static void svm(
+	float alpha, float beta, uint32_t PWMHalfPeriod,
+	uint32_t* tAout, uint32_t* tBout, uint32_t* tCout, uint32_t* svm_sector
+);
+static void run_pid_control_pos(float angle_now, float angle_set, float dt, volatile motor_all_state_t* motor);
+static void run_pid_control_speed(float dt, volatile motor_all_state_t* motor);
+static void stop_pwm_hw(volatile motor_all_state_t* motor);
+static void start_pwm_hw(volatile motor_all_state_t* motor);
+static float correct_encoder(
+	float obs_angle,
+	float enc_angle,
+	float speed,
+	float sl_erpm,
+	volatile motor_all_state_t* motor
+);
+static float correct_hall(float angle, float dt, volatile motor_all_state_t* motor);
+static void terminal_plot_hfi(int argc, const char** argv);
+static void timer_update(volatile motor_all_state_t* motor, float dt);
+static void hfi_update(volatile motor_all_state_t* motor);
 
 // Threads
 static THD_WORKING_AREA(timer_thread_wa, 1024);
@@ -206,18 +222,18 @@
 // Macros
 #ifdef HW_HAS_3_SHUNTS
 #define TIMER_UPDATE_DUTY_M1(duty1, duty2, duty3) \
-		TIM1->CR1 |= TIM_CR1_UDIS; \
-		TIM1->CCR1 = duty1; \
-		TIM1->CCR2 = duty2; \
-		TIM1->CCR3 = duty3; \
-		TIM1->CR1 &= ~TIM_CR1_UDIS;
+        TIM1->CR1 |= TIM_CR1_UDIS; \
+        TIM1->CCR1 = duty1; \
+        TIM1->CCR2 = duty2; \
+        TIM1->CCR3 = duty3; \
+        TIM1->CR1 &= ~TIM_CR1_UDIS;
 
 #define TIMER_UPDATE_DUTY_M2(duty1, duty2, duty3) \
-		TIM8->CR1 |= TIM_CR1_UDIS; \
-		TIM8->CCR1 = duty1; \
-		TIM8->CCR2 = duty2; \
-		TIM8->CCR3 = duty3; \
-		TIM8->CR1 &= ~TIM_CR1_UDIS;
+        TIM8->CR1 |= TIM_CR1_UDIS; \
+        TIM8->CCR1 = duty1; \
+        TIM8->CCR2 = duty2; \
+        TIM8->CCR3 = duty3; \
+        TIM8->CR1 &= ~TIM_CR1_UDIS;
 #else
 #define TIMER_UPDATE_DUTY_M1(duty1, duty2, duty3) \
 		TIM1->CR1 |= TIM_CR1_UDIS; \
@@ -234,42 +250,42 @@
 #endif
 
 #define TIMER_UPDATE_SAMP(samp) \
-		TIM2->CCR2 = (samp / 2);
+        TIM2->CCR2 = (samp / 2);
 
 #define TIMER_UPDATE_SAMP_TOP_M1(samp, top) \
-		TIM1->CR1 |= TIM_CR1_UDIS; \
-		TIM2->CR1 |= TIM_CR1_UDIS; \
-		TIM1->ARR = top; \
-		TIM2->CCR2 = samp / 2; \
-		TIM1->CR1 &= ~TIM_CR1_UDIS; \
-		TIM2->CR1 &= ~TIM_CR1_UDIS;
+        TIM1->CR1 |= TIM_CR1_UDIS; \
+        TIM2->CR1 |= TIM_CR1_UDIS; \
+        TIM1->ARR = top; \
+        TIM2->CCR2 = samp / 2; \
+        TIM1->CR1 &= ~TIM_CR1_UDIS; \
+        TIM2->CR1 &= ~TIM_CR1_UDIS;
 #define TIMER_UPDATE_SAMP_TOP_M2(samp, top) \
-		TIM8->CR1 |= TIM_CR1_UDIS; \
-		TIM2->CR1 |= TIM_CR1_UDIS; \
-		TIM8->ARR = top; \
-		TIM2->CCR2 = samp / 2; \
-		TIM8->CR1 &= ~TIM_CR1_UDIS; \
-		TIM2->CR1 &= ~TIM_CR1_UDIS;
+        TIM8->CR1 |= TIM_CR1_UDIS; \
+        TIM2->CR1 |= TIM_CR1_UDIS; \
+        TIM8->ARR = top; \
+        TIM2->CCR2 = samp / 2; \
+        TIM8->CR1 &= ~TIM_CR1_UDIS; \
+        TIM2->CR1 &= ~TIM_CR1_UDIS;
 
 #ifdef HW_HAS_3_SHUNTS
 #define TIMER_UPDATE_DUTY_SAMP_M1(duty1, duty2, duty3, samp) \
-		TIM1->CR1 |= TIM_CR1_UDIS; \
-		TIM2->CR1 |= TIM_CR1_UDIS; \
-		TIM1->CCR1 = duty1; \
-		TIM1->CCR2 = duty2; \
-		TIM1->CCR3 = duty3; \
-		TIM2->CCR2 = samp / 2; \
-		TIM1->CR1 &= ~TIM_CR1_UDIS; \
-		TIM2->CR1 &= ~TIM_CR1_UDIS;
+        TIM1->CR1 |= TIM_CR1_UDIS; \
+        TIM2->CR1 |= TIM_CR1_UDIS; \
+        TIM1->CCR1 = duty1; \
+        TIM1->CCR2 = duty2; \
+        TIM1->CCR3 = duty3; \
+        TIM2->CCR2 = samp / 2; \
+        TIM1->CR1 &= ~TIM_CR1_UDIS; \
+        TIM2->CR1 &= ~TIM_CR1_UDIS;
 #define TIMER_UPDATE_DUTY_SAMP_M2(duty1, duty2, duty3, samp) \
-		TIM8->CR1 |= TIM_CR1_UDIS; \
-		TIM2->CR1 |= TIM_CR1_UDIS; \
-		TIM8->CCR1 = duty1; \
-		TIM8->CCR2 = duty2; \
-		TIM8->CCR3 = duty3; \
-		TIM2->CCR2 = samp / 2; \
-		TIM8->CR1 &= ~TIM_CR1_UDIS; \
-		TIM2->CR1 &= ~TIM_CR1_UDIS;
+        TIM8->CR1 |= TIM_CR1_UDIS; \
+        TIM2->CR1 |= TIM_CR1_UDIS; \
+        TIM8->CCR1 = duty1; \
+        TIM8->CCR2 = duty2; \
+        TIM8->CCR3 = duty3; \
+        TIM2->CCR2 = samp / 2; \
+        TIM8->CR1 &= ~TIM_CR1_UDIS; \
+        TIM2->CR1 &= ~TIM_CR1_UDIS;
 #else
 #define TIMER_UPDATE_DUTY_SAMP_M1(duty1, duty2, duty3, samp) \
 		TIM1->CR1 |= TIM_CR1_UDIS; \
@@ -291,11 +307,13 @@
 		TIM2->CR1 &= ~TIM_CR1_UDIS;
 #endif
 
-static void update_hfi_samples(foc_hfi_samples samples, volatile motor_all_state_t *motor) {
+static void update_hfi_samples(foc_hfi_samples samples, volatile motor_all_state_t* motor)
+{
 	utils_sys_lock_cnt();
-
+	
 	memset((void*)&motor->m_hfi, 0, sizeof(motor->m_hfi));
-	switch (samples) {
+	switch (samples)
+	{
 	case HFI_SAMPLES_8:
 		motor->m_hfi.samples = 8;
 		motor->m_hfi.table_fact = 4;
@@ -303,7 +321,7 @@
 		motor->m_hfi.fft_bin1_func = utils_fft8_bin1;
 		motor->m_hfi.fft_bin2_func = utils_fft8_bin2;
 		break;
-
+	
 	case HFI_SAMPLES_16:
 		motor->m_hfi.samples = 16;
 		motor->m_hfi.table_fact = 2;
@@ -311,7 +329,7 @@
 		motor->m_hfi.fft_bin1_func = utils_fft16_bin1;
 		motor->m_hfi.fft_bin2_func = utils_fft16_bin2;
 		break;
-
+	
 	case HFI_SAMPLES_32:
 		motor->m_hfi.samples = 32;
 		motor->m_hfi.table_fact = 1;
@@ -320,38 +338,39 @@
 		motor->m_hfi.fft_bin2_func = utils_fft32_bin2;
 		break;
 	}
-
+	
 	utils_sys_unlock_cnt();
 }
 
-static void timer_reinit(int f_sw) {
+static void timer_reinit(int f_sw)
+{
 	utils_sys_lock_cnt();
-
+	
 	TIM_DeInit(TIM1);
 	TIM_DeInit(TIM8);
 	TIM_DeInit(TIM2);
-
+	
 	TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
 	TIM_OCInitTypeDef TIM_OCInitStructure;
 	TIM_BDTRInitTypeDef TIM_BDTRInitStructure;
-
+	
 	TIM1->CNT = 0;
 	TIM2->CNT = 0;
 	TIM8->CNT = 0;
-
+	
 	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);
 	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM8, ENABLE);
-
+	
 	// Time Base configuration
 	TIM_TimeBaseStructure.TIM_Prescaler = 0;
 	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_CenterAligned1;
 	TIM_TimeBaseStructure.TIM_Period = (SYSTEM_CORE_CLOCK / f_sw);
 	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
 	TIM_TimeBaseStructure.TIM_RepetitionCounter = 0;
-
+	
 	TIM_TimeBaseInit(TIM1, &TIM_TimeBaseStructure);
 	TIM_TimeBaseInit(TIM8, &TIM_TimeBaseStructure);
-
+	
 	// Channel 1, 2 and 3 Configuration in PWM mode
 	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
 	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
@@ -361,32 +380,32 @@
 	TIM_OCInitStructure.TIM_OCNPolarity = TIM_OCNPolarity_High;
 	TIM_OCInitStructure.TIM_OCIdleState = TIM_OCIdleState_Set;
 	TIM_OCInitStructure.TIM_OCNIdleState = TIM_OCNIdleState_Set;
-
+	
 	TIM_OC1Init(TIM1, &TIM_OCInitStructure);
 	TIM_OC2Init(TIM1, &TIM_OCInitStructure);
 	TIM_OC3Init(TIM1, &TIM_OCInitStructure);
 	TIM_OC4Init(TIM1, &TIM_OCInitStructure);
-
+	
 	TIM_OC1PreloadConfig(TIM1, TIM_OCPreload_Enable);
 	TIM_OC2PreloadConfig(TIM1, TIM_OCPreload_Enable);
 	TIM_OC3PreloadConfig(TIM1, TIM_OCPreload_Enable);
 	TIM_OC4PreloadConfig(TIM1, TIM_OCPreload_Enable);
-
+	
 	TIM_OC1Init(TIM8, &TIM_OCInitStructure);
 	TIM_OC2Init(TIM8, &TIM_OCInitStructure);
 	TIM_OC3Init(TIM8, &TIM_OCInitStructure);
 	TIM_OC4Init(TIM8, &TIM_OCInitStructure);
-
+	
 	TIM_OC1PreloadConfig(TIM8, TIM_OCPreload_Enable);
 	TIM_OC2PreloadConfig(TIM8, TIM_OCPreload_Enable);
 	TIM_OC3PreloadConfig(TIM8, TIM_OCPreload_Enable);
 	TIM_OC4PreloadConfig(TIM8, TIM_OCPreload_Enable);
-
+	
 	// Automatic Output enable, Break, dead time and lock configuration
 	TIM_BDTRInitStructure.TIM_OSSRState = TIM_OSSRState_Enable;
 	TIM_BDTRInitStructure.TIM_OSSIState = TIM_OSSIState_Enable;
 	TIM_BDTRInitStructure.TIM_LOCKLevel = TIM_LOCKLevel_OFF;
-	TIM_BDTRInitStructure.TIM_DeadTime =  conf_general_calculate_deadtime(HW_DEAD_TIME_NSEC, SYSTEM_CORE_CLOCK);
+	TIM_BDTRInitStructure.TIM_DeadTime = conf_general_calculate_deadtime(HW_DEAD_TIME_NSEC, SYSTEM_CORE_CLOCK);
 	TIM_BDTRInitStructure.TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
 
 #ifdef HW_USE_BRK
@@ -399,26 +418,26 @@
 	TIM_BDTRInitStructure.TIM_Break = TIM_Break_Disable;
 	TIM_BDTRInitStructure.TIM_BreakPolarity = TIM_BreakPolarity_High;
 #endif
-
+	
 	TIM_BDTRConfig(TIM1, &TIM_BDTRInitStructure);
 	TIM_CCPreloadControl(TIM1, ENABLE);
 	TIM_ARRPreloadConfig(TIM1, ENABLE);
-
+	
 	TIM_BDTRConfig(TIM8, &TIM_BDTRInitStructure);
 	TIM_CCPreloadControl(TIM8, ENABLE);
 	TIM_ARRPreloadConfig(TIM8, ENABLE);
-
+	
 	// ------------- Timer2 for ADC sampling ------------- //
 	// Time Base configuration
 	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
-
+	
 	TIM_TimeBaseStructure.TIM_Prescaler = 0;
 	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
 	TIM_TimeBaseStructure.TIM_Period = 0xFFFF;
 	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
 	TIM_TimeBaseStructure.TIM_RepetitionCounter = 0;
 	TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);
-
+	
 	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
 	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
 	TIM_OCInitStructure.TIM_Pulse = 250;
@@ -432,13 +451,13 @@
 	TIM_OC2PreloadConfig(TIM2, TIM_OCPreload_Enable);
 	TIM_OC3Init(TIM2, &TIM_OCInitStructure);
 	TIM_OC3PreloadConfig(TIM2, TIM_OCPreload_Enable);
-
+	
 	TIM_ARRPreloadConfig(TIM2, ENABLE);
 	TIM_CCPreloadControl(TIM2, ENABLE);
-
+	
 	// PWM outputs have to be enabled in order to trigger ADC on CCx
 	TIM_CtrlPWMOutputs(TIM2, ENABLE);
-
+	
 	// TIM1 Master and TIM8 slave
 #if defined HW_HAS_DUAL_MOTORS || defined HW_HAS_DUAL_PARALLEL
 	// TODO: Explain. See: https://www.cnblogs.com/shangdawei/p/4758988.html
@@ -456,7 +475,7 @@
 	TIM_SelectInputTrigger(TIM2, TIM_TS_ITR0);
 	TIM_SelectSlaveMode(TIM2, TIM_SlaveMode_Reset);
 #endif
-
+	
 	// Enable TIM1 and TIM2
 #ifdef HW_HAS_DUAL_MOTORS
 	TIM8->CNT = TIM1->ARR;
@@ -466,40 +485,41 @@
 	TIM1->CNT = 0;
 	TIM_Cmd(TIM1, ENABLE);
 	TIM_Cmd(TIM2, ENABLE);
-
+	
 	// Prevent all low side FETs from switching on
 	stop_pwm_hw(&m_motor_1);
 #ifdef HW_HAS_DUAL_MOTORS
 	stop_pwm_hw(&m_motor_2);
 #endif
-
+	
 	// Main Output Enable
 	TIM_CtrlPWMOutputs(TIM1, ENABLE);
 	TIM_CtrlPWMOutputs(TIM8, ENABLE);
-
+	
 	// Sample intervals
 	TIMER_UPDATE_SAMP(MCPWM_FOC_CURRENT_SAMP_OFFSET);
-
+	
 	// Enable CC2 interrupt, which will be fired in V0 and V7
 	TIM_ITConfig(TIM2, TIM_IT_CC2, ENABLE);
 	utils_sys_unlock_cnt();
-
+	
 	nvicEnableVector(TIM2_IRQn, 6);
 }
 
-void mcpwm_foc_init(volatile mc_configuration *conf_m1, volatile mc_configuration *conf_m2) {
+void mcpwm_foc_init(volatile mc_configuration* conf_m1, volatile mc_configuration* conf_m2)
+{
 	utils_sys_lock_cnt();
 
 #ifndef HW_HAS_DUAL_MOTORS
 	(void)conf_m2;
 #endif
-
+	
 	m_init_done = false;
-
+	
 	// Initialize variables
 	memset((void*)&m_motor_1, 0, sizeof(motor_all_state_t));
 	m_isr_motor = 0;
-
+	
 	m_motor_1.m_conf = conf_m1;
 	m_motor_1.m_state = MC_STATE_OFF;
 	m_motor_1.m_control_mode = CONTROL_MODE_NONE;
@@ -526,30 +546,31 @@
 	m_motor_2.m_curr_ofs[2] = 2048;
 	update_hfi_samples(m_motor_2.m_conf->foc_hfi_samples, &m_motor_2);
 #endif
-
+	
 	virtual_motor_init();
-
+	
 	TIM_DeInit(TIM1);
 	TIM_DeInit(TIM2);
 	TIM_DeInit(TIM8);
 	TIM1->CNT = 0;
 	TIM2->CNT = 0;
 	TIM8->CNT = 0;
-
+	
 	// ADC
 	ADC_CommonInitTypeDef ADC_CommonInitStructure;
 	DMA_InitTypeDef DMA_InitStructure;
 	ADC_InitTypeDef ADC_InitStructure;
-
+	
 	// Clock
 	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA2 | RCC_AHB1Periph_GPIOA | RCC_AHB1Periph_GPIOC, ENABLE);
 	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 | RCC_APB2Periph_ADC2 | RCC_APB2Periph_ADC3, ENABLE);
-
+	
 	dmaStreamAllocate(STM32_DMA_STREAM(STM32_DMA_STREAM_ID(2, 4)),
-					  5,
-					  (stm32_dmaisr_t)mcpwm_foc_adc_int_handler,
-					  (void *)0);
-
+	                  5,
+	                  (stm32_dmaisr_t)mcpwm_foc_adc_int_handler,
+	                  (void*)0
+	);
+	
 	// DMA for the ADC
 	DMA_InitStructure.DMA_Channel = DMA_Channel_0;
 	DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)&ADC_Value;
@@ -567,10 +588,10 @@
 	DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;
 	DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
 	DMA_Init(DMA2_Stream4, &DMA_InitStructure);
-
+	
 	DMA_Cmd(DMA2_Stream4, ENABLE);
 	DMA_ITConfig(DMA2_Stream4, DMA_IT_TC, ENABLE);
-
+	
 	// ADC Common Init
 	// Note that the ADC is running at 42MHz, which is higher than the
 	// specified 36MHz in the data sheet, but it works.
@@ -579,7 +600,7 @@
 	ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_1;
 	ADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;
 	ADC_CommonInit(&ADC_CommonInitStructure);
-
+	
 	// Channel-specific settings
 	ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;
 	ADC_InitStructure.ADC_ScanConvMode = ENABLE;
@@ -588,84 +609,90 @@
 	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_T2_CC2;
 	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
 	ADC_InitStructure.ADC_NbrOfConversion = HW_ADC_NBR_CONV;
-
+	
 	ADC_Init(ADC1, &ADC_InitStructure);
 	ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
 	ADC_InitStructure.ADC_ExternalTrigConv = 0;
 	ADC_Init(ADC2, &ADC_InitStructure);
 	ADC_Init(ADC3, &ADC_InitStructure);
-
+	
 	ADC_TempSensorVrefintCmd(ENABLE);
 	ADC_MultiModeDMARequestAfterLastTransferCmd(ENABLE);
-
+	
 	hw_setup_adc_channels();
-
+	
 	ADC_Cmd(ADC1, ENABLE);
 	ADC_Cmd(ADC2, ENABLE);
 	ADC_Cmd(ADC3, ENABLE);
-
+	
 	timer_reinit((int)m_motor_1.m_conf->foc_f_sw);
-
+	
 	stop_pwm_hw(&m_motor_1);
 #ifdef HW_HAS_DUAL_MOTORS
 	stop_pwm_hw(&m_motor_2);
 #endif
-
+	
 	// Sample intervals. For now they are fixed with voltage samples in the center of V7
 	// and current samples in the center of V0
 	TIMER_UPDATE_SAMP(MCPWM_FOC_CURRENT_SAMP_OFFSET);
-
+	
 	// Enable CC2 interrupt, which will be fired in V0 and V7
 	TIM_ITConfig(TIM2, TIM_IT_CC2, ENABLE);
 	nvicEnableVector(TIM2_IRQn, 6);
-
+	
 	utils_sys_unlock_cnt();
-
+	
 	CURRENT_FILTER_ON();
-
+	
 	// Calibrate current offset
 	ENABLE_GATE();
 	DCCAL_OFF();
 	do_dc_cal();
-
+	
 	// Start threads
 	timer_thd_stop = false;
 	chThdCreateStatic(timer_thread_wa, sizeof(timer_thread_wa), NORMALPRIO, timer_thread, NULL);
-
+	
 	hfi_thd_stop = false;
 	chThdCreateStatic(hfi_thread_wa, sizeof(hfi_thread_wa), NORMALPRIO, hfi_thread, NULL);
-
+	
 	// Check if the system has resumed from IWDG reset
-	if (timeout_had_IWDG_reset()) {
+	if (timeout_had_IWDG_reset())
+	{
 		mc_interface_fault_stop(FAULT_CODE_BOOTING_FROM_WATCHDOG_RESET, false, false);
 	}
-
+	
 	terminal_register_command_callback(
-			"foc_plot_hfi_en",
-			"Enable HFI plotting. 0: off, 1: DFT, 2: Raw",
-			"[en]",
-			terminal_plot_hfi);
-
+		"foc_plot_hfi_en",
+		"Enable HFI plotting. 0: off, 1: DFT, 2: Raw",
+		"[en]",
+		terminal_plot_hfi
+	);
+	
 	m_init_done = true;
 }
 
-void mcpwm_foc_deinit(void) {
-	if (!m_init_done) {
+void mcpwm_foc_deinit(void)
+{
+	if (!m_init_done)
+	{
 		return;
 	}
-
+	
 	m_init_done = false;
-
+	
 	timer_thd_stop = true;
-	while (timer_thd_stop) {
+	while (timer_thd_stop)
+	{
 		chThdSleepMilliseconds(1);
 	}
-
+	
 	hfi_thd_stop = true;
-	while (hfi_thd_stop) {
+	while (hfi_thd_stop)
+	{
 		chThdSleepMilliseconds(1);
 	}
-
+	
 	TIM_DeInit(TIM1);
 	TIM_DeInit(TIM2);
 	TIM_DeInit(TIM8);
@@ -675,7 +702,8 @@
 	dmaStreamRelease(STM32_DMA_STREAM(STM32_DMA_STREAM_ID(2, 4)));
 }
 
-static volatile motor_all_state_t *motor_now(void) {
+static volatile motor_all_state_t* motor_now(void)
+{
 #ifdef HW_HAS_DUAL_MOTORS
 	return mc_interface_motor_now() == 1 ? &m_motor_1 : &m_motor_2;
 #else
@@ -683,17 +711,20 @@
 #endif
 }
 
-bool mcpwm_foc_init_done(void) {
+bool mcpwm_foc_init_done(void)
+{
 	return m_init_done;
 }
 
-void mcpwm_foc_set_configuration(volatile mc_configuration *configuration) {
+void mcpwm_foc_set_configuration(volatile mc_configuration* configuration)
+{
 	motor_now()->m_conf = configuration;
-
+	
 	// Below we check if anything in the configuration changed that requires stopping the motor.
-
+	
 	uint32_t top = SYSTEM_CORE_CLOCK / (int)configuration->foc_f_sw;
-	if (TIM1->ARR != top) {
+	if (TIM1->ARR != top)
+	{
 #ifdef HW_HAS_DUAL_MOTORS
 		m_motor_1.m_control_mode = CONTROL_MODE_NONE;
 		m_motor_1.m_state = MC_STATE_OFF;
@@ -714,8 +745,9 @@
 #endif
 #endif
 	}
-
-	if (((1 << motor_now()->m_conf->foc_hfi_samples) * 8) != motor_now()->m_hfi.samples) {
+	
+	if (((1 << motor_now()->m_conf->foc_hfi_samples) * 8) != motor_now()->m_hfi.samples)
+	{
 		motor_now()->m_control_mode = CONTROL_MODE_NONE;
 		motor_now()->m_state = MC_STATE_OFF;
 		stop_pwm_hw(motor_now());
@@ -723,11 +755,13 @@
 	}
 }
 
-mc_state mcpwm_foc_get_state(void) {
+mc_state mcpwm_foc_get_state(void)
+{
 	return motor_now()->m_state;
 }
 
-bool mcpwm_foc_is_dccal_done(void) {
+bool mcpwm_foc_is_dccal_done(void)
+{
 	return m_dccal_done;
 }
 
@@ -739,21 +773,23 @@
  * 1: Motor 1
  * 2: Motor 2
  */
-int mcpwm_foc_isr_motor(void) {
+int mcpwm_foc_isr_motor(void)
+{
 	return m_isr_motor;
 }
 
 /**
  * Switch off all FETs.
  */
-void mcpwm_foc_stop_pwm(bool is_second_motor) {
+void mcpwm_foc_stop_pwm(bool is_second_motor)
+{
 #ifdef HW_HAS_DUAL_MOTORS
 	volatile motor_all_state_t *motor = is_second_motor ? &m_motor_2 : &m_motor_1;
 #else
 	(void)is_second_motor;
-	volatile motor_all_state_t *motor = &m_motor_1;
+	volatile motor_all_state_t* motor = &m_motor_1;
 #endif
-
+	
 	motor->m_control_mode = CONTROL_MODE_NONE;
 	motor->m_state = MC_STATE_OFF;
 	stop_pwm_hw(motor);
@@ -766,11 +802,13 @@
  * @param dutyCycle
  * The duty cycle to use.
  */
-void mcpwm_foc_set_duty(float dutyCycle) {
+void mcpwm_foc_set_duty(float dutyCycle)
+{
 	motor_now()->m_control_mode = CONTROL_MODE_DUTY;
 	motor_now()->m_duty_cycle_set = dutyCycle;
-
-	if (motor_now()->m_state != MC_STATE_RUNNING) {
+	
+	if (motor_now()->m_state != MC_STATE_RUNNING)
+	{
 		motor_now()->m_state = MC_STATE_RUNNING;
 	}
 }
@@ -785,7 +823,8 @@
  * @param dutyCycle
  * The duty cycle to use.
  */
-void mcpwm_foc_set_duty_noramp(float dutyCycle) {
+void mcpwm_foc_set_duty_noramp(float dutyCycle)
+{
 	// TODO: Actually do this without ramping
 	mcpwm_foc_set_duty(dutyCycle);
 }
@@ -797,11 +836,13 @@
  * @param rpm
  * The electrical RPM goal value to use.
  */
-void mcpwm_foc_set_pid_speed(float rpm) {
+void mcpwm_foc_set_pid_speed(float rpm)
+{
 	motor_now()->m_control_mode = CONTROL_MODE_SPEED;
 	motor_now()->m_speed_pid_set_rpm = rpm;
-
-	if (motor_now()->m_state != MC_STATE_RUNNING) {
+	
+	if (motor_now()->m_state != MC_STATE_RUNNING)
+	{
 		motor_now()->m_state = MC_STATE_RUNNING;
 	}
 }
@@ -813,11 +854,13 @@
  * @param pos
  * The desired position of the motor in degrees.
  */
-void mcpwm_foc_set_pid_pos(float pos) {
+void mcpwm_foc_set_pid_pos(float pos)
+{
 	motor_now()->m_control_mode = CONTROL_MODE_POS;
 	motor_now()->m_pos_pid_set = pos;
-
-	if (motor_now()->m_state != MC_STATE_RUNNING) {
+	
+	if (motor_now()->m_state != MC_STATE_RUNNING)
+	{
 		motor_now()->m_state = MC_STATE_RUNNING;
 	}
 }
@@ -830,18 +873,21 @@
  * @param current
  * The current to use.
  */
-void mcpwm_foc_set_current(float current) {
-	if (fabsf(current) < motor_now()->m_conf->cc_min_current) {
+void mcpwm_foc_set_current(float current)
+{
+	if (fabsf(current) < motor_now()->m_conf->cc_min_current)
+	{
 		motor_now()->m_control_mode = CONTROL_MODE_NONE;
 		motor_now()->m_state = MC_STATE_OFF;
 		stop_pwm_hw(motor_now());
 		return;
 	}
-
+	
 	motor_now()->m_control_mode = CONTROL_MODE_CURRENT;
 	motor_now()->m_iq_set = current;
-
-	if (motor_now()->m_state != MC_STATE_RUNNING) {
+	
+	if (motor_now()->m_state != MC_STATE_RUNNING)
+	{
 		motor_now()->m_state = MC_STATE_RUNNING;
 	}
 }
@@ -853,18 +899,21 @@
  * @param current
  * The current to use. Positive and negative values give the same effect.
  */
-void mcpwm_foc_set_brake_current(float current) {
-	if (fabsf(current) < motor_now()->m_conf->cc_min_current) {
+void mcpwm_foc_set_brake_current(float current)
+{
+	if (fabsf(current) < motor_now()->m_conf->cc_min_current)
+	{
 		motor_now()->m_control_mode = CONTROL_MODE_NONE;
 		motor_now()->m_state = MC_STATE_OFF;
 		stop_pwm_hw(motor_now());
 		return;
 	}
-
+	
 	motor_now()->m_control_mode = CONTROL_MODE_CURRENT_BRAKE;
 	motor_now()->m_iq_set = current;
-
-	if (motor_now()->m_state != MC_STATE_RUNNING) {
+	
+	if (motor_now()->m_state != MC_STATE_RUNNING)
+	{
 		motor_now()->m_state = MC_STATE_RUNNING;
 	}
 }
@@ -876,18 +925,21 @@
  * @param current
  * The brake current to use.
  */
-void mcpwm_foc_set_handbrake(float current) {
-	if (fabsf(current) < motor_now()->m_conf->cc_min_current) {
+void mcpwm_foc_set_handbrake(float current)
+{
+	if (fabsf(current) < motor_now()->m_conf->cc_min_current)
+	{
 		motor_now()->m_control_mode = CONTROL_MODE_NONE;
 		motor_now()->m_state = MC_STATE_OFF;
 		stop_pwm_hw(motor_now());
 		return;
 	}
-
+	
 	motor_now()->m_control_mode = CONTROL_MODE_HANDBRAKE;
 	motor_now()->m_iq_set = current;
-
-	if (motor_now()->m_state != MC_STATE_RUNNING) {
+	
+	if (motor_now()->m_state != MC_STATE_RUNNING)
+	{
 		motor_now()->m_state = MC_STATE_RUNNING;
 	}
 }
@@ -901,22 +953,27 @@
  * @param rpm
  * The RPM to use.
  */
-void mcpwm_foc_set_openloop(float current, float rpm) {
-	if (fabsf(current) < motor_now()->m_conf->cc_min_current) {
+void mcpwm_foc_set_openloop(float current, float rpm)
+{
+	if (fabsf(current) < motor_now()->m_conf->cc_min_current)
+	{
 		motor_now()->m_control_mode = CONTROL_MODE_NONE;
 		motor_now()->m_state = MC_STATE_OFF;
 		stop_pwm_hw(motor_now());
 		return;
 	}
-
-	utils_truncate_number(&current, -motor_now()->m_conf->l_current_max * motor_now()->m_conf->l_current_max_scale,
-						  motor_now()->m_conf->l_current_max * motor_now()->m_conf->l_current_max_scale);
-
+	
+	utils_truncate_number(
+		&current, -motor_now()->m_conf->l_current_max * motor_now()->m_conf->l_current_max_scale,
+		motor_now()->m_conf->l_current_max * motor_now()->m_conf->l_current_max_scale
+	);
+	
 	motor_now()->m_control_mode = CONTROL_MODE_OPENLOOP;
 	motor_now()->m_iq_set = current;
 	motor_now()->m_openloop_speed = rpm * ((2.0 * M_PI) / 60.0);
-
-	if (motor_now()->m_state != MC_STATE_RUNNING) {
+	
+	if (motor_now()->m_state != MC_STATE_RUNNING)
+	{
 		motor_now()->m_state = MC_STATE_RUNNING;
 	}
 }
@@ -930,24 +987,29 @@
  * @param phase
  * The phase to use in degrees, range [0.0 360.0]
  */
-void mcpwm_foc_set_openloop_phase(float current, float phase) {
-	if (fabsf(current) < motor_now()->m_conf->cc_min_current) {
+void mcpwm_foc_set_openloop_phase(float current, float phase)
+{
+	if (fabsf(current) < motor_now()->m_conf->cc_min_current)
+	{
 		motor_now()->m_control_mode = CONTROL_MODE_NONE;
 		motor_now()->m_state = MC_STATE_OFF;
 		stop_pwm_hw(motor_now());
 		return;
 	}
-
-	utils_truncate_number(&current, -motor_now()->m_conf->l_current_max * motor_now()->m_conf->l_current_max_scale,
-						  motor_now()->m_conf->l_current_max * motor_now()->m_conf->l_current_max_scale);
-
+	
+	utils_truncate_number(
+		&current, -motor_now()->m_conf->l_current_max * motor_now()->m_conf->l_current_max_scale,
+		motor_now()->m_conf->l_current_max * motor_now()->m_conf->l_current_max_scale
+	);
+	
 	motor_now()->m_control_mode = CONTROL_MODE_OPENLOOP_PHASE;
 	motor_now()->m_iq_set = current;
-
+	
 	motor_now()->m_openloop_phase = phase * M_PI / 180.0;
 	utils_norm_angle_rad((float*)&motor_now()->m_openloop_phase);
-
-	if (motor_now()->m_state != MC_STATE_RUNNING) {
+	
+	if (motor_now()->m_state != MC_STATE_RUNNING)
+	{
 		motor_now()->m_state = MC_STATE_RUNNING;
 	}
 }
@@ -957,9 +1019,12 @@
  * this is used by the virtual motor to set the previously saved offsets back,
  * when it is disconnected
  */
-void mcpwm_foc_set_current_offsets(volatile int curr0_offset,
-								   volatile int curr1_offset,
-								   volatile int curr2_offset) {
+void mcpwm_foc_set_current_offsets(
+	volatile int curr0_offset,
+	volatile int curr1_offset,
+	volatile int curr2_offset
+)
+{
 	motor_now()->m_curr_ofs[0] = curr0_offset;
 	motor_now()->m_curr_ofs[1] = curr1_offset;
 	motor_now()->m_curr_ofs[2] = curr2_offset;
@@ -974,12 +1039,14 @@
  * @param rpm
  * The RPM to use.
  */
-void mcpwm_foc_set_openloop_duty(float dutyCycle, float rpm) {
+void mcpwm_foc_set_openloop_duty(float dutyCycle, float rpm)
+{
 	motor_now()->m_control_mode = CONTROL_MODE_OPENLOOP_DUTY;
 	motor_now()->m_duty_cycle_set = dutyCycle;
 	motor_now()->m_openloop_speed = rpm * ((2.0 * M_PI) / 60.0);
-
-	if (motor_now()->m_state != MC_STATE_RUNNING) {
+	
+	if (motor_now()->m_state != MC_STATE_RUNNING)
+	{
 		motor_now()->m_state = MC_STATE_RUNNING;
 	}
 }
@@ -993,30 +1060,36 @@
  * @param phase
  * The phase to use in degrees, range [0.0 360.0]
  */
-void mcpwm_foc_set_openloop_duty_phase(float dutyCycle, float phase) {
+void mcpwm_foc_set_openloop_duty_phase(float dutyCycle, float phase)
+{
 	motor_now()->m_control_mode = CONTROL_MODE_OPENLOOP_DUTY_PHASE;
 	motor_now()->m_duty_cycle_set = dutyCycle;
 	motor_now()->m_openloop_phase = phase * M_PI / 180.0;
 	utils_norm_angle_rad((float*)&motor_now()->m_openloop_phase);
-
-	if (motor_now()->m_state != MC_STATE_RUNNING) {
+	
+	if (motor_now()->m_state != MC_STATE_RUNNING)
+	{
 		motor_now()->m_state = MC_STATE_RUNNING;
 	}
 }
 
-float mcpwm_foc_get_duty_cycle_set(void) {
+float mcpwm_foc_get_duty_cycle_set(void)
+{
 	return motor_now()->m_duty_cycle_set;
 }
 
-float mcpwm_foc_get_duty_cycle_now(void) {
+float mcpwm_foc_get_duty_cycle_now(void)
+{
 	return motor_now()->m_motor_state.duty_now;
 }
 
-float mcpwm_foc_get_pid_pos_set(void) {
+float mcpwm_foc_get_pid_pos_set(void)
+{
 	return motor_now()->m_pos_pid_set;
 }
 
-float mcpwm_foc_get_pid_pos_now(void) {
+float mcpwm_foc_get_pid_pos_now(void)
+{
 	return motor_now()->m_pos_pid_now;
 }
 
@@ -1026,7 +1099,8 @@
  * @return
  * The switching frequency in Hz.
  */
-float mcpwm_foc_get_switching_frequency_now(void) {
+float mcpwm_foc_get_switching_frequency_now(void)
+{
 	return motor_now()->m_conf->foc_f_sw;
 }
 
@@ -1036,11 +1110,15 @@
  * @return
  * The sampling frequency in Hz.
  */
-float mcpwm_foc_get_sampling_frequency_now(void) {
+float mcpwm_foc_get_sampling_frequency_now(void)
+{
 #ifdef HW_HAS_PHASE_SHUNTS
-	if (motor_now()->m_conf->foc_sample_v0_v7) {
+	if (motor_now()->m_conf->foc_sample_v0_v7)
+	{
 		return motor_now()->m_conf->foc_f_sw;
-	} else {
+	}
+	else
+	{
 		return motor_now()->m_conf->foc_f_sw / 2.0;
 	}
 #else
@@ -1051,11 +1129,15 @@
 /**
  * Returns Ts used for virtual motor sync
  */
-float mcpwm_foc_get_ts(void) {
+float mcpwm_foc_get_ts(void)
+{
 #ifdef HW_HAS_PHASE_SHUNTS
-	if (motor_now()->m_conf->foc_sample_v0_v7) {
-		return (1.0 / motor_now()->m_conf->foc_f_sw) ;
-	} else {
+	if (motor_now()->m_conf->foc_sample_v0_v7)
+	{
+		return (1.0 / motor_now()->m_conf->foc_f_sw);
+	}
+	else
+	{
 		return (1.0 / (motor_now()->m_conf->foc_f_sw / 2.0));
 	}
 #else
@@ -1063,11 +1145,13 @@
 #endif
 }
 
-bool mcpwm_foc_is_using_encoder(void) {
+bool mcpwm_foc_is_using_encoder(void)
+{
 	return motor_now()->m_using_encoder;
 }
 
-float mcpwm_foc_get_tot_current_motor(bool is_second_motor) {
+float mcpwm_foc_get_tot_current_motor(bool is_second_motor)
+{
 #ifdef HW_HAS_DUAL_MOTORS
 	volatile motor_all_state_t *motor = is_second_motor ? &m_motor_2 : &m_motor_1;
 	return SIGN(motor->m_motor_state.vq) * motor->m_motor_state.iq;
@@ -1077,7 +1161,8 @@
 #endif
 }
 
-float mcpwm_foc_get_tot_current_filtered_motor(bool is_second_motor) {
+float mcpwm_foc_get_tot_current_filtered_motor(bool is_second_motor)
+{
 #ifdef HW_HAS_DUAL_MOTORS
 	volatile motor_all_state_t *motor = is_second_motor ? &m_motor_2 : &m_motor_1;
 	return SIGN(motor->m_motor_state.vq) * motor->m_motor_state.iq_filter;
@@ -1087,7 +1172,8 @@
 #endif
 }
 
-float mcpwm_foc_get_tot_current_in_motor(bool is_second_motor) {
+float mcpwm_foc_get_tot_current_in_motor(bool is_second_motor)
+{
 #ifdef HW_HAS_DUAL_MOTORS
 	return (is_second_motor ? &m_motor_2 : &m_motor_1)->m_motor_state.i_bus;
 #else
@@ -1096,7 +1182,8 @@
 #endif
 }
 
-float mcpwm_foc_get_tot_current_in_filtered_motor(bool is_second_motor) {
+float mcpwm_foc_get_tot_current_in_filtered_motor(bool is_second_motor)
+{
 	// TODO: Filter current?
 #ifdef HW_HAS_DUAL_MOTORS
 	return (is_second_motor ? &m_motor_2 : &m_motor_1)->m_motor_state.i_bus;
@@ -1106,7 +1193,8 @@
 #endif
 }
 
-float mcpwm_foc_get_abs_motor_current_motor(bool is_second_motor) {
+float mcpwm_foc_get_abs_motor_current_motor(bool is_second_motor)
+{
 #ifdef HW_HAS_DUAL_MOTORS
 	return (is_second_motor ? &m_motor_2 : &m_motor_1)->m_motor_state.i_abs;
 #else
@@ -1115,7 +1203,8 @@
 #endif
 }
 
-float mcpwm_foc_get_abs_motor_current_filtered_motor(bool is_second_motor) {
+float mcpwm_foc_get_abs_motor_current_filtered_motor(bool is_second_motor)
+{
 #ifdef HW_HAS_DUAL_MOTORS
 	return (is_second_motor ? &m_motor_2 : &m_motor_1)->m_motor_state.i_abs_filter;
 #else
@@ -1124,7 +1213,8 @@
 #endif
 }
 
-mc_state mcpwm_foc_get_state_motor(bool is_second_motor) {
+mc_state mcpwm_foc_get_state_motor(bool is_second_motor)
+{
 #ifdef HW_HAS_DUAL_MOTORS
 	return (is_second_motor ? &m_motor_2 : &m_motor_1)->m_state;
 #else
@@ -1141,7 +1231,8 @@
  * @return
  * The RPM value.
  */
-float mcpwm_foc_get_rpm(void) {
+float mcpwm_foc_get_rpm(void)
+{
 	return motor_now()->m_motor_state.speed_rad_s / ((2.0 * M_PI) / 60.0);
 	//	return motor_now()->m_speed_est_fast / ((2.0 * M_PI) / 60.0);
 }
@@ -1149,14 +1240,16 @@
 /**
  * Same as above, but uses the fast and noisier estimator.
  */
-float mcpwm_foc_get_rpm_fast(void) {
+float mcpwm_foc_get_rpm_fast(void)
+{
 	return motor_now()->m_speed_est_fast / ((2.0 * M_PI) / 60.0);
 }
 
 /**
  * Same as above, but uses the faster and noisier estimator.
  */
-float mcpwm_foc_get_rpm_faster(void) {
+float mcpwm_foc_get_rpm_faster(void)
+{
 	return motor_now()->m_speed_est_faster / ((2.0 * M_PI) / 60.0);
 }
 
@@ -1168,7 +1261,8 @@
  * @return
  * The motor current.
  */
-float mcpwm_foc_get_tot_current(void) {
+float mcpwm_foc_get_tot_current(void)
+{
 	return SIGN(motor_now()->m_motor_state.vq) * motor_now()->m_motor_state.iq;
 }
 
@@ -1180,7 +1274,8 @@
  * @return
  * The filtered motor current.
  */
-float mcpwm_foc_get_tot_current_filtered(void) {
+float mcpwm_foc_get_tot_current_filtered(void)
+{
 	return SIGN(motor_now()->m_motor_state.vq) * motor_now()->m_motor_state.iq_filter;
 }
 
@@ -1191,7 +1286,8 @@
  * @return
  * The magnitude of the motor current.
  */
-float mcpwm_foc_get_abs_motor_current(void) {
+float mcpwm_foc_get_abs_motor_current(void)
+{
 	return motor_now()->m_motor_state.i_abs;
 }
 
@@ -1201,7 +1297,8 @@
  * @return
  * The magnitude of the phase currents unbalance.
  */
-float mcpwm_foc_get_abs_motor_current_unbalance(void) {
+float mcpwm_foc_get_abs_motor_current_unbalance(void)
+{
 	return (float)(motor_now()->m_curr_unbalance) * FAC_CURRENT;
 }
 
@@ -1211,7 +1308,8 @@
  * @return
  * The magnitude of the motor voltage.
  */
-float mcpwm_foc_get_abs_motor_voltage(void) {
+float mcpwm_foc_get_abs_motor_voltage(void)
+{
 	const float vd_tmp = motor_now()->m_motor_state.vd;
 	const float vq_tmp = motor_now()->m_motor_state.vq;
 	return sqrtf(SQ(vd_tmp) + SQ(vq_tmp));
@@ -1224,7 +1322,8 @@
  * @return
  * The magnitude of the motor current.
  */
-float mcpwm_foc_get_abs_motor_current_filtered(void) {
+float mcpwm_foc_get_abs_motor_current_filtered(void)
+{
 	return motor_now()->m_motor_state.i_abs_filter;
 }
 
@@ -1235,7 +1334,8 @@
  * @return
  * The motor current.
  */
-float mcpwm_foc_get_tot_current_directional(void) {
+float mcpwm_foc_get_tot_current_directional(void)
+{
 	return motor_now()->m_motor_state.iq;
 }
 
@@ -1246,7 +1346,8 @@
  * @return
  * The filtered motor current.
  */
-float mcpwm_foc_get_tot_current_directional_filtered(void) {
+float mcpwm_foc_get_tot_current_directional_filtered(void)
+{
 	return motor_now()->m_motor_state.iq_filter;
 }
 
@@ -1256,7 +1357,8 @@
  * @return
  * The D axis current.
  */
-float mcpwm_foc_get_id(void) {
+float mcpwm_foc_get_id(void)
+{
 	return motor_now()->m_motor_state.id;
 }
 
@@ -1266,7 +1368,8 @@
  * @return
  * The Q axis current.
  */
-float mcpwm_foc_get_iq(void) {
+float mcpwm_foc_get_iq(void)
+{
 	return motor_now()->m_motor_state.iq;
 }
 
@@ -1276,7 +1379,8 @@
  * @return
  * The input current.
  */
-float mcpwm_foc_get_tot_current_in(void) {
+float mcpwm_foc_get_tot_current_in(void)
+{
 	return motor_now()->m_motor_state.i_bus;
 }
 
@@ -1286,7 +1390,8 @@
  * @return
  * The filtered input current.
  */
-float mcpwm_foc_get_tot_current_in_filtered(void) {
+float mcpwm_foc_get_tot_current_in_filtered(void)
+{
 	return motor_now()->m_motor_state.i_bus; // TODO: Calculate filtered current?
 }
 
@@ -1301,7 +1406,8 @@
  * The previous tachometer value in motor steps. The number of motor revolutions will
  * be this number divided by (3 * MOTOR_POLE_NUMBER).
  */
-int mcpwm_foc_set_tachometer_value(int steps) {
+int mcpwm_foc_set_tachometer_value(int steps)
+{
 	int val = motor_now()->m_tachometer;
 	motor_now()->m_tachometer = steps;
 	return val;
@@ -1318,13 +1424,15 @@
  * The tachometer value in motor steps. The number of motor revolutions will
  * be this number divided by (3 * MOTOR_POLE_NUMBER).
  */
-int mcpwm_foc_get_tachometer_value(bool reset) {
+int mcpwm_foc_get_tachometer_value(bool reset)
+{
 	int val = motor_now()->m_tachometer;
-
-	if (reset) {
+	
+	if (reset)
+	{
 		motor_now()->m_tachometer = 0;
 	}
-
+	
 	return val;
 }
 
@@ -1338,13 +1446,15 @@
  * The tachometer value in motor steps. The number of motor revolutions will
  * be this number divided by (3 * MOTOR_POLE_NUMBER).
  */
-int mcpwm_foc_get_tachometer_abs_value(bool reset) {
+int mcpwm_foc_get_tachometer_abs_value(bool reset)
+{
 	int val = motor_now()->m_tachometer_abs;
-
-	if (reset) {
+	
+	if (reset)
+	{
 		motor_now()->m_tachometer_abs = 0;
 	}
-
+	
 	return val;
 }
 
@@ -1354,7 +1464,8 @@
  * @return
  * The phase angle in degrees.
  */
-float mcpwm_foc_get_phase(void) {
+float mcpwm_foc_get_phase(void)
+{
 	float angle = motor_now()->m_motor_state.phase * (180.0 / M_PI);
 	utils_norm_angle(&angle);
 	return angle;
@@ -1366,7 +1477,8 @@
  * @return
  * The phase angle in degrees.
  */
-float mcpwm_foc_get_phase_observer(void) {
+float mcpwm_foc_get_phase_observer(void)
+{
 	float angle = motor_now()->m_phase_now_observer * (180.0 / M_PI);
 	utils_norm_angle(&angle);
 	return angle;
@@ -1378,17 +1490,20 @@
  * @return
  * The phase angle in degrees.
  */
-float mcpwm_foc_get_phase_encoder(void) {
+float mcpwm_foc_get_phase_encoder(void)
+{
 	float angle = motor_now()->m_phase_now_encoder * (180.0 / M_PI);
 	utils_norm_angle(&angle);
 	return angle;
 }
 
-float mcpwm_foc_get_vd(void) {
+float mcpwm_foc_get_vd(void)
+{
 	return motor_now()->m_motor_state.vd;
 }
 
-float mcpwm_foc_get_vq(void) {
+float mcpwm_foc_get_vq(void)
+{
 	return motor_now()->m_motor_state.vq;
 }
 
@@ -1398,15 +1513,17 @@
  * when it is connected
  */
 void mcpwm_foc_get_current_offsets(
-		volatile int *curr0_offset,
-		volatile int *curr1_offset,
-		volatile int *curr2_offset,
-		bool is_second_motor) {
+	volatile int* curr0_offset,
+	volatile int* curr1_offset,
+	volatile int* curr2_offset,
+	bool is_second_motor
+)
+{
 #ifdef HW_HAS_DUAL_MOTORS
 	volatile motor_all_state_t *motor = is_second_motor ? &m_motor_2 : &m_motor_1;
 #else
 	(void)is_second_motor;
-	volatile motor_all_state_t *motor = &m_motor_1;
+	volatile motor_all_state_t* motor = &m_motor_1;
 #endif
 	*curr0_offset = motor->m_curr_ofs[0];
 	*curr1_offset = motor->m_curr_ofs[1];
@@ -1428,225 +1545,251 @@
  * @param direction
  * The detected direction.
  */
-void mcpwm_foc_encoder_detect(float current, bool print, float *offset, float *ratio, bool *inverted) {
+void mcpwm_foc_encoder_detect(float current, bool print, float* offset, float* ratio, bool* inverted)
+{
 	mc_interface_lock();
-
-	volatile motor_all_state_t *motor = motor_now();
-
+	
+	volatile motor_all_state_t* motor = motor_now();
+	
 	motor->m_phase_override = true;
 	motor->m_id_set = current;
 	motor->m_iq_set = 0.0;
 	motor->m_control_mode = CONTROL_MODE_CURRENT;
 	motor->m_state = MC_STATE_RUNNING;
-
+	
 	// Disable timeout
 	systime_t tout = timeout_get_timeout_msec();
 	float tout_c = timeout_get_brake_current();
 	timeout_reset();
 	timeout_configure(600000, 0.0);
-
+	
 	// Save configuration
 	float offset_old = motor->m_conf->foc_encoder_offset;
 	float inverted_old = motor->m_conf->foc_encoder_inverted;
 	float ratio_old = motor->m_conf->foc_encoder_ratio;
-
+	
 	motor->m_conf->foc_encoder_offset = 0.0;
 	motor->m_conf->foc_encoder_inverted = false;
 	motor->m_conf->foc_encoder_ratio = 1.0;
-
+	
 	// Find index
 	int cnt = 0;
-	while(!encoder_index_found()) {
-		for (float i = 0.0;i < 2.0 * M_PI;i += (2.0 * M_PI) / 500.0) {
+	while (!encoder_index_found())
+	{
+		for (float i = 0.0; i < 2.0 * M_PI; i += (2.0 * M_PI) / 500.0)
+		{
 			motor->m_phase_now_override = i;
 			chThdSleepMilliseconds(1);
 		}
-
+		
 		cnt++;
-		if (cnt > 30) {
+		if (cnt > 30)
+		{
 			// Give up
 			break;
 		}
 	}
-
-	if (print) {
+	
+	if (print)
+	{
 		commands_printf("Index found");
 	}
-
+	
 	// Rotate
-	for (float i = 0.0;i < 2.0 * M_PI;i += (2.0 * M_PI) / 500.0) {
+	for (float i = 0.0; i < 2.0 * M_PI; i += (2.0 * M_PI) / 500.0)
+	{
 		motor->m_phase_now_override = i;
 		chThdSleepMilliseconds(1);
 	}
-
-	if (print) {
+	
+	if (print)
+	{
 		commands_printf("Rotated for sync");
 	}
-
+	
 	// Inverted and ratio
 	chThdSleepMilliseconds(1000);
-
+	
 	const int it_rat = 20;
 	float s_sum = 0.0;
 	float c_sum = 0.0;
 	float first = motor->m_phase_now_encoder;
-
-	for (int i = 0; i < it_rat; i++) {
+	
+	for (int i = 0; i < it_rat; i++)
+	{
 		float phase_old = motor->m_phase_now_encoder;
 		float phase_ovr_tmp = motor->m_phase_now_override;
 		for (float j = phase_ovr_tmp; j < phase_ovr_tmp + (2.0 / 3.0) * M_PI;
-				j += (2.0 * M_PI) / 500.0) {
+		     j += (2.0 * M_PI) / 500.0)
+		{
 			motor->m_phase_now_override = j;
 			chThdSleepMilliseconds(1);
 		}
 		utils_norm_angle_rad((float*)&motor->m_phase_now_override);
 		chThdSleepMilliseconds(300);
 		float diff = utils_angle_difference_rad(motor->m_phase_now_encoder, phase_old);
-
+		
 		float s, c;
 		sincosf(diff, &s, &c);
 		s_sum += s;
 		c_sum += c;
-
-		if (print) {
+		
+		if (print)
+		{
 			commands_printf("%.2f", (double)(diff * 180.0 / M_PI));
 		}
-
-		if (i > 3 && fabsf(utils_angle_difference_rad(motor->m_phase_now_encoder, first)) < fabsf(diff / 2.0)) {
+		
+		if (i > 3 && fabsf(utils_angle_difference_rad(motor->m_phase_now_encoder, first)) < fabsf(diff / 2.0))
+		{
 			break;
 		}
 	}
-
+	
 	first = motor->m_phase_now_encoder;
-
-	for (int i = 0; i < it_rat; i++) {
+	
+	for (int i = 0; i < it_rat; i++)
+	{
 		float phase_old = motor->m_phase_now_encoder;
 		float phase_ovr_tmp = motor->m_phase_now_override;
 		for (float j = phase_ovr_tmp; j > phase_ovr_tmp - (2.0 / 3.0) * M_PI;
-				j -= (2.0 * M_PI) / 500.0) {
+		     j -= (2.0 * M_PI) / 500.0)
+		{
 			motor->m_phase_now_override = j;
 			chThdSleepMilliseconds(1);
 		}
 		utils_norm_angle_rad((float*)&motor->m_phase_now_override);
 		chThdSleepMilliseconds(300);
 		float diff = utils_angle_difference_rad(phase_old, motor->m_phase_now_encoder);
-
+		
 		float s, c;
 		sincosf(diff, &s, &c);
 		s_sum += s;
 		c_sum += c;
-
-		if (print) {
+		
+		if (print)
+		{
 			commands_printf("%.2f", (double)(diff * 180.0 / M_PI));
 		}
-
-		if (i > 3 && fabsf(utils_angle_difference_rad(motor->m_phase_now_encoder, first)) < fabsf(diff / 2.0)) {
+		
+		if (i > 3 && fabsf(utils_angle_difference_rad(motor->m_phase_now_encoder, first)) < fabsf(diff / 2.0))
+		{
 			break;
 		}
 	}
-
+	
 	float diff = atan2f(s_sum, c_sum) * 180.0 / M_PI;
 	*inverted = diff < 0.0;
 	*ratio = roundf(((2.0 / 3.0) * 180.0) / fabsf(diff));
-
+	
 	motor->m_conf->foc_encoder_inverted = *inverted;
 	motor->m_conf->foc_encoder_ratio = *ratio;
-
-	if (print) {
+	
+	if (print)
+	{
 		commands_printf("Inversion and ratio detected");
 	}
-
+	
 	// Rotate
-	for (float i = motor->m_phase_now_override;i < 2.0 * M_PI;i += (2.0 * M_PI) / 500.0) {
+	for (float i = motor->m_phase_now_override; i < 2.0 * M_PI; i += (2.0 * M_PI) / 500.0)
+	{
 		motor->m_phase_now_override = i;
 		chThdSleepMilliseconds(2);
 	}
-
-	if (print) {
+	
+	if (print)
+	{
 		commands_printf("Rotated for sync");
 		commands_printf("Enc: %.2f", (double)encoder_read_deg());
 	}
-
+	
 	const int it_ofs = motor->m_conf->foc_encoder_ratio * 3.0;
 	s_sum = 0.0;
 	c_sum = 0.0;
-
-	for (int i = 0;i < it_ofs;i++) {
+	
+	for (int i = 0; i < it_ofs; i++)
+	{
 		float step = (2.0 * M_PI * motor->m_conf->foc_encoder_ratio) / ((float)it_ofs);
 		float override = (float)i * step;
-
-		while (motor->m_phase_now_override != override) {
+		
+		while (motor->m_phase_now_override != override)
+		{
 			utils_step_towards((float*)&motor->m_phase_now_override, override, step / 100.0);
 			chThdSleepMilliseconds(4);
 		}
-
+		
 		chThdSleepMilliseconds(100);
-
+		
 		float angle_diff = utils_angle_difference_rad(motor->m_phase_now_encoder, motor->m_phase_now_override);
 		float s, c;
 		sincosf(angle_diff, &s, &c);
 		s_sum += s;
 		c_sum += c;
-
-		if (print) {
+		
+		if (print)
+		{
 			commands_printf("%.2f", (double)(angle_diff * 180.0 / M_PI));
 		}
 	}
-
-	for (int i = it_ofs;i > 0;i--) {
+	
+	for (int i = it_ofs; i > 0; i--)
+	{
 		float step = (2.0 * M_PI * motor->m_conf->foc_encoder_ratio) / ((float)it_ofs);
 		float override = (float)i * step;
-
-		while (motor->m_phase_now_override != override) {
+		
+		while (motor->m_phase_now_override != override)
+		{
 			utils_step_towards((float*)&motor->m_phase_now_override, override, step / 100.0);
 			chThdSleepMilliseconds(4);
 		}
-
+		
 		chThdSleepMilliseconds(100);
-
+		
 		float angle_diff = utils_angle_difference_rad(motor->m_phase_now_encoder, motor->m_phase_now_override);
 		float s, c;
 		sincosf(angle_diff, &s, &c);
 		s_sum += s;
 		c_sum += c;
-
-		if (print) {
+		
+		if (print)
+		{
 			commands_printf("%.2f", (double)(angle_diff * 180.0 / M_PI));
 		}
 	}
-
+	
 	*offset = atan2f(s_sum, c_sum) * 180.0 / M_PI;
-
-	if (print) {
+	
+	if (print)
+	{
 		commands_printf("Avg: %.2f", (double)*offset);
 	}
-
+	
 	utils_norm_angle(offset);
-
-	if (print) {
+	
+	if (print)
+	{
 		commands_printf("Offset detected");
 	}
-
+	
 	motor->m_id_set = 0.0;
 	motor->m_iq_set = 0.0;
 	motor->m_phase_override = false;
 	motor->m_control_mode = CONTROL_MODE_NONE;
 	motor->m_state = MC_STATE_OFF;
 	stop_pwm_hw(motor);
-
+	
 	// Restore configuration
 	motor->m_conf->foc_encoder_inverted = inverted_old;
 	motor->m_conf->foc_encoder_offset = offset_old;
 	motor->m_conf->foc_encoder_ratio = ratio_old;
-
+	
 	// Enable timeout
 	timeout_configure(tout, tout_c);
-
+	
 	mc_interface_unlock();
 }
 
 /**
- * Lock the motor with a current and sample the voiltage and current to
+ * Lock the motor with a current and sample the voltage and current to
  * calculate the motor resistance.
  *
  * @param current
@@ -1663,66 +1806,72 @@
  * @return
  * The calculated motor resistance.
  */
-float mcpwm_foc_measure_resistance(float current, int samples, bool stop_after) {
+float mcpwm_foc_measure_resistance(float current, int samples, bool stop_after)
+{
 	mc_interface_lock();
-
-	volatile motor_all_state_t *motor = motor_now();
-
+	
+	volatile motor_all_state_t* motor = motor_now();
+	
 	motor->m_phase_override = true;
 	motor->m_phase_now_override = 0.0;
 	motor->m_id_set = 0.0;
 	motor->m_control_mode = CONTROL_MODE_CURRENT;
 	motor->m_state = MC_STATE_RUNNING;
-
+	
 	// Disable timeout
 	systime_t tout = timeout_get_timeout_msec();
 	float tout_c = timeout_get_brake_current();
 	timeout_reset();
 	timeout_configure(60000, 0.0);
-
+	
 	// Ramp up the current slowly
-	while (fabsf(motor->m_iq_set - current) > 0.001) {
+	while (fabsf(motor->m_iq_set - current) > 0.001)
+	{
 		utils_step_towards((float*)&motor->m_iq_set, current, fabsf(current) / 500.0);
 		chThdSleepMilliseconds(1);
 	}
-
+	
 	// Wait for the current to rise and the motor to lock.
 	chThdSleepMilliseconds(100);
-
+	
 	// Sample
 	motor->m_samples.avg_current_tot = 0.0;
 	motor->m_samples.avg_voltage_tot = 0.0;
 	motor->m_samples.sample_num = 0;
-
+	
 	int cnt = 0;
-	while (motor->m_samples.sample_num < samples) {
+	while (motor->m_samples.sample_num < samples)
+	{
 		chThdSleepMilliseconds(1);
 		cnt++;
 		// Timeout
-		if (cnt > 10000) {
+		if (cnt > 10000)
+		{
 			break;
 		}
-
-		if (mc_interface_get_fault() != FAULT_CODE_NONE) {
+		
+		if (mc_interface_get_fault() != FAULT_CODE_NONE)
+		{
 			motor->m_id_set = 0.0;
 			motor->m_iq_set = 0.0;
 			motor->m_phase_override = false;
 			motor->m_control_mode = CONTROL_MODE_NONE;
 			motor->m_state = MC_STATE_OFF;
 			stop_pwm_hw(motor);
-
+			
 			timeout_configure(tout, tout_c);
 			mc_interface_unlock();
-
+			
 			return 0.0;
 		}
 	}
-
+	
 	const float current_avg = motor->m_samples.avg_current_tot / (float)motor->m_samples.sample_num;
 	const float voltage_avg = motor->m_samples.avg_voltage_tot / (float)motor->m_samples.sample_num;
-
+	
 	// Stop
-	if (stop_after) {
+	if (stop_after)
+	{
 		motor->m_id_set = 0.0;
 		motor->m_iq_set = 0.0;
 		motor->m_phase_override = false;
@@ -1730,11 +1879,11 @@
 		motor->m_state = MC_STATE_OFF;
 		stop_pwm_hw(motor);
 	}
-
+	
 	// Enable timeout
 	timeout_configure(tout, tout_c);
 	mc_interface_unlock();
-
+	
 	return (voltage_avg / current_avg) * (2.0 / 3.0);
 }
 
@@ -1753,9 +1902,10 @@
  * @return
  * The average d and q axis inductance in uH.
  */
-float mcpwm_foc_measure_inductance(float duty, int samples, float *curr, float *ld_lq_diff) {
-	volatile motor_all_state_t *motor = motor_now();
-
+float mcpwm_foc_measure_inductance(float duty, int samples, float* curr, float* ld_lq_diff)
+{
+	volatile motor_all_state_t* motor = motor_now();
+	
 	mc_sensor_mode sensor_mode_old = motor->m_conf->sensor_mode;
 	float f_sw_old = motor->m_conf->foc_f_sw;
 	float hfi_voltage_start_old = motor->m_conf->foc_hfi_voltage_start;
@@ -1764,12 +1914,12 @@
 	bool sample_v0_v7_old = motor->m_conf->foc_sample_v0_v7;
 	foc_hfi_samples samples_old = motor->m_conf->foc_hfi_samples;
 	bool sample_high_current_old = motor->m_conf->foc_sample_high_current;
-
+	
 	mc_interface_lock();
 	motor->m_control_mode = CONTROL_MODE_NONE;
 	motor->m_state = MC_STATE_OFF;
 	stop_pwm_hw(motor);
-
+	
 	motor->m_conf->foc_sensor_mode = FOC_SENSOR_MODE_HFI;
 	motor->m_conf->foc_hfi_voltage_start = duty * GET_INPUT_VOLTAGE() * (2.0 / 3.0);
 	motor->m_conf->foc_hfi_voltage_run = duty * GET_INPUT_VOLTAGE() * (2.0 / 3.0);
@@ -1777,41 +1927,46 @@
 	motor->m_conf->foc_sample_v0_v7 = false;
 	motor->m_conf->foc_hfi_samples = HFI_SAMPLES_32;
 	motor->m_conf->foc_sample_high_current = false;
-
+	
 	update_hfi_samples(motor->m_conf->foc_hfi_samples, motor);
-
+	
 	chThdSleepMilliseconds(1);
-
+	
 	timeout_reset();
 	mcpwm_foc_set_duty(0.0);
 	chThdSleepMilliseconds(1);
-
+	
 	int ready_cnt = 0;
-	while (!motor->m_hfi.ready) {
+	while (!motor->m_hfi.ready)
+	{
 		chThdSleepMilliseconds(1);
 		ready_cnt++;
-		if (ready_cnt > 100) {
+		if (ready_cnt > 100)
+		{
 			break;
 		}
 	}
-
-	if (samples < 10) {
+	
+	if (samples < 10)
+	{
 		samples = 10;
 	}
-
+	
 	float l_sum = 0.0;
 	float ld_lq_diff_sum = 0.0;
 	float i_sum = 0.0;
 	float iterations = 0.0;
-
-	for (int i = 0;i < (samples / 10);i++) {
-		if (mc_interface_get_fault() != FAULT_CODE_NONE) {
+	
+	for (int i = 0; i < (samples / 10); i++)
+	{
+		if (mc_interface_get_fault() != FAULT_CODE_NONE)
+		{
 			motor->m_id_set = 0.0;
 			motor->m_iq_set = 0.0;
 			motor->m_control_mode = CONTROL_MODE_NONE;
 			motor->m_state = MC_STATE_OFF;
 			stop_pwm_hw(motor);
-
+			
 			motor->m_conf->foc_sensor_mode = sensor_mode_old;
 			motor->m_conf->foc_f_sw = f_sw_old;
 			motor->m_conf->foc_hfi_voltage_start = hfi_voltage_start_old;
@@ -1820,35 +1975,35 @@
 			motor->m_conf->foc_sample_v0_v7 = sample_v0_v7_old;
 			motor->m_conf->foc_hfi_samples = samples_old;
 			motor->m_conf->foc_sample_high_current = sample_high_current_old;
-
+			
 			update_hfi_samples(motor->m_conf->foc_hfi_samples, motor);
-
+			
 			mc_interface_unlock();
-
+			
 			return 0.0;
 		}
-
+		
 		timeout_reset();
 		mcpwm_foc_set_duty(0.0);
 		chThdSleepMilliseconds(10);
-
+		
 		float real_bin0, imag_bin0;
 		float real_bin2, imag_bin2;
 		float real_bin0_i, imag_bin0_i;
-
+		
 		motor->m_hfi.fft_bin0_func((float*)motor->m_hfi.buffer, &real_bin0, &imag_bin0);
 		motor->m_hfi.fft_bin2_func((float*)motor->m_hfi.buffer, &real_bin2, &imag_bin2);
 		motor->m_hfi.fft_bin0_func((float*)motor->m_hfi.buffer_current, &real_bin0_i, &imag_bin0_i);
-
+		
 		l_sum += real_bin0;
 		ld_lq_diff_sum += 2.0 * sqrtf(SQ(real_bin2) + SQ(imag_bin2));
 		i_sum += real_bin0_i;
-
+		
 		iterations++;
 	}
-
+	
 	mcpwm_foc_set_current(0.0);
-
+	
 	motor->m_conf->foc_sensor_mode = sensor_mode_old;
 	motor->m_conf->foc_f_sw = f_sw_old;
 	motor->m_conf->foc_hfi_voltage_start = hfi_voltage_start_old;
@@ -1857,19 +2012,21 @@
 	motor->m_conf->foc_sample_v0_v7 = sample_v0_v7_old;
 	motor->m_conf->foc_hfi_samples = samples_old;
 	motor->m_conf->foc_sample_high_current = sample_high_current_old;
-
+	
 	update_hfi_samples(motor->m_conf->foc_hfi_samples, motor);
-
+	
 	mc_interface_unlock();
-
-	if (curr) {
+	
+	if (curr)
+	{
 		*curr = i_sum / iterations;
 	}
-
-	if (ld_lq_diff) {
+	
+	if (ld_lq_diff)
+	{
 		*ld_lq_diff = (ld_lq_diff_sum / iterations) * 1e6 * (2.0 / 3.0);
 	}
-
+	
 	return (l_sum / iterations) * 1e6 * (2.0 / 3.0);
 }
 
@@ -1890,18 +2047,21 @@
  * @return
  * The average d and q axis inductance in uH.
  */
-float mcpwm_foc_measure_inductance_current(float curr_goal, int samples, float *curr, float *ld_lq_diff) {
+float mcpwm_foc_measure_inductance_current(float curr_goal, int samples, float* curr, float* ld_lq_diff)
+{
 	float duty_last = 0.0;
-	for (float i = 0.02;i < 0.5;i *= 1.5) {
+	for (float i = 0.02; i < 0.5; i *= 1.5)
+	{
 		float i_tmp;
 		mcpwm_foc_measure_inductance(i, 10, &i_tmp, 0);
-
+		
 		duty_last = i;
-		if (i_tmp >= curr_goal) {
+		if (i_tmp >= curr_goal)
+		{
 			break;
 		}
 	}
-
+	
 	float ind = mcpwm_foc_measure_inductance(duty_last, samples, curr, ld_lq_diff);
 	return ind;
 }
@@ -1918,42 +2078,46 @@
  * @return
  * True if the measurement succeeded, false otherwise.
  */
-bool mcpwm_foc_measure_res_ind(float *res, float *ind) {
-	volatile motor_all_state_t *motor = motor_now();
-
+bool mcpwm_foc_measure_res_ind(float* res, float* ind)
+{
+	volatile motor_all_state_t* motor = motor_now();
+	
 	const float f_sw_old = motor->m_conf->foc_f_sw;
 	const float kp_old = motor->m_conf->foc_current_kp;
 	const float ki_old = motor->m_conf->foc_current_ki;
 	const float res_old = motor->m_conf->foc_motor_r;
-
+	
 	motor->m_conf->foc_current_kp = 0.001;
 	motor->m_conf->foc_current_ki = 1.0;
-
+	
 	float i_last = 0.0;
-	for (float i = 2.0;i < (motor->m_conf->l_current_max / 2.0);i *= 1.5) {
-		if (i > (1.0 / mcpwm_foc_measure_resistance(i, 20, false))) {
+	for (float i = 2.0; i < (motor->m_conf->l_current_max / 2.0); i *= 1.5)
+	{
+		if (i > (1.0 / mcpwm_foc_measure_resistance(i, 20, false)))
+		{
 			i_last = i;
 			break;
 		}
 	}
-
-	if (i_last < 0.01) {
+	
+	if (i_last < 0.01)
+	{
 		i_last = (motor->m_conf->l_current_max / 2.0);
 	}
 
 #ifdef HW_AXIOM_FORCE_HIGH_CURRENT_MEASUREMENTS
 	i_last = (motor->m_conf->l_current_max / 2.0);
 #endif
-
+	
 	*res = mcpwm_foc_measure_resistance(i_last, 200, true);
 	motor->m_conf->foc_motor_r = *res;
 	*ind = mcpwm_foc_measure_inductance_current(i_last, 200, 0, 0);
-
+	
 	motor->m_conf->foc_f_sw = f_sw_old;
 	motor->m_conf->foc_current_kp = kp_old;
 	motor->m_conf->foc_current_ki = ki_old;
 	motor->m_conf->foc_motor_r = res_old;
-
+	
 	return true;
 }
 
@@ -1970,44 +2134,48 @@
  * true: Success
  * false: Something went wrong
  */
-bool mcpwm_foc_hall_detect(float current, uint8_t *hall_table) {
-	volatile motor_all_state_t *motor = motor_now();
-
+bool mcpwm_foc_hall_detect(float current, uint8_t* hall_table)
+{
+	volatile motor_all_state_t* motor = motor_now();
+	
 	mc_interface_lock();
-
+	
 	motor->m_phase_override = true;
 	motor->m_id_set = 0.0;
 	motor->m_iq_set = 0.0;
 	motor->m_control_mode = CONTROL_MODE_CURRENT;
 	motor->m_state = MC_STATE_RUNNING;
-
+	
 	// Disable timeout
 	systime_t tout = timeout_get_timeout_msec();
 	float tout_c = timeout_get_brake_current();
 	timeout_reset();
 	timeout_configure(60000, 0.0);
-
+	
 	// Lock the motor
 	motor->m_phase_now_override = 0;
-
-	for (int i = 0;i < 1000;i++) {
+	
+	for (int i = 0; i < 1000; i++)
+	{
 		motor->m_id_set = (float)i * current / 1000.0;
 		chThdSleepMilliseconds(1);
 	}
-
+	
 	float sin_hall[8];
 	float cos_hall[8];
 	int hall_iterations[8];
 	memset(sin_hall, 0, sizeof(sin_hall));
 	memset(cos_hall, 0, sizeof(cos_hall));
 	memset(hall_iterations, 0, sizeof(hall_iterations));
-
+	
 	// Forwards
-	for (int i = 0;i < 3;i++) {
-		for (int j = 0;j < 360;j++) {
+	for (int i = 0; i < 3; i++)
+	{
+		for (int j = 0; j < 360; j++)
+		{
 			motor->m_phase_now_override = (float)j * M_PI / 180.0;
 			chThdSleepMilliseconds(5);
-
+			
 			int hall = utils_read_hall(motor != &m_motor_1);
 			float s, c;
 			sincosf(motor->m_phase_now_override, &s, &c);
@@ -2016,13 +2184,15 @@
 			hall_iterations[hall]++;
 		}
 	}
-
+	
 	// Reverse
-	for (int i = 0;i < 3;i++) {
-		for (int j = 360;j >= 0;j--) {
+	for (int i = 0; i < 3; i++)
+	{
+		for (int j = 360; j >= 0; j--)
+		{
 			motor->m_phase_now_override = (float)j * M_PI / 180.0;
 			chThdSleepMilliseconds(5);
-
+			
 			int hall = utils_read_hall(motor != &m_motor_1);
 			float s, c;
 			sincosf(motor->m_phase_now_override, &s, &c);
@@ -2031,35 +2201,40 @@
 			hall_iterations[hall]++;
 		}
 	}
-
+	
 	motor->m_id_set = 0.0;
 	motor->m_iq_set = 0.0;
 	motor->m_phase_override = false;
 	motor->m_control_mode = CONTROL_MODE_NONE;
 	motor->m_state = MC_STATE_OFF;
 	stop_pwm_hw(motor);
-
+	
 	// Enable timeout
 	timeout_configure(tout, tout_c);
-
+	
 	int fails = 0;
-	for(int i = 0;i < 8;i++) {
-		if (hall_iterations[i] > 30) {
+	for (int i = 0; i < 8; i++)
+	{
+		if (hall_iterations[i] > 30)
+		{
 			float ang = atan2f(sin_hall[i], cos_hall[i]) * 180.0 / M_PI;
 			utils_norm_angle(&ang);
 			hall_table[i] = (uint8_t)(ang * 200.0 / 360.0);
-		} else {
+		}
+		else
+		{
 			hall_table[i] = 255;
 			fails++;
 		}
 	}
-
+	
 	mc_interface_unlock();
-
+	
 	return fails == 2;
 }
 
-void mcpwm_foc_print_state(void) {
+void mcpwm_foc_print_state(void)
+{
 	commands_printf("Mod d:        %.2f", (double)motor_now()->m_motor_state.mod_d);
 	commands_printf("Mod q:        %.2f", (double)motor_now()->m_motor_state.mod_q);
 	commands_printf("Duty:         %.2f", (double)motor_now()->m_motor_state.duty_now);
@@ -2082,35 +2257,43 @@
 	commands_printf("vq_int:       %.2f", (double)motor_now()->m_motor_state.vq_int);
 }
 
-float mcpwm_foc_get_last_adc_isr_duration(void) {
+float mcpwm_foc_get_last_adc_isr_duration(void)
+{
 	return m_last_adc_isr_duration;
 }
 
-void mcpwm_foc_tim_sample_int_handler(void) {
-	if (m_init_done) {
+void mcpwm_foc_tim_sample_int_handler(void)
+{
+	if (m_init_done)
+	{
 		// Generate COM event here for synchronization
 		TIM_GenerateEvent(TIM1, TIM_EventSource_COM);
 		TIM_GenerateEvent(TIM8, TIM_EventSource_COM);
-
+		
 		virtual_motor_int_handler(
-				m_motor_1.m_motor_state.v_alpha,
-				m_motor_1.m_motor_state.v_beta);
+			m_motor_1.m_motor_state.v_alpha,
+			m_motor_1.m_motor_state.v_beta
+		);
 	}
 }
 
-void mcpwm_foc_adc_int_handler(void *p, uint32_t flags) {
+void mcpwm_foc_adc_int_handler(void* p, uint32_t flags)
+{
 	(void)p;
 	(void)flags;
-
+	
 	static int skip = 0;
-	if (++skip == FOC_CONTROL_LOOP_FREQ_DIVIDER) {
+	if (++skip == FOC_CONTROL_LOOP_FREQ_DIVIDER)
+	{
 		skip = 0;
-	} else {
+	}
+	else
+	{
 		return;
 	}
-
+	
 	uint32_t t_start = timer_time_now();
-
+	
 	bool is_v7 = !(TIM1->CR1 & TIM_CR1_DIR);
 	int norm_curr_ofs = 0;
 
@@ -2124,17 +2307,18 @@
 	volatile TIM_TypeDef *tim = is_second_motor ? TIM8 : TIM1;
 #endif
 #else
-	volatile motor_all_state_t *motor_other = &m_motor_1;
-	volatile motor_all_state_t *motor_now = &m_motor_1;;
+	volatile motor_all_state_t* motor_other = &m_motor_1;
+	volatile motor_all_state_t* motor_now = &m_motor_1;
 	m_isr_motor = 1;
 #ifdef HW_HAS_3_SHUNTS
-	volatile TIM_TypeDef *tim = TIM1;
+	volatile TIM_TypeDef* tim = TIM1;
 #endif
 #endif
-
-	volatile mc_configuration *conf_now = motor_now->m_conf;
-
-	if (motor_other->m_duty_next_set) {
+	
+	volatile mc_configuration* conf_now = motor_now->m_conf;
+	
+	if (motor_other->m_duty_next_set)
+	{
 		motor_other->m_duty_next_set = false;
 #ifdef HW_HAS_DUAL_MOTORS
 		if (is_second_motor) {
@@ -2152,7 +2336,8 @@
 
 #ifndef HW_HAS_DUAL_MOTORS
 #ifdef HW_HAS_PHASE_SHUNTS
-	if (!conf_now->foc_sample_v0_v7 && is_v7) {
+	if (!conf_now->foc_sample_v0_v7 && is_v7)
+	{
 		return;
 	}
 #else
@@ -2161,7 +2346,7 @@
 	}
 #endif
 #endif
-
+	
 	// Reset the watchdog
 	timeout_feed_WDT(THREAD_MCPWM);
 
@@ -2200,22 +2385,22 @@
 #endif
 #endif
 #endif
-
+	
 	motor_now->m_curr_sum[0] += curr0;
 	motor_now->m_curr_sum[1] += curr1;
 #ifdef HW_HAS_3_SHUNTS
 	motor_now->m_curr_sum[2] += curr2;
 #endif
-
+	
 	curr0 -= motor_now->m_curr_ofs[0];
 	curr1 -= motor_now->m_curr_ofs[1];
 #ifdef HW_HAS_3_SHUNTS
 	curr2 -= motor_now->m_curr_ofs[2];
 	motor_now->m_curr_unbalance = curr0 + curr1 + curr2;
 #endif
-
+	
 	motor_now->m_curr_samples++;
-
+	
 	ADC_curr_norm_value[0 + norm_curr_ofs] = curr0;
 	ADC_curr_norm_value[1 + norm_curr_ofs] = curr1;
 #ifdef HW_HAS_3_SHUNTS
@@ -2223,51 +2408,89 @@
 #else
 	ADC_curr_norm_value[2 + norm_curr_ofs] = -(ADC_curr_norm_value[0] + ADC_curr_norm_value[1]);
 #endif
-
+	
 	// Use the best current samples depending on the modulation state.
 #ifdef HW_HAS_3_SHUNTS
-	if (conf_now->foc_sample_high_current) {
+	if (conf_now->foc_sample_high_current)
+	{
 		// High current sampling mode. Choose the lower currents to derive the highest one
 		// in order to be able to measure higher currents.
 		const float i0_abs = fabsf(ADC_curr_norm_value[0 + norm_curr_ofs]);
 		const float i1_abs = fabsf(ADC_curr_norm_value[1 + norm_curr_ofs]);
 		const float i2_abs = fabsf(ADC_curr_norm_value[2 + norm_curr_ofs]);
-
-		if (i0_abs > i1_abs && i0_abs > i2_abs) {
-			ADC_curr_norm_value[0 + norm_curr_ofs] = -(ADC_curr_norm_value[1 + norm_curr_ofs] + ADC_curr_norm_value[2 + norm_curr_ofs]);
-		} else if (i1_abs > i0_abs && i1_abs > i2_abs) {
-			ADC_curr_norm_value[1 + norm_curr_ofs] = -(ADC_curr_norm_value[0 + norm_curr_ofs] + ADC_curr_norm_value[2 + norm_curr_ofs]);
-		} else if (i2_abs > i0_abs && i2_abs > i1_abs) {
-			ADC_curr_norm_value[2 + norm_curr_ofs] = -(ADC_curr_norm_value[0 + norm_curr_ofs] + ADC_curr_norm_value[1 + norm_curr_ofs]);
+		
+		if (i0_abs > i1_abs && i0_abs > i2_abs)
+		{
+			ADC_curr_norm_value[0 + norm_curr_ofs] =
+				-(ADC_curr_norm_value[1 + norm_curr_ofs] + ADC_curr_norm_value[2 + norm_curr_ofs]);
+		}
+		else if (i1_abs > i0_abs && i1_abs > i2_abs)
+		{
+			ADC_curr_norm_value[1 + norm_curr_ofs] =
+				-(ADC_curr_norm_value[0 + norm_curr_ofs] + ADC_curr_norm_value[2 + norm_curr_ofs]);
 		}
-	} else {
+		else if (i2_abs > i0_abs && i2_abs > i1_abs)
+		{
+			ADC_curr_norm_value[2 + norm_curr_ofs] =
+				-(ADC_curr_norm_value[0 + norm_curr_ofs] + ADC_curr_norm_value[1 + norm_curr_ofs]);
+		}
+	}
+	else
+	{
 #ifdef HW_HAS_PHASE_SHUNTS
-		if (is_v7) {
-			if (tim->CCR1 > 500 && tim->CCR2 > 500) {
+		if (is_v7)
+		{
+			if (tim->CCR1 > 500 && tim->CCR2 > 500)
+			{
 				// Use the same 2 shunts on low modulation, as that will avoid jumps in the current reading.
 				// This is especially important when using HFI.
-				ADC_curr_norm_value[2 + norm_curr_ofs] = -(ADC_curr_norm_value[0 + norm_curr_ofs] + ADC_curr_norm_value[1 + norm_curr_ofs]);
-			} else {
-				if (tim->CCR1 < tim->CCR2 && tim->CCR1 < tim->CCR3) {
-					ADC_curr_norm_value[0 + norm_curr_ofs] = -(ADC_curr_norm_value[1 + norm_curr_ofs] + ADC_curr_norm_value[2 + norm_curr_ofs]);
-				} else if (tim->CCR2 < tim->CCR1 && tim->CCR2 < tim->CCR3) {
-					ADC_curr_norm_value[1 + norm_curr_ofs] = -(ADC_curr_norm_value[0 + norm_curr_ofs] + ADC_curr_norm_value[2 + norm_curr_ofs]);
-				} else if (tim->CCR3 < tim->CCR1 && tim->CCR3 < tim->CCR2) {
-					ADC_curr_norm_value[2 + norm_curr_ofs] = -(ADC_curr_norm_value[0 + norm_curr_ofs] + ADC_curr_norm_value[1 + norm_curr_ofs]);
+				ADC_curr_norm_value[2 + norm_curr_ofs] =
+					-(ADC_curr_norm_value[0 + norm_curr_ofs] + ADC_curr_norm_value[1 + norm_curr_ofs]);
+			}
+			else
+			{
+				if (tim->CCR1 < tim->CCR2 && tim->CCR1 < tim->CCR3)
+				{
+					ADC_curr_norm_value[0 + norm_curr_ofs] =
+						-(ADC_curr_norm_value[1 + norm_curr_ofs] + ADC_curr_norm_value[2 + norm_curr_ofs]);
+				}
+				else if (tim->CCR2 < tim->CCR1 && tim->CCR2 < tim->CCR3)
+				{
+					ADC_curr_norm_value[1 + norm_curr_ofs] =
+						-(ADC_curr_norm_value[0 + norm_curr_ofs] + ADC_curr_norm_value[2 + norm_curr_ofs]);
+				}
+				else if (tim->CCR3 < tim->CCR1 && tim->CCR3 < tim->CCR2)
+				{
+					ADC_curr_norm_value[2 + norm_curr_ofs] =
+						-(ADC_curr_norm_value[0 + norm_curr_ofs] + ADC_curr_norm_value[1 + norm_curr_ofs]);
 				}
 			}
-		} else {
-			if (tim->CCR1 < (tim->ARR - 500) && tim->CCR2 < (tim->ARR - 500)) {
+		}
+		else
+		{
+			if (tim->CCR1 < (tim->ARR - 500) && tim->CCR2 < (tim->ARR - 500))
+			{
 				// Use the same 2 shunts on low modulation, as that will avoid jumps in the current reading.
 				// This is especially important when using HFI.
-				ADC_curr_norm_value[2 + norm_curr_ofs] = -(ADC_curr_norm_value[0 + norm_curr_ofs] + ADC_curr_norm_value[1 + norm_curr_ofs]);
-			} else {
-				if (tim->CCR1 > tim->CCR2 && tim->CCR1 > tim->CCR3) {
-					ADC_curr_norm_value[0 + norm_curr_ofs] = -(ADC_curr_norm_value[1 + norm_curr_ofs] + ADC_curr_norm_value[2 + norm_curr_ofs]);
-				} else if (tim->CCR2 > tim->CCR1 && tim->CCR2 > tim->CCR3) {
-					ADC_curr_norm_value[1 + norm_curr_ofs] = -(ADC_curr_norm_value[0 + norm_curr_ofs] + ADC_curr_norm_value[2 + norm_curr_ofs]);
-				} else if (tim->CCR3 > tim->CCR1 && tim->CCR3 > tim->CCR2) {
-					ADC_curr_norm_value[2 + norm_curr_ofs] = -(ADC_curr_norm_value[0 + norm_curr_ofs] + ADC_curr_norm_value[1 + norm_curr_ofs]);
+				ADC_curr_norm_value[2 + norm_curr_ofs] =
+					-(ADC_curr_norm_value[0 + norm_curr_ofs] + ADC_curr_norm_value[1 + norm_curr_ofs]);
+			}
+			else
+			{
+				if (tim->CCR1 > tim->CCR2 && tim->CCR1 > tim->CCR3)
+				{
+					ADC_curr_norm_value[0 + norm_curr_ofs] =
+						-(ADC_curr_norm_value[1 + norm_curr_ofs] + ADC_curr_norm_value[2 + norm_curr_ofs]);
+				}
+				else if (tim->CCR2 > tim->CCR1 && tim->CCR2 > tim->CCR3)
+				{
+					ADC_curr_norm_value[1 + norm_curr_ofs] =
+						-(ADC_curr_norm_value[0 + norm_curr_ofs] + ADC_curr_norm_value[2 + norm_curr_ofs]);
+				}
+				else if (tim->CCR3 > tim->CCR1 && tim->CCR3 > tim->CCR2)
+				{
+					ADC_curr_norm_value[2 + norm_curr_ofs] =
+						-(ADC_curr_norm_value[0 + norm_curr_ofs] + ADC_curr_norm_value[1 + norm_curr_ofs]);
 				}
 			}
 		}
@@ -2288,39 +2511,47 @@
 #endif
 	}
 #endif
-
+	
 	float ia = (float)ADC_curr_norm_value[0 + norm_curr_ofs] * FAC_CURRENT;
 	float ib = (float)ADC_curr_norm_value[1 + norm_curr_ofs] * FAC_CURRENT;
 //	float ic = -(ia + ib);
 
 #ifdef HW_HAS_PHASE_SHUNTS
 	float dt;
-	if (conf_now->foc_sample_v0_v7) {
+	if (conf_now->foc_sample_v0_v7)
+	{
 		dt = 1.0 / conf_now->foc_f_sw;
-	} else {
+	}
+	else
+	{
 		dt = 1.0 / (conf_now->foc_f_sw / 2.0);
 	}
 #else
 	float dt = 1.0 / (conf_now->foc_f_sw / 2.0);
 #endif
-
+	
 	// This has to be done for the skip function to have any chance at working with the
 	// observer and control loops.
 	// TODO: Test this.
 	dt /= (float)FOC_CONTROL_LOOP_FREQ_DIVIDER;
-
+	
 	UTILS_LP_FAST(motor_now->m_motor_state.v_bus, GET_INPUT_VOLTAGE(), 0.1);
-
+	
 	float enc_ang = 0;
-	if (encoder_is_configured()) {
-		if (virtual_motor_is_connected()){
+	if (encoder_is_configured())
+	{
+		if (virtual_motor_is_connected())
+		{
 			enc_ang = virtual_motor_get_angle_deg();
-		} else {
+		}
+		else
+		{
 			enc_ang = encoder_read_deg();
 		}
-
+		
 		float phase_tmp = enc_ang;
-		if (conf_now->foc_encoder_inverted) {
+		if (conf_now->foc_encoder_inverted)
+		{
 			phase_tmp = 360.0 - phase_tmp;
 		}
 		phase_tmp *= conf_now->foc_encoder_ratio;
@@ -2328,229 +2559,298 @@
 		utils_norm_angle((float*)&phase_tmp);
 		motor_now->m_phase_now_encoder = phase_tmp * (M_PI / 180.0);
 	}
-
+	
 	const float phase_diff = utils_angle_difference_rad(motor_now->m_motor_state.phase, motor_now->m_phase_before);
 	motor_now->m_phase_before = motor_now->m_motor_state.phase;
-
-	if (motor_now->m_state == MC_STATE_RUNNING) {
+	
+	if (motor_now->m_state == MC_STATE_RUNNING)
+	{
 		// Clarke transform assuming balanced currents
 		motor_now->m_motor_state.i_alpha = ia;
 		motor_now->m_motor_state.i_beta = ONE_BY_SQRT3 * ia + TWO_BY_SQRT3 * ib;
-
+		
 		// Full Clarke transform in case there are current offsets
 //		m_motor_state.i_alpha = (2.0 / 3.0) * ia - (1.0 / 3.0) * ib - (1.0 / 3.0) * ic;
 //		m_motor_state.i_beta = ONE_BY_SQRT3 * ib - ONE_BY_SQRT3 * ic;
-
+		
 		const float duty_abs = fabsf(motor_now->m_motor_state.duty_now);
 		float id_set_tmp = motor_now->m_id_set;
 		float iq_set_tmp = motor_now->m_iq_set;
 		motor_now->m_motor_state.max_duty = conf_now->l_max_duty;
-
+		
 		UTILS_LP_FAST(motor_now->m_duty_filtered, motor_now->m_motor_state.duty_now, 0.1);
 		utils_truncate_number((float*)&motor_now->m_duty_filtered, -1.0, 1.0);
-
+		
 		float duty_set = motor_now->m_duty_cycle_set;
 		bool control_duty = motor_now->m_control_mode == CONTROL_MODE_DUTY ||
-				motor_now->m_control_mode == CONTROL_MODE_OPENLOOP_DUTY ||
-				motor_now->m_control_mode == CONTROL_MODE_OPENLOOP_DUTY_PHASE;
-
+		                    motor_now->m_control_mode == CONTROL_MODE_OPENLOOP_DUTY ||
+		                    motor_now->m_control_mode == CONTROL_MODE_OPENLOOP_DUTY_PHASE;
+		
 		// When the modulation is low in brake mode and the set brake current
 		// cannot be reached, short all phases to get more braking without
 		// applying active braking. Use a bit of hysteresis when leaving
 		// the shorted mode.
 		if (motor_now->m_control_mode == CONTROL_MODE_CURRENT_BRAKE &&
-				fabsf(motor_now->m_duty_filtered) < conf_now->l_min_duty * 1.5 &&
-				(motor_now->m_motor_state.i_abs * (motor_now->m_was_full_brake ? 1.0 : 1.5)) < fabsf(motor_now->m_iq_set)) {
+		    fabsf(motor_now->m_duty_filtered) < conf_now->l_min_duty * 1.5 &&
+		    (motor_now->m_motor_state.i_abs * (motor_now->m_was_full_brake ? 1.0 : 1.5)) < fabsf(motor_now->m_iq_set))
+		{
 			control_duty = true;
 			duty_set = 0.0;
 			motor_now->m_was_full_brake = true;
-		} else {
+		}
+		else
+		{
 			motor_now->m_was_full_brake = false;
 		}
-
+		
 		// Brake when set ERPM is below min ERPM
 		if (motor_now->m_control_mode == CONTROL_MODE_SPEED &&
-				fabsf(motor_now->m_speed_pid_set_rpm) < conf_now->s_pid_min_erpm) {
+		    fabsf(motor_now->m_speed_pid_set_rpm) < conf_now->s_pid_min_erpm)
+		{
 			control_duty = true;
 			duty_set = 0.0;
 		}
-
+		
 		// Reset integrator when leaving duty cycle mode, as the windup protection is not too fast. Making
 		// better windup protection is probably better, but not easy.
-		if (!control_duty && motor_now->m_was_control_duty) {
+		if (!control_duty && motor_now->m_was_control_duty)
+		{
 			motor_now->m_motor_state.vq_int = motor_now->m_motor_state.vq;
 			if (conf_now->foc_cc_decoupling == FOC_CC_DECOUPLING_BEMF ||
-					conf_now->foc_cc_decoupling == FOC_CC_DECOUPLING_CROSS_BEMF) {
-				motor_now->m_motor_state.vq_int -= motor_now->m_motor_state.speed_rad_s * conf_now->foc_motor_flux_linkage;
+			    conf_now->foc_cc_decoupling == FOC_CC_DECOUPLING_CROSS_BEMF)
+			{
+				motor_now->m_motor_state.vq_int
+					-=
+					motor_now->m_motor_state.speed_rad_s * conf_now->foc_motor_flux_linkage;
 			}
 		}
 		motor_now->m_was_control_duty = control_duty;
-
-		if (control_duty) {
+		
+		if (control_duty)
+		{
 			// Duty cycle control
 			if (fabsf(duty_set) < (duty_abs - 0.05) ||
-					(SIGN(motor_now->m_motor_state.vq) * motor_now->m_motor_state.iq) < conf_now->lo_current_min) {
+			    (SIGN(motor_now->m_motor_state.vq) * motor_now->m_motor_state.iq) < conf_now->lo_current_min)
+			{
 				// Truncating the duty cycle here would be dangerous, so run a PID controller.
-
+				
 				// Compensation for supply voltage variations
 				float scale = 1.0 / GET_INPUT_VOLTAGE();
-
+				
 				// Compute error
 				float error = duty_set - motor_now->m_motor_state.duty_now;
-
+				
 				// Compute parameters
 				float p_term = error * conf_now->foc_duty_dowmramp_kp * scale;
 				motor_now->m_duty_i_term += error * (conf_now->foc_duty_dowmramp_ki * dt) * scale;
-
+				
 				// I-term wind-up protection
 				utils_truncate_number((float*)&motor_now->m_duty_i_term, -1.0, 1.0);
-
+				
 				// Calculate output
 				float output = p_term + motor_now->m_duty_i_term;
 				utils_truncate_number(&output, -1.0, 1.0);
 				iq_set_tmp = output * conf_now->lo_current_max;
-			} else {
+			}
+			else
+			{
 				// If the duty cycle is less than or equal to the set duty cycle just limit
 				// the modulation and use the maximum allowed current.
 				motor_now->m_duty_i_term = 0.0;
 				motor_now->m_motor_state.max_duty = duty_set;
-				if (duty_set > 0.0) {
+				if (duty_set > 0.0)
+				{
 					iq_set_tmp = conf_now->lo_current_max;
-				} else {
+				}
+				else
+				{
 					iq_set_tmp = -conf_now->lo_current_max;
 				}
 			}
-		} else if (motor_now->m_control_mode == CONTROL_MODE_CURRENT_BRAKE) {
+		}
+		else if (motor_now->m_control_mode == CONTROL_MODE_CURRENT_BRAKE)
+		{
 			// Braking
 			iq_set_tmp = fabsf(iq_set_tmp);
-
-			if (phase_diff > 0.0) {
+			
+			if (phase_diff > 0.0)
+			{
 				iq_set_tmp = -iq_set_tmp;
-			} else if (phase_diff == 0.0) {
+			}
+			else if (phase_diff == 0.0)
+			{
 				iq_set_tmp = 0.0;
 			}
 		}
-
+		
 		// Run observer
-		if (!motor_now->m_phase_override) {
-			observer_update(motor_now->m_motor_state.v_alpha, motor_now->m_motor_state.v_beta,
-							motor_now->m_motor_state.i_alpha, motor_now->m_motor_state.i_beta, dt,
-							&motor_now->m_observer_x1, &motor_now->m_observer_x2, &motor_now->m_phase_now_observer, motor_now);
+		if (!motor_now->m_phase_override)
+		{
+			observer_update(
+				motor_now->m_motor_state.v_alpha, motor_now->m_motor_state.v_beta,
+				motor_now->m_motor_state.i_alpha, motor_now->m_motor_state.i_beta, dt,
+				&motor_now->m_observer_x1, &motor_now->m_observer_x2, &motor_now->m_phase_now_observer, motor_now
+			);
 			motor_now->m_phase_now_observer += motor_now->m_pll_speed * dt * 0.5;
 			utils_norm_angle_rad((float*)&motor_now->m_phase_now_observer);
 		}
-
-		switch (conf_now->foc_sensor_mode) {
+		
+		switch (conf_now->foc_sensor_mode)
+		{
 		case FOC_SENSOR_MODE_ENCODER:
-			if (encoder_index_found()) {
+			if (encoder_index_found())
+			{
 				motor_now->m_motor_state.phase = correct_encoder(
-						motor_now->m_phase_now_observer,
-						motor_now->m_phase_now_encoder,
-						motor_now->m_speed_est_fast,
-						conf_now->foc_sl_erpm,
-						motor_now);
-			} else {
+					motor_now->m_phase_now_observer,
+					motor_now->m_phase_now_encoder,
+					motor_now->m_speed_est_fast,
+					conf_now->foc_sl_erpm,
+					motor_now
+				);
+			}
+			else
+			{
 				// Rotate the motor in open loop if the index isn't found.
 				motor_now->m_motor_state.phase = motor_now->m_phase_now_encoder_no_index;
 			}
-
-			if (!motor_now->m_phase_override) {
+			
+			if (!motor_now->m_phase_override)
+			{
 				id_set_tmp = 0.0;
 			}
 			break;
 		case FOC_SENSOR_MODE_HALL:
 			motor_now->m_phase_now_observer = correct_hall(motor_now->m_phase_now_observer, dt, motor_now);
 			motor_now->m_motor_state.phase = motor_now->m_phase_now_observer;
-
-			if (!motor_now->m_phase_override) {
+			
+			if (!motor_now->m_phase_override)
+			{
 				id_set_tmp = 0.0;
 			}
 			break;
 		case FOC_SENSOR_MODE_SENSORLESS:
-			if (motor_now->m_phase_observer_override) {
+			if (motor_now->m_phase_observer_override)
+			{
 				motor_now->m_motor_state.phase = motor_now->m_phase_now_observer_override;
-			} else {
+			}
+			else
+			{
 				motor_now->m_motor_state.phase = motor_now->m_phase_now_observer;
 			}
-
+			
 			// Inject D axis current at low speed to make the observer track
 			// better. This does not seem to be necessary with dead time
 			// compensation.
 			// Note: this is done at high rate prevent noise.
-			if (!motor_now->m_phase_override) {
-				if (duty_abs < conf_now->foc_sl_d_current_duty) {
-					id_set_tmp = utils_map(duty_abs, 0.0, conf_now->foc_sl_d_current_duty,
-										   fabsf(motor_now->m_motor_state.iq_target) * conf_now->foc_sl_d_current_factor, 0.0);
-				} else {
+			if (!motor_now->m_phase_override)
+			{
+				if (duty_abs < conf_now->foc_sl_d_current_duty)
+				{
+					id_set_tmp = utils_map(
+						duty_abs, 0.0, conf_now->foc_sl_d_current_duty,
+						fabsf(motor_now->m_motor_state.iq_target) * conf_now->foc_sl_d_current_factor, 0.0
+					);
+				}
+				else
+				{
 					id_set_tmp = 0.0;
 				}
 			}
 			break;
-
+		
 		case FOC_SENSOR_MODE_HFI:
-			if (fabsf(motor_now->m_speed_est_fast * (60.0 / (2.0 * M_PI))) > conf_now->foc_sl_erpm_hfi) {
+			if (fabsf(motor_now->m_speed_est_fast * (60.0 / (2.0 * M_PI))) > conf_now->foc_sl_erpm_hfi)
+			{
 				motor_now->m_hfi.observer_zero_time = 0;
-			} else {
+			}
+			else
+			{
 				motor_now->m_hfi.observer_zero_time += dt;
 			}
-
-			if (motor_now->m_hfi.observer_zero_time < conf_now->foc_hfi_obs_ovr_sec) {
+			
+			if (motor_now->m_hfi.observer_zero_time < conf_now->foc_hfi_obs_ovr_sec)
+			{
 				motor_now->m_hfi.angle = motor_now->m_phase_now_observer;
 			}
-
+			
 			motor_now->m_motor_state.phase = correct_encoder(
-					motor_now->m_phase_now_observer,
-					motor_now->m_hfi.angle,
-					motor_now->m_speed_est_fast,
-					conf_now->foc_sl_erpm_hfi,
-					motor_now);
-
-			if (!motor_now->m_phase_override) {
+				motor_now->m_phase_now_observer,
+				motor_now->m_hfi.angle,
+				motor_now->m_speed_est_fast,
+				conf_now->foc_sl_erpm_hfi,
+				motor_now
+			);
+			
+			if (!motor_now->m_phase_override)
+			{
 				id_set_tmp = 0.0;
 			}
 			break;
 		}
-
-		if (motor_now->m_control_mode == CONTROL_MODE_HANDBRAKE) {
+		
+		if (motor_now->m_control_mode == CONTROL_MODE_HANDBRAKE)
+		{
 			// Force the phase to 0 in handbrake mode so that the current simply locks the rotor.
 			motor_now->m_motor_state.phase = 0.0;
-		} else if (motor_now->m_control_mode == CONTROL_MODE_OPENLOOP ||
-				motor_now->m_control_mode == CONTROL_MODE_OPENLOOP_DUTY) {
+		}
+		else if (motor_now->m_control_mode == CONTROL_MODE_OPENLOOP ||
+		         motor_now->m_control_mode == CONTROL_MODE_OPENLOOP_DUTY)
+		{
 			motor_now->m_openloop_angle += dt * motor_now->m_openloop_speed;
 			utils_norm_angle_rad((float*)&motor_now->m_openloop_angle);
 			motor_now->m_motor_state.phase = motor_now->m_openloop_angle;
-		} else if (motor_now->m_control_mode == CONTROL_MODE_OPENLOOP_PHASE ||
-				motor_now->m_control_mode == CONTROL_MODE_OPENLOOP_DUTY_PHASE) {
+		}
+		else if (motor_now->m_control_mode == CONTROL_MODE_OPENLOOP_PHASE ||
+		         motor_now->m_control_mode == CONTROL_MODE_OPENLOOP_DUTY_PHASE)
+		{
 			motor_now->m_motor_state.phase = motor_now->m_openloop_phase;
 		}
-
-		if (motor_now->m_phase_override) {
+		
+		if (motor_now->m_phase_override)
+		{
 			motor_now->m_motor_state.phase = motor_now->m_phase_now_override;
 		}
-
+		
 		// Apply current limits
 		// TODO: Consider D axis current for the input current as well.
 		const float mod_q = motor_now->m_motor_state.mod_q;
-		if (mod_q > 0.001) {
-			utils_truncate_number(&iq_set_tmp, conf_now->lo_in_current_min / mod_q, conf_now->lo_in_current_max / mod_q);
-		} else if (mod_q < -0.001) {
-			utils_truncate_number(&iq_set_tmp, conf_now->lo_in_current_max / mod_q, conf_now->lo_in_current_min / mod_q);
+		if (mod_q > 0.001)
+		{
+			utils_truncate_number(
+				&iq_set_tmp,
+				conf_now->lo_in_current_min / mod_q,
+				conf_now->lo_in_current_max / mod_q
+			);
+		}
+		else if (mod_q < -0.001)
+		{
+			utils_truncate_number(
+				&iq_set_tmp,
+				conf_now->lo_in_current_max / mod_q,
+				conf_now->lo_in_current_min / mod_q
+			);
 		}
-
-		if (mod_q > 0.0) {
+		
+		if (mod_q > 0.0)
+		{
 			utils_truncate_number(&iq_set_tmp, conf_now->lo_current_min, conf_now->lo_current_max);
-		} else {
+		}
+		else
+		{
 			utils_truncate_number(&iq_set_tmp, -conf_now->lo_current_max, -conf_now->lo_current_min);
 		}
-
-		utils_saturate_vector_2d(&id_set_tmp, &iq_set_tmp,
-								 utils_max_abs(conf_now->lo_current_max, conf_now->lo_current_min));
-
+		
+		utils_saturate_vector_2d(
+			&id_set_tmp, &iq_set_tmp,
+			utils_max_abs(conf_now->lo_current_max, conf_now->lo_current_min));
+		
 		motor_now->m_motor_state.id_target = id_set_tmp;
 		motor_now->m_motor_state.iq_target = iq_set_tmp;
-
+		
 		control_current(motor_now, dt);
-	} else {
+	}
+	else
+	{
 		// The current is 0 when the motor is undriven
 		motor_now->m_motor_state.i_alpha = 0.0;
 		motor_now->m_motor_state.i_beta = 0.0;
@@ -2561,7 +2861,7 @@
 		motor_now->m_motor_state.i_bus = 0.0;
 		motor_now->m_motor_state.i_abs = 0.0;
 		motor_now->m_motor_state.i_abs_filter = 0.0;
-
+		
 		// Track back emf
 #ifdef HW_HAS_DUAL_MOTORS
 #ifdef HW_HAS_3_SHUNTS
@@ -2598,7 +2898,7 @@
 		float Vc = ADC_VOLTS(ADC_IND_SENS2) * ((VIN_R1 + VIN_R2) / VIN_R2);
 #endif
 #endif
-
+		
 		// Full Clarke transform (no balanced voltages)
 		motor_now->m_motor_state.v_alpha = (2.0 / 3.0) * Va - (1.0 / 3.0) * Vb - (1.0 / 3.0) * Vc;
 		motor_now->m_motor_state.v_beta = ONE_BY_SQRT3 * Vb - ONE_BY_SQRT3 * Vc;
@@ -2615,25 +2915,31 @@
 		motor_now->m_motor_state.v_alpha *= ONE_BY_SQRT3;
 		motor_now->m_motor_state.v_beta *= ONE_BY_SQRT3;
 #endif
-
+		
 		// Run observer
-		observer_update(motor_now->m_motor_state.v_alpha, motor_now->m_motor_state.v_beta,
-						motor_now->m_motor_state.i_alpha, motor_now->m_motor_state.i_beta, dt,
-						&motor_now->m_observer_x1, &motor_now->m_observer_x2, 0, motor_now);
-		motor_now->m_phase_now_observer = utils_fast_atan2(motor_now->m_x2_prev + motor_now->m_observer_x2,
-														   motor_now->m_x1_prev + motor_now->m_observer_x1);
-
+		observer_update(
+			motor_now->m_motor_state.v_alpha, motor_now->m_motor_state.v_beta,
+			motor_now->m_motor_state.i_alpha, motor_now->m_motor_state.i_beta, dt,
+			&motor_now->m_observer_x1, &motor_now->m_observer_x2, 0, motor_now
+		);
+		motor_now->m_phase_now_observer = utils_fast_atan2(
+			motor_now->m_x2_prev + motor_now->m_observer_x2,
+			motor_now->m_x1_prev + motor_now->m_observer_x1
+		);
+		
 		motor_now->m_x1_prev = motor_now->m_observer_x1;
 		motor_now->m_x2_prev = motor_now->m_observer_x2;
-
-		switch (conf_now->foc_sensor_mode) {
+		
+		switch (conf_now->foc_sensor_mode)
+		{
 		case FOC_SENSOR_MODE_ENCODER:
 			motor_now->m_motor_state.phase = correct_encoder(
-					motor_now->m_phase_now_observer,
-					motor_now->m_phase_now_encoder,
-					motor_now->m_speed_est_fast,
-					conf_now->foc_sl_erpm,
-					motor_now);
+				motor_now->m_phase_now_observer,
+				motor_now->m_phase_now_encoder,
+				motor_now->m_speed_est_fast,
+				conf_now->foc_sl_erpm,
+				motor_now
+			);
 			break;
 		case FOC_SENSOR_MODE_HALL:
 			motor_now->m_phase_now_observer = correct_hall(motor_now->m_phase_now_observer, dt, motor_now);
@@ -2642,14 +2948,17 @@
 		case FOC_SENSOR_MODE_SENSORLESS:
 			motor_now->m_motor_state.phase = motor_now->m_phase_now_observer;
 			break;
-		case FOC_SENSOR_MODE_HFI: {
+		case FOC_SENSOR_MODE_HFI:
+		{
 			motor_now->m_motor_state.phase = motor_now->m_phase_now_observer;
-			if (fabsf(motor_now->m_pll_speed * (60.0 / (2.0 * M_PI))) < (conf_now->foc_sl_erpm_hfi * 1.1)) {
+			if (fabsf(motor_now->m_pll_speed * (60.0 / (2.0 * M_PI))) < (conf_now->foc_sl_erpm_hfi * 1.1))
+			{
 				motor_now->m_hfi.est_done_cnt = 0;
 			}
-		} break;
+		}
+			break;
 		}
-
+		
 		// HFI Restore
 		CURRENT_FILTER_ON();
 		motor_now->m_hfi.ind = 0;
@@ -2657,63 +2966,64 @@
 		motor_now->m_hfi.is_samp_n = false;
 		motor_now->m_hfi.prev_sample = 0.0;
 		motor_now->m_hfi.angle = motor_now->m_motor_state.phase;
-
+		
 		float c, s;
 		utils_fast_sincos_better(motor_now->m_motor_state.phase, &s, &c);
-
+		
 		// Park transform
 		float vd_tmp = c * motor_now->m_motor_state.v_alpha + s * motor_now->m_motor_state.v_beta;
-		float vq_tmp = c * motor_now->m_motor_state.v_beta  - s * motor_now->m_motor_state.v_alpha;
-
+		float vq_tmp = c * motor_now->m_motor_state.v_beta - s * motor_now->m_motor_state.v_alpha;
+		
 		UTILS_NAN_ZERO(motor_now->m_motor_state.vd);
 		UTILS_NAN_ZERO(motor_now->m_motor_state.vq);
-
+		
 		UTILS_LP_FAST(motor_now->m_motor_state.vd, vd_tmp, 0.2);
 		UTILS_LP_FAST(motor_now->m_motor_state.vq, vq_tmp, 0.2);
-
+		
 		// Set the current controller integrator to the BEMF voltage to avoid
 		// a current spike when the motor is driven again. Notice that we have
 		// to take decoupling into account.
 		motor_now->m_motor_state.vd_int = motor_now->m_motor_state.vd;
 		motor_now->m_motor_state.vq_int = motor_now->m_motor_state.vq;
-
+		
 		if (conf_now->foc_cc_decoupling == FOC_CC_DECOUPLING_BEMF ||
-				conf_now->foc_cc_decoupling == FOC_CC_DECOUPLING_CROSS_BEMF) {
+		    conf_now->foc_cc_decoupling == FOC_CC_DECOUPLING_CROSS_BEMF)
+		{
 			motor_now->m_motor_state.vq_int -= motor_now->m_motor_state.speed_rad_s * conf_now->foc_motor_flux_linkage;
 		}
-
+		
 		// Update corresponding modulation
 		motor_now->m_motor_state.mod_d = motor_now->m_motor_state.vd / ((2.0 / 3.0) * motor_now->m_motor_state.v_bus);
 		motor_now->m_motor_state.mod_q = motor_now->m_motor_state.vq / ((2.0 / 3.0) * motor_now->m_motor_state.v_bus);
 	}
-
+	
 	// Calculate duty cycle
 	motor_now->m_motor_state.duty_now = SIGN(motor_now->m_motor_state.vq) *
-			sqrtf(SQ(motor_now->m_motor_state.mod_d) + SQ(motor_now->m_motor_state.mod_q))
-			/ SQRT3_BY_2;
-
+	                                    sqrtf(SQ(motor_now->m_motor_state.mod_d) + SQ(motor_now->m_motor_state.mod_q))
+	                                    / SQRT3_BY_2;
+	
 	// Run PLL for speed estimation
 	pll_run(motor_now->m_motor_state.phase, dt, &motor_now->m_pll_phase, &motor_now->m_pll_speed, conf_now);
 	motor_now->m_motor_state.speed_rad_s = motor_now->m_pll_speed;
-
+	
 	// Low latency speed estimation, for e.g. HFI.
 	{
 		// Based on back emf and motor parameters. This could be useful for a resistance observer in the future.
 //		UTILS_LP_FAST(m_speed_est_fast, (m_motor_state.vq - (3.0 / 2.0) * m_conf->foc_motor_r * m_motor_state.iq) / m_conf->foc_motor_flux_linkage, 0.05);
-
+		
 		// Based on angle difference
 		float diff = utils_angle_difference_rad(motor_now->m_motor_state.phase, motor_now->m_phase_before_speed_est);
 		utils_truncate_number(&diff, -M_PI / 3.0, M_PI / 3.0);
-
+		
 		UTILS_LP_FAST(motor_now->m_speed_est_fast, diff / dt, 0.01);
 		UTILS_NAN_ZERO(motor_now->m_speed_est_fast);
-
+		
 		UTILS_LP_FAST(motor_now->m_speed_est_faster, diff / dt, 0.2);
 		UTILS_NAN_ZERO(motor_now->m_speed_est_faster);
-
+		
 		motor_now->m_phase_before_speed_est = motor_now->m_motor_state.phase;
 	}
-
+	
 	// Update tachometer (resolution = 60 deg as for BLDC)
 	float ph_tmp = motor_now->m_motor_state.phase;
 	utils_norm_angle_rad(&ph_tmp);
@@ -2721,40 +3031,53 @@
 	utils_truncate_number_int(&step, 0, 5);
 	int diff = step - motor_now->m_tacho_step_last;
 	motor_now->m_tacho_step_last = step;
-
-	if (diff > 3) {
+	
+	if (diff > 3)
+	{
 		diff -= 6;
-	} else if (diff < -2) {
+	}
+	else if (diff < -2)
+	{
 		diff += 6;
 	}
-
+	
 	motor_now->m_tachometer += diff;
 	motor_now->m_tachometer_abs += abs(diff);
-
+	
 	// Track position control angle
 	// TODO: Have another look at this.
 	float angle_now = 0.0;
-	if (encoder_is_configured()) {
-		if (conf_now->m_sensor_port_mode == SENSOR_PORT_MODE_TS5700N8501_MULTITURN) {
+	if (encoder_is_configured())
+	{
+		if (conf_now->m_sensor_port_mode == SENSOR_PORT_MODE_TS5700N8501_MULTITURN)
+		{
 			angle_now = encoder_read_deg_multiturn();
-		} else {
+		}
+		else
+		{
 			angle_now = enc_ang;
 		}
-	} else {
+	}
+	else
+	{
 		angle_now = motor_now->m_motor_state.phase * (180.0 / M_PI);
 	}
-
-	if (conf_now->p_pid_ang_div > 0.98 && conf_now->p_pid_ang_div < 1.02) {
+	
+	if (conf_now->p_pid_ang_div > 0.98 && conf_now->p_pid_ang_div < 1.02)
+	{
 		motor_now->m_pos_pid_now = angle_now;
-	} else {
+	}
+	else
+	{
 		float diff_f = utils_angle_difference(angle_now, motor_now->m_pid_div_angle_last);
 		motor_now->m_pid_div_angle_last = angle_now;
 		motor_now->m_pos_pid_now += diff_f / conf_now->p_pid_ang_div;
 		utils_norm_angle((float*)&motor_now->m_pos_pid_now);
 	}
-
+	
 	// Run position control
-	if (motor_now->m_state == MC_STATE_RUNNING) {
+	if (motor_now->m_state == MC_STATE_RUNNING)
+	{
 		run_pid_control_pos(motor_now->m_pos_pid_now, motor_now->m_pos_pid_set, dt, motor_now);
 	}
 
@@ -2768,211 +3091,250 @@
 #else
 	mc_interface_mc_timer_isr(false);
 #endif
-
+	
 	m_isr_motor = 0;
 	m_last_adc_isr_duration = timer_seconds_elapsed_since(t_start);
 }
 
 // Private functions
 
-static void timer_update(volatile motor_all_state_t *motor, float dt) {
-	float openloop_rpm = utils_map(fabsf(motor->m_motor_state.iq_target),
-								   0.0, motor->m_conf->l_current_max,
-								   0.0, motor->m_conf->foc_openloop_rpm);
-
+static void timer_update(volatile motor_all_state_t* motor, float dt)
+{
+	float openloop_rpm = utils_map(
+		fabsf(motor->m_motor_state.iq_target),
+		0.0, motor->m_conf->l_current_max,
+		0.0, motor->m_conf->foc_openloop_rpm
+	);
+	
 	utils_truncate_number_abs(&openloop_rpm, motor->m_conf->foc_openloop_rpm);
-
+	
 	const float min_rads = (openloop_rpm * 2.0 * M_PI) / 60.0;
-
+	
 	float add_min_speed = 0.0;
-	if (motor->m_motor_state.duty_now > 0.0) {
+	if (motor->m_motor_state.duty_now > 0.0)
+	{
 		add_min_speed = min_rads * dt;
-	} else {
+	}
+	else
+	{
 		add_min_speed = -min_rads * dt;
 	}
-
+	
 	// Open loop encoder angle for when the index is not found
 	motor->m_phase_now_encoder_no_index += add_min_speed;
 	utils_norm_angle_rad((float*)&motor->m_phase_now_encoder_no_index);
-
+	
 	// Output a minimum speed from the observer
-	if (fabsf(motor->m_pll_speed) < min_rads) {
+	if (fabsf(motor->m_pll_speed) < min_rads)
+	{
 		motor->m_min_rpm_hyst_timer += dt;
-	} else if (motor->m_min_rpm_hyst_timer > 0.0) {
+	}
+	else if (motor->m_min_rpm_hyst_timer > 0.0)
+	{
 		motor->m_min_rpm_hyst_timer -= dt;
 	}
-
+	
 	// Don't use this in brake mode.
-	if (motor->m_control_mode == CONTROL_MODE_CURRENT_BRAKE || fabsf(motor->m_motor_state.duty_now) < 0.001) {
+	if (motor->m_control_mode == CONTROL_MODE_CURRENT_BRAKE || fabsf(motor->m_motor_state.duty_now) < 0.001)
+	{
 		motor->m_min_rpm_hyst_timer = 0.0;
 		motor->m_phase_observer_override = false;
 	}
-
+	
 	bool started_now = false;
-	if (motor->m_min_rpm_hyst_timer > motor->m_conf->foc_sl_openloop_hyst && motor->m_min_rpm_timer <= 0.0001) {
+	if (motor->m_min_rpm_hyst_timer > motor->m_conf->foc_sl_openloop_hyst && motor->m_min_rpm_timer <= 0.0001)
+	{
 		motor->m_min_rpm_timer = motor->m_conf->foc_sl_openloop_time;
 		started_now = true;
 	}
-
-	if (motor->m_min_rpm_timer > 0.0) {
+	
+	if (motor->m_min_rpm_timer > 0.0)
+	{
 		motor->m_phase_now_observer_override += add_min_speed;
-
+		
 		// When the motor gets stuck it tends to be 90 degrees off, so start the open loop
 		// sequence by correcting with 90 degrees.
-		if (started_now) {
-			if (motor->m_motor_state.duty_now > 0.0) {
+		if (started_now)
+		{
+			if (motor->m_motor_state.duty_now > 0.0)
+			{
 				motor->m_phase_now_observer_override += M_PI / 2.0;
-			} else {
+			}
+			else
+			{
 				motor->m_phase_now_observer_override -= M_PI / 2.0;
 			}
 		}
-
+		
 		utils_norm_angle_rad((float*)&motor->m_phase_now_observer_override);
 		motor->m_phase_observer_override = true;
 		motor->m_min_rpm_timer -= dt;
 		motor->m_min_rpm_hyst_timer = 0.0;
-	} else {
+	}
+	else
+	{
 		motor->m_phase_now_observer_override = motor->m_phase_now_observer;
 		motor->m_phase_observer_override = false;
 	}
-
+	
 	// Samples
-	if (motor->m_state == MC_STATE_RUNNING) {
+	if (motor->m_state == MC_STATE_RUNNING)
+	{
 		const volatile float vd_tmp = motor->m_motor_state.vd;
 		const volatile float vq_tmp = motor->m_motor_state.vq;
 		const volatile float id_tmp = motor->m_motor_state.id;
 		const volatile float iq_tmp = motor->m_motor_state.iq;
-
+		
 		motor->m_samples.avg_current_tot += sqrtf(SQ(id_tmp) + SQ(iq_tmp));
 		motor->m_samples.avg_voltage_tot += sqrtf(SQ(vd_tmp) + SQ(vq_tmp));
 		motor->m_samples.sample_num++;
 	}
-
+	
 	// Update and the observer gain.
-
+	
 	// Old gain scaling, based on duty cycle
 //	motor->m_gamma_now = utils_map(fabsf(motor->m_motor_state.duty_now), 0.0, 1.0,
 //			motor->m_conf->foc_observer_gain * motor->m_conf->foc_observer_gain_slow,
 //			motor->m_conf->foc_observer_gain);
-
+	
 	// Observer gain scaling, based on bus voltage and duty cycle
-	float gamma_tmp = utils_map(fabsf(motor->m_motor_state.duty_now),
-								0.0, 40.0 / motor->m_motor_state.v_bus,
-								0,
-								motor->m_conf->foc_observer_gain);
-	if (gamma_tmp < (motor->m_conf->foc_observer_gain_slow * motor->m_conf->foc_observer_gain)) {
+	float gamma_tmp = utils_map(
+		fabsf(motor->m_motor_state.duty_now),
+		0.0, 40.0 / motor->m_motor_state.v_bus,
+		0,
+		motor->m_conf->foc_observer_gain
+	);
+	if (gamma_tmp < (motor->m_conf->foc_observer_gain_slow * motor->m_conf->foc_observer_gain))
+	{
 		gamma_tmp = motor->m_conf->foc_observer_gain_slow * motor->m_conf->foc_observer_gain;
 	}
-
+	
 	// 4.0 scaling is kind of arbitrary, but it should make configs from old VESC Tools more likely to work.
 	motor->m_gamma_now = gamma_tmp * 4.0;
 }
 
-static THD_FUNCTION(timer_thread, arg) {
+static THD_FUNCTION(timer_thread, arg)
+{
 	(void)arg;
-
+	
 	chRegSetThreadName("foc timer");
-
-	for(;;) {
+	
+	for (;;)
+	{
 		const float dt = 0.001;
-
-		if (timer_thd_stop) {
+		
+		if (timer_thd_stop)
+		{
 			timer_thd_stop = false;
 			return;
 		}
-
+		
 		timer_update(&m_motor_1, dt);
 #ifdef HW_HAS_DUAL_MOTORS
 		timer_update(&m_motor_2, dt);
 #endif
-
+		
 		run_pid_control_speed(dt, &m_motor_1);
 #ifdef HW_HAS_DUAL_MOTORS
 		run_pid_control_speed(dt, &m_motor_2);
 #endif
-
+		
 		chThdSleepMilliseconds(1);
 	}
 }
 
-static void hfi_update(volatile motor_all_state_t *motor) {
+static void hfi_update(volatile motor_all_state_t* motor)
+{
 	float rpm_abs = fabsf(motor->m_speed_est_fast * (60.0 / (2.0 * M_PI)));
-
-	if (rpm_abs > motor->m_conf->foc_sl_erpm_hfi) {
+	
+	if (rpm_abs > motor->m_conf->foc_sl_erpm_hfi)
+	{
 		motor->m_hfi.angle = motor->m_phase_now_observer;
 	}
-
-	if (motor->m_hfi.ready) {
+	
+	if (motor->m_hfi.ready)
+	{
 		float real_bin1, imag_bin1, real_bin2, imag_bin2;
 		motor->m_hfi.fft_bin1_func((float*)motor->m_hfi.buffer, &real_bin1, &imag_bin1);
 		motor->m_hfi.fft_bin2_func((float*)motor->m_hfi.buffer, &real_bin2, &imag_bin2);
-
+		
 		float mag_bin_1 = sqrtf(SQ(imag_bin1) + SQ(real_bin1));
 		float angle_bin_1 = -utils_fast_atan2(imag_bin1, real_bin1);
-
+		
 		angle_bin_1 += M_PI / 1.7; // Why 1.7??
 		utils_norm_angle_rad(&angle_bin_1);
-
+		
 		float mag_bin_2 = sqrtf(SQ(imag_bin2) + SQ(real_bin2));
 		float angle_bin_2 = -utils_fast_atan2(imag_bin2, real_bin2) / 2.0;
-
+		
 		// Assuming this thread is much faster than it takes to fill the HFI buffer completely,
 		// we should lag 1/2 HFI buffer behind in phase. Compensate for that here.
 		float dt_sw;
-		if (motor->m_conf->foc_sample_v0_v7) {
+		if (motor->m_conf->foc_sample_v0_v7)
+		{
 			dt_sw = 1.0 / motor->m_conf->foc_f_sw;
-		} else {
+		}
+		else
+		{
 			dt_sw = 1.0 / (motor->m_conf->foc_f_sw / 2.0);
 		}
 		angle_bin_2 += motor->m_motor_state.speed_rad_s * ((float)motor->m_hfi.samples / 2.0) * dt_sw;
-
+		
 		if (fabsf(utils_angle_difference_rad(angle_bin_2 + M_PI, motor->m_hfi.angle)) <
-				fabsf(utils_angle_difference_rad(angle_bin_2, motor->m_hfi.angle))) {
+		    fabsf(utils_angle_difference_rad(angle_bin_2, motor->m_hfi.angle)))
+		{
 			angle_bin_2 += M_PI;
 		}
-
-		if (motor->m_hfi.est_done_cnt < motor->m_conf->foc_hfi_start_samples) {
+		
+		if (motor->m_hfi.est_done_cnt < motor->m_conf->foc_hfi_start_samples)
+		{
 			motor->m_hfi.est_done_cnt++;
-
-			if (fabsf(utils_angle_difference_rad(angle_bin_2, angle_bin_1)) > (M_PI / 2.0)) {
+			
+			if (fabsf(utils_angle_difference_rad(angle_bin_2, angle_bin_1)) > (M_PI / 2.0))
+			{
 				motor->m_hfi.flip_cnt++;
 			}
-		} else {
-			if (motor->m_hfi.flip_cnt >= (motor->m_conf->foc_hfi_start_samples / 2)) {
+		}
+		else
+		{
+			if (motor->m_hfi.flip_cnt >= (motor->m_conf->foc_hfi_start_samples / 2))
+			{
 				angle_bin_2 += M_PI;
 			}
 			motor->m_hfi.flip_cnt = 0;
 		}
-
+		
 		motor->m_hfi.angle = angle_bin_2;
 		utils_norm_angle_rad((float*)&motor->m_hfi.angle);
-
+		
 		// As angle_bin_1 is based on saturation, it is only accurate when the motor current is low. It
 		// might be possible to compensate for that, which would allow HFI on non-salient motors.
 		//			m_hfi.angle = angle_bin_1;
-
-		if (motor->m_hfi_plot_en == 1) {
+		
+		if (motor->m_hfi_plot_en == 1)
+		{
 			static float hfi_plot_div = 0;
 			hfi_plot_div++;
-
-			if (hfi_plot_div >= 8) {
+			
+			if (hfi_plot_div >= 8)
+			{
 				hfi_plot_div = 0;
-
+				
 				float real_bin0, imag_bin0;
 				motor->m_hfi.fft_bin0_func((float*)motor->m_hfi.buffer, &real_bin0, &imag_bin0);
-
+				
 				commands_plot_set_graph(0);
 				commands_send_plot_points(motor->m_hfi_plot_sample, motor->m_hfi.angle);
-
+				
 				commands_plot_set_graph(1);
 				commands_send_plot_points(motor->m_hfi_plot_sample, angle_bin_1);
-
+				
 				commands_plot_set_graph(2);
 				commands_send_plot_points(motor->m_hfi_plot_sample, 2.0 * mag_bin_2 * 1e6);
-
+				
 				commands_plot_set_graph(3);
 				commands_send_plot_points(motor->m_hfi_plot_sample, 2.0 * mag_bin_1 * 1e6);
-
+				
 				commands_plot_set_graph(4);
 				commands_send_plot_points(motor->m_hfi_plot_sample, real_bin0 * 1e6);
 
@@ -2981,72 +3343,90 @@
 //
 //					commands_plot_set_graph(1);
 //					commands_send_plot_points(motor->m_hfi_plot_sample, motor->m_speed_est_fast);
-
+				
 				motor->m_hfi_plot_sample++;
 			}
-		} else if (motor->m_hfi_plot_en == 2) {
+		}
+		else if (motor->m_hfi_plot_en == 2)
+		{
 			static float hfi_plot_div = 0;
 			hfi_plot_div++;
-
-			if (hfi_plot_div >= 8) {
+			
+			if (hfi_plot_div >= 8)
+			{
 				hfi_plot_div = 0;
-
-				if (motor->m_hfi_plot_sample >= motor->m_hfi.samples) {
+				
+				if (motor->m_hfi_plot_sample >= motor->m_hfi.samples)
+				{
 					motor->m_hfi_plot_sample = 0;
 				}
-
+				
 				commands_plot_set_graph(0);
-				commands_send_plot_points(motor->m_hfi_plot_sample, motor->m_hfi.buffer_current[(int)motor->m_hfi_plot_sample]);
-
+				commands_send_plot_points(
+					motor->m_hfi_plot_sample,
+					motor->m_hfi.buffer_current[(int)motor->m_hfi_plot_sample]
+				);
+				
 				commands_plot_set_graph(1);
-				commands_send_plot_points(motor->m_hfi_plot_sample, motor->m_hfi.buffer[(int)motor->m_hfi_plot_sample] * 1e6);
-
+				commands_send_plot_points(
+					motor->m_hfi_plot_sample,
+					motor->m_hfi.buffer[(int)motor->m_hfi_plot_sample] * 1e6
+				);
+				
 				motor->m_hfi_plot_sample++;
 			}
 		}
-	} else {
+	}
+	else
+	{
 		motor->m_hfi.angle = motor->m_phase_now_observer;
 	}
 }
 
-static THD_FUNCTION(hfi_thread, arg) {
+static THD_FUNCTION(hfi_thread, arg)
+{
 	(void)arg;
-
+	
 	chRegSetThreadName("foc hfi");
-
-	for(;;) {
-		if (hfi_thd_stop) {
+	
+	for (;;)
+	{
+		if (hfi_thd_stop)
+		{
 			hfi_thd_stop = false;
 			return;
 		}
-
+		
 		hfi_update(&m_motor_1);
 #ifdef HW_HAS_DUAL_MOTORS
 		hfi_update(&m_motor_2);
 #endif
-
+		
 		chThdSleepMicroseconds(500);
 	}
 }
 
-static void do_dc_cal(void) {
+static void do_dc_cal(void)
+{
 	DCCAL_ON();
-
+	
 	// Wait max 5 seconds
 	int cnt = 0;
-	while(IS_DRV_FAULT()){
+	while (IS_DRV_FAULT())
+	{
 		chThdSleepMilliseconds(1);
 		cnt++;
-		if (cnt > 5000) {
+		if (cnt > 5000)
+		{
 			break;
 		}
 	};
-
+	
 	chThdSleepMilliseconds(1000);
-
+	
 	memset((int*)m_motor_1.m_curr_sum, 0, sizeof(m_motor_1.m_curr_sum));
 	m_motor_1.m_curr_samples = 0;
-	while(m_motor_1.m_curr_samples < 4000) {};
+	while (m_motor_1.m_curr_samples < 4000) {};
 	m_motor_1.m_curr_ofs[0] = m_motor_1.m_curr_sum[0] / m_motor_1.m_curr_samples;
 	m_motor_1.m_curr_ofs[1] = m_motor_1.m_curr_sum[1] / m_motor_1.m_curr_samples;
 #ifdef HW_HAS_3_SHUNTS
@@ -3063,68 +3443,79 @@
 	m_motor_2.m_curr_ofs[2] = m_motor_2.m_curr_sum[2] / m_motor_2.m_curr_samples;
 #endif
 #endif
-
+	
 	DCCAL_OFF();
 	m_dccal_done = true;
 }
 
 // See http://cas.ensmp.fr/~praly/Telechargement/Journaux/2010-IEEE_TPEL-Lee-Hong-Nam-Ortega-Praly-Astolfi.pdf
-void observer_update(float v_alpha, float v_beta, float i_alpha, float i_beta,
-					 float dt, volatile float *x1, volatile float *x2, volatile float *phase, volatile motor_all_state_t *motor) {
-
-	volatile mc_configuration *conf_now = motor->m_conf;
-
+void observer_update(
+	float v_alpha, float v_beta, float i_alpha, float i_beta,
+	float dt, volatile float* x1, volatile float* x2, volatile float* phase, volatile motor_all_state_t* motor
+)
+{
+	
+	volatile mc_configuration* conf_now = motor->m_conf;
+	
 	const float L = (3.0 / 2.0) * conf_now->foc_motor_l;
 	float R = (3.0 / 2.0) * conf_now->foc_motor_r;
-
+	
 	// Saturation compensation
 	const float sign = (motor->m_motor_state.iq * motor->m_motor_state.vq) >= 0.0 ? 1.0 : -1.0;
 	R -= R * sign * conf_now->foc_sat_comp * (motor->m_motor_state.i_abs_filter / conf_now->l_current_max);
-
+	
 	// Temperature compensation
 	const float t = mc_interface_temp_motor_filtered();
-	if (conf_now->foc_temp_comp && t > -25.0) {
+	if (conf_now->foc_temp_comp && t > -25.0)
+	{
 		R += R * 0.00386 * (t - conf_now->foc_temp_comp_base_temp);
 	}
-
+	
 	const float L_ia = L * i_alpha;
 	const float L_ib = L * i_beta;
 	const float R_ia = R * i_alpha;
 	const float R_ib = R * i_beta;
 	const float lambda_2 = SQ(conf_now->foc_motor_flux_linkage);
 	const float gamma_half = motor->m_gamma_now * 0.5;
-
-	switch (conf_now->foc_observer_type) {
-	case FOC_OBSERVER_ORTEGA_ORIGINAL: {
+	
+	switch (conf_now->foc_observer_type)
+	{
+	case FOC_OBSERVER_ORTEGA_ORIGINAL:
+	{
 		float err = lambda_2 - (SQ(*x1 - L_ia) + SQ(*x2 - L_ib));
 		float x1_dot = -R_ia + v_alpha + gamma_half * (*x1 - L_ia) * err;
 		float x2_dot = -R_ib + v_beta + gamma_half * (*x2 - L_ib) * err;
 		*x1 += x1_dot * dt;
 		*x2 += x2_dot * dt;
-	} break;
-
-	case FOC_OBSERVER_ORTEGA_ITERATIVE: {
+	}
+		break;
+	
+	case FOC_OBSERVER_ORTEGA_ITERATIVE:
+	{
 		// Iterative with some trial and error
 		const int iterations = 6;
 		const float dt_iteration = dt / (float)iterations;
-		for (int i = 0;i < iterations;i++) {
+		for (int i = 0; i < iterations; i++)
+		{
 			float err = lambda_2 - (SQ(*x1 - L_ia) + SQ(*x2 - L_ib));
 			float gamma_tmp = gamma_half;
-			if (utils_truncate_number_abs(&err, lambda_2 * 0.2)) {
+			if (utils_truncate_number_abs(&err, lambda_2 * 0.2))
+			{
 				gamma_tmp *= 10.0;
 			}
 			float x1_dot = -R_ia + v_alpha + gamma_tmp * (*x1 - L_ia) * err;
 			float x2_dot = -R_ib + v_beta + gamma_tmp * (*x2 - L_ib) * err;
-
+			
 			*x1 += x1_dot * dt_iteration;
 			*x2 += x2_dot * dt_iteration;
 		}
-	} break;
-
+	}
+		break;
+	
 	default:
 		break;
 	}
-
+	
 	// Same as iterative, but without iterations.
 //	float err = lambda_2 - (SQ(*x1 - L_ia) + SQ(*x2 - L_ib));
 //	float gamma_tmp = gamma_half;
@@ -3135,17 +3526,21 @@
 //	float x2_dot = -R_ib + v_beta + gamma_tmp * (*x2 - L_ib) * err;
 //	*x1 += x1_dot * dt;
 //	*x2 += x2_dot * dt;
-
+	
 	UTILS_NAN_ZERO(*x1);
 	UTILS_NAN_ZERO(*x2);
-
-	if (phase) {
+	
+	if (phase)
+	{
 		*phase = utils_fast_atan2(*x2 - L_ib, *x1 - L_ia);
 	}
 }
 
-static void pll_run(float phase, float dt, volatile float *phase_var,
-					volatile float *speed_var, volatile mc_configuration *conf) {
+static void pll_run(
+	float phase, float dt, volatile float* phase_var,
+	volatile float* speed_var, volatile mc_configuration* conf
+)
+{
 	UTILS_NAN_ZERO(*phase_var);
 	float delta_theta = phase - *phase_var;
 	utils_norm_angle_rad(&delta_theta);
@@ -3192,506 +3587,602 @@
  * @param dt
  * The time step in seconds.
  */
-static void control_current(volatile motor_all_state_t *motor, float dt) {
-	volatile motor_state_t *state_m = &motor->m_motor_state;
-	volatile mc_configuration *conf_now = motor->m_conf;
-
-	float c,s;
+static void control_current(volatile motor_all_state_t* motor, float dt)
+{
+	volatile motor_state_t* state_m = &motor->m_motor_state;
+	volatile mc_configuration* conf_now = motor->m_conf;
+	
+	float c, s;
 	utils_fast_sincos_better(state_m->phase, &s, &c);
-
+	
 	float abs_rpm = fabsf(motor->m_speed_est_fast * 60 / (2 * M_PI));
-
+	
 	bool do_hfi = conf_now->foc_sensor_mode == FOC_SENSOR_MODE_HFI &&
-			!motor->m_phase_override &&
-			abs_rpm < (conf_now->foc_sl_erpm_hfi * (motor->m_cc_was_hfi ? 1.8 : 1.5));
+	              !motor->m_phase_override &&
+	              abs_rpm < (conf_now->foc_sl_erpm_hfi * (motor->m_cc_was_hfi ? 1.8 : 1.5));
 	motor->m_cc_was_hfi = do_hfi;
-
+	
 	// Only allow Q axis current after the HFI ambiguity is resolved. This causes
 	// a short delay when starting.
-	if (do_hfi && motor->m_hfi.est_done_cnt < conf_now->foc_hfi_start_samples) {
+	if (do_hfi && motor->m_hfi.est_done_cnt < conf_now->foc_hfi_start_samples)
+	{
 		state_m->iq_target = 0;
 	}
-
+	
 	float max_duty = fabsf(state_m->max_duty);
 	utils_truncate_number(&max_duty, 0.0, conf_now->l_max_duty);
-
+	utils_truncate_number(&max_duty, 0.0, conf_now->l_max_duty);
+	
 	state_m->id = c * state_m->i_alpha + s * state_m->i_beta;
-	state_m->iq = c * state_m->i_beta  - s * state_m->i_alpha;
+	state_m->iq = c * state_m->i_beta - s * state_m->i_alpha;
 	UTILS_LP_FAST(state_m->id_filter, state_m->id, conf_now->foc_current_filter_const);
 	UTILS_LP_FAST(state_m->iq_filter, state_m->iq, conf_now->foc_current_filter_const);
-
+	
 	float Ierr_d = state_m->id_target - state_m->id;
 	float Ierr_q = state_m->iq_target - state_m->iq;
-
+	
 	state_m->vd = state_m->vd_int + Ierr_d * conf_now->foc_current_kp;
 	state_m->vq = state_m->vq_int + Ierr_q * conf_now->foc_current_kp;
-
+	
 	// Temperature compensation
 	const float t = mc_interface_temp_motor_filtered();
 	float ki = conf_now->foc_current_ki;
-	if (conf_now->foc_temp_comp && t > -5.0) {
+	if (conf_now->foc_temp_comp && t > -5.0)
+	{
 		ki += ki * 0.00386 * (t - conf_now->foc_temp_comp_base_temp);
 	}
-
+	
 	state_m->vd_int += Ierr_d * (ki * dt);
 	state_m->vq_int += Ierr_q * (ki * dt);
-
+	
 	// Decoupling
 	float dec_vd = 0.0;
 	float dec_vq = 0.0;
 	float dec_bemf = 0.0;
-
-	if (motor->m_control_mode < CONTROL_MODE_HANDBRAKE && conf_now->foc_cc_decoupling != FOC_CC_DECOUPLING_DISABLED) {
-		switch (conf_now->foc_cc_decoupling) {
+	
+	if (motor->m_control_mode < CONTROL_MODE_HANDBRAKE && conf_now->foc_cc_decoupling != FOC_CC_DECOUPLING_DISABLED)
+	{
+		switch (conf_now->foc_cc_decoupling)
+		{
 		case FOC_CC_DECOUPLING_CROSS:
 			dec_vd = state_m->iq * state_m->speed_rad_s * conf_now->foc_motor_l * (3.0 / 2.0);
 			dec_vq = state_m->id * state_m->speed_rad_s * conf_now->foc_motor_l * (3.0 / 2.0);
 			break;
-
+		
 		case FOC_CC_DECOUPLING_BEMF:
 			dec_bemf = state_m->speed_rad_s * conf_now->foc_motor_flux_linkage;
 			break;
-
+		
 		case FOC_CC_DECOUPLING_CROSS_BEMF:
 			dec_vd = state_m->iq * state_m->speed_rad_s * conf_now->foc_motor_l * (3.0 / 2.0);
 			dec_vq = state_m->id * state_m->speed_rad_s * conf_now->foc_motor_l * (3.0 / 2.0);
 			dec_bemf = state_m->speed_rad_s * conf_now->foc_motor_flux_linkage;
 			break;
-
+		
 		default:
 			break;
 		}
 	}
-
+	
 	state_m->vd -= dec_vd;
 	state_m->vq += dec_vq + dec_bemf;
-
+	
 	float max_v_mag = (2.0 / 3.0) * max_duty * SQRT3_BY_2 * state_m->v_bus;
-
+	
 	// Saturation
 	utils_saturate_vector_2d((float*)&state_m->vd, (float*)&state_m->vq, max_v_mag);
 	state_m->mod_d = state_m->vd / ((2.0 / 3.0) * state_m->v_bus);
 	state_m->mod_q = state_m->vq / ((2.0 / 3.0) * state_m->v_bus);
-
+	
 	// Integrator windup protection
 	// This is important, tricky and probably needs improvement.
 	// Currently we start by truncating the d-axis and then the q-axis with the magnitude that is
 	// left. Axis decoupling is taken into account in the truncation. How to do that best is also
 	// an open question...
-
+	
 	// Take both cross and back emf decoupling into consideration. Seems to make the control
 	// noisy at full modulation.
 //	utils_truncate_number((float*)&state_m->vd_int, -max_v_mag + dec_vd, max_v_mag + dec_vd);
 //	float mag_left = sqrtf(SQ(max_v_mag) - SQ(state_m->vd_int - dec_vd));
 //	utils_truncate_number((float*)&state_m->vq_int, -mag_left - (dec_vq + dec_bemf), mag_left - (dec_vq + dec_bemf));
-
+	
 	// Take only back emf decoupling into consideration. Seems to work best.
 	utils_truncate_number((float*)&state_m->vd_int, -max_v_mag, max_v_mag);
 	float mag_left = sqrtf(SQ(max_v_mag) - SQ(state_m->vd_int));
 	utils_truncate_number((float*)&state_m->vq_int, -mag_left - dec_bemf, mag_left - dec_bemf);
-
+	
 	// Ignore decoupling. Works badly when back emf decoupling is used, probably not
 	// the best way to go.
 //	utils_truncate_number((float*)&state_m->vd_int, -max_v_mag, max_v_mag);
 //	float mag_left = sqrtf(SQ(max_v_mag) - SQ(state_m->vd_int));
 //	utils_truncate_number((float*)&state_m->vq_int, -mag_left, mag_left);
-
+	
 	// This is how anti-windup was done in FW < 4.0. Does not work well when there is too much D axis voltage.
 //	utils_truncate_number((float*)&state_m->vd_int, -max_v_mag, max_v_mag);
 //	utils_truncate_number((float*)&state_m->vq_int, -max_v_mag, max_v_mag);
-
+	
 	// TODO: Have a look at this?
 	state_m->i_bus = state_m->mod_d * state_m->id + state_m->mod_q * state_m->iq;
 	state_m->i_abs = sqrtf(SQ(state_m->id) + SQ(state_m->iq));
 	state_m->i_abs_filter = sqrtf(SQ(state_m->id_filter) + SQ(state_m->iq_filter));
-
+	
 	float mod_alpha = c * state_m->mod_d - s * state_m->mod_q;
-	float mod_beta  = c * state_m->mod_q + s * state_m->mod_d;
-
+	float mod_beta = c * state_m->mod_q + s * state_m->mod_d;
+	
 	// Deadtime compensation
 	const float i_alpha_filter = c * state_m->id_target - s * state_m->iq_target;
 	const float i_beta_filter = c * state_m->iq_target + s * state_m->id_target;
 	const float ia_filter = i_alpha_filter;
 	const float ib_filter = -0.5 * i_alpha_filter + SQRT3_BY_2 * i_beta_filter;
 	const float ic_filter = -0.5 * i_alpha_filter - SQRT3_BY_2 * i_beta_filter;
-	const float mod_alpha_filter_sgn = (2.0 / 3.0) * SIGN(ia_filter) - (1.0 / 3.0) * SIGN(ib_filter) - (1.0 / 3.0) * SIGN(ic_filter);
+	const float
+		mod_alpha_filter_sgn =
+		(2.0 / 3.0) * SIGN(ia_filter) - (1.0 / 3.0) * SIGN(ib_filter) - (1.0 / 3.0) * SIGN(ic_filter);
 	const float mod_beta_filter_sgn = ONE_BY_SQRT3 * SIGN(ib_filter) - ONE_BY_SQRT3 * SIGN(ic_filter);
 	const float mod_comp_fact = conf_now->foc_dt_us * 1e-6 * conf_now->foc_f_sw;
 	const float mod_alpha_comp = mod_alpha_filter_sgn * mod_comp_fact;
 	const float mod_beta_comp = mod_beta_filter_sgn * mod_comp_fact;
-
+	
 	// Apply compensation here so that 0 duty cycle has no glitches.
 	state_m->v_alpha = (mod_alpha - mod_alpha_comp) * (2.0 / 3.0) * state_m->v_bus;
 	state_m->v_beta = (mod_beta - mod_beta_comp) * (2.0 / 3.0) * state_m->v_bus;
 	state_m->vd = c * motor->m_motor_state.v_alpha + s * motor->m_motor_state.v_beta;
-	state_m->vq = c * motor->m_motor_state.v_beta  - s * motor->m_motor_state.v_alpha;
-
+	state_m->vq = c * motor->m_motor_state.v_beta - s * motor->m_motor_state.v_alpha;
+	
 	// HFI
-	if (do_hfi) {
+	if (do_hfi)
+	{
 		CURRENT_FILTER_OFF();
-
+		
 		float mod_alpha_tmp = mod_alpha;
 		float mod_beta_tmp = mod_beta;
-
+		
 		float hfi_voltage;
-		if (motor->m_hfi.est_done_cnt < conf_now->foc_hfi_start_samples) {
+		if (motor->m_hfi.est_done_cnt < conf_now->foc_hfi_start_samples)
+		{
 			hfi_voltage = conf_now->foc_hfi_voltage_start;
-		} else {
-			hfi_voltage = utils_map(fabsf(state_m->iq), 0.0, conf_now->l_current_max,
-									conf_now->foc_hfi_voltage_run, conf_now->foc_hfi_voltage_max);
+		}
+		else
+		{
+			hfi_voltage = utils_map(
+				fabsf(state_m->iq), 0.0, conf_now->l_current_max,
+				conf_now->foc_hfi_voltage_run, conf_now->foc_hfi_voltage_max
+			);
 		}
-
+		
 		utils_truncate_number_abs(&hfi_voltage, state_m->v_bus * (2.0 / 3.0) * 0.9);
-
-		if (motor->m_hfi.is_samp_n) {
+		
+		if (motor->m_hfi.is_samp_n)
+		{
 			float sample_now = (utils_tab_sin_32_1[motor->m_hfi.ind * motor->m_hfi.table_fact] * state_m->i_alpha -
-					utils_tab_cos_32_1[motor->m_hfi.ind * motor->m_hfi.table_fact] * state_m->i_beta);
+			                    utils_tab_cos_32_1[motor->m_hfi.ind * motor->m_hfi.table_fact] * state_m->i_beta);
 			float current_sample = sample_now - motor->m_hfi.prev_sample;
-
+			
 			motor->m_hfi.buffer_current[motor->m_hfi.ind] = current_sample;
-
-			if (current_sample > 0.01) {
+			
+			if (current_sample > 0.01)
+			{
 				motor->m_hfi.buffer[motor->m_hfi.ind] = ((hfi_voltage / 2.0 - conf_now->foc_motor_r *
-						current_sample) / (conf_now->foc_f_sw * current_sample));
+				                                                              current_sample) / (conf_now->foc_f_sw * current_sample));
 			}
-
+			
 			motor->m_hfi.ind++;
-			if (motor->m_hfi.ind == motor->m_hfi.samples) {
+			if (motor->m_hfi.ind == motor->m_hfi.samples)
+			{
 				motor->m_hfi.ind = 0;
 				motor->m_hfi.ready = true;
 			}
-
-			mod_alpha_tmp += hfi_voltage * utils_tab_sin_32_1[motor->m_hfi.ind * motor->m_hfi.table_fact] / ((2.0 / 3.0) * state_m->v_bus);
-			mod_beta_tmp -= hfi_voltage * utils_tab_cos_32_1[motor->m_hfi.ind * motor->m_hfi.table_fact] / ((2.0 / 3.0) * state_m->v_bus);
-		} else {
-			motor->m_hfi.prev_sample = utils_tab_sin_32_1[motor->m_hfi.ind * motor->m_hfi.table_fact] * state_m->i_alpha -
-					utils_tab_cos_32_1[motor->m_hfi.ind * motor->m_hfi.table_fact] * state_m->i_beta;
-
-			mod_alpha_tmp -= hfi_voltage * utils_tab_sin_32_1[motor->m_hfi.ind * motor->m_hfi.table_fact] / ((2.0 / 3.0) * state_m->v_bus);
-			mod_beta_tmp += hfi_voltage * utils_tab_cos_32_1[motor->m_hfi.ind * motor->m_hfi.table_fact] / ((2.0 / 3.0) * state_m->v_bus);
+			
+			mod_alpha_tmp
+				+=
+				hfi_voltage * utils_tab_sin_32_1[motor->m_hfi.ind * motor->m_hfi
+				                                                         .table_fact] / ((2.0 / 3.0) * state_m->v_bus);
+			mod_beta_tmp
+				-=
+				hfi_voltage * utils_tab_cos_32_1[motor->m_hfi.ind * motor->m_hfi
+				                                                         .table_fact] / ((2.0 / 3.0) * state_m->v_bus);
+		}
+		else
+		{
+			motor->m_hfi.prev_sample =
+				utils_tab_sin_32_1[motor->m_hfi.ind * motor->m_hfi.table_fact] * state_m->i_alpha -
+				utils_tab_cos_32_1[motor->m_hfi.ind * motor->m_hfi.table_fact] * state_m->i_beta;
+			
+			mod_alpha_tmp
+				-=
+				hfi_voltage * utils_tab_sin_32_1[motor->m_hfi.ind * motor->m_hfi
+				                                                         .table_fact] / ((2.0 / 3.0) * state_m->v_bus);
+			mod_beta_tmp
+				+=
+				hfi_voltage * utils_tab_cos_32_1[motor->m_hfi.ind * motor->m_hfi
+				                                                         .table_fact] / ((2.0 / 3.0) * state_m->v_bus);
 		}
-
+		
 		utils_saturate_vector_2d(&mod_alpha_tmp, &mod_beta_tmp, SQRT3_BY_2 * 0.95);
 		motor->m_hfi.is_samp_n = !motor->m_hfi.is_samp_n;
-
-		if (conf_now->foc_sample_v0_v7) {
+		
+		if (conf_now->foc_sample_v0_v7)
+		{
 			mod_alpha = mod_alpha_tmp;
 			mod_beta = mod_beta_tmp;
-		} else {
+		}
+		else
+		{
 			// Delay adding the HFI voltage when not sampling in both 0 vectors, as it will cancel
 			// itself with the opposite pulse from the previous HFI sample. This makes more sense
 			// when drawing the SVM waveform.
-			svm(-mod_alpha_tmp, -mod_beta_tmp, TIM1->ARR,
+			svm(
+				-mod_alpha_tmp, -mod_beta_tmp, TIM1->ARR,
 				(uint32_t*)&motor->m_duty1_next,
 				(uint32_t*)&motor->m_duty2_next,
 				(uint32_t*)&motor->m_duty3_next,
-				(uint32_t*)&state_m->svm_sector);
+				(uint32_t*)&state_m->svm_sector
+			);
 			motor->m_duty_next_set = true;
 		}
-	} else {
+	}
+	else
+	{
 		CURRENT_FILTER_ON();
 		motor->m_hfi.ind = 0;
 		motor->m_hfi.ready = false;
 		motor->m_hfi.is_samp_n = false;
 		motor->m_hfi.prev_sample = 0.0;
 	}
-
+	
 	// Set output (HW Dependent)
 	uint32_t duty1, duty2, duty3, top;
 	top = TIM1->ARR;
 	svm(-mod_alpha, -mod_beta, top, &duty1, &duty2, &duty3, (uint32_t*)&state_m->svm_sector);
-
-	if (motor == &m_motor_1) {
+	
+	if (motor == &m_motor_1)
+	{
 		TIMER_UPDATE_DUTY_M1(duty1, duty2, duty3);
 #ifdef HW_HAS_DUAL_PARALLEL
 		TIMER_UPDATE_DUTY_M2(duty1, duty2, duty3);
 #endif
-	} else {
+	}
+	else
+	{
 #ifndef HW_HAS_DUAL_PARALLEL
 		TIMER_UPDATE_DUTY_M2(duty1, duty2, duty3);
 #endif
 	}
-
+	
 	// do not allow to turn on PWM outputs if virtual motor is used
-	if(virtual_motor_is_connected() == false) {
-		if (!motor->m_output_on) {
+	if (virtual_motor_is_connected() == false)
+	{
+		if (!motor->m_output_on)
+		{
 			start_pwm_hw(motor);
 		}
 	}
 }
 
 // Magnitude must not be larger than sqrt(3)/2, or 0.866
-static void svm(float alpha, float beta, uint32_t PWMHalfPeriod,
-				uint32_t* tAout, uint32_t* tBout, uint32_t* tCout, uint32_t *svm_sector) {
+static void svm(
+	float alpha, float beta, uint32_t PWMHalfPeriod,
+	uint32_t* tAout, uint32_t* tBout, uint32_t* tCout, uint32_t* svm_sector
+)
+{
 	uint32_t sector;
-
-	if (beta >= 0.0f) {
-		if (alpha >= 0.0f) {
+	
+	if (beta >= 0.0f)
+	{
+		if (alpha >= 0.0f)
+		{
 			//quadrant I
-			if (ONE_BY_SQRT3 * beta > alpha) {
+			if (ONE_BY_SQRT3 * beta > alpha)
+			{
 				sector = 2;
-			} else {
+			}
+			else
+			{
 				sector = 1;
 			}
-		} else {
+		}
+		else
+		{
 			//quadrant II
-			if (-ONE_BY_SQRT3 * beta > alpha) {
+			if (-ONE_BY_SQRT3 * beta > alpha)
+			{
 				sector = 3;
-			} else {
+			}
+			else
+			{
 				sector = 2;
 			}
 		}
-	} else {
-		if (alpha >= 0.0f) {
+	}
+	else
+	{
+		if (alpha >= 0.0f)
+		{
 			//quadrant IV5
-			if (-ONE_BY_SQRT3 * beta > alpha) {
+			if (-ONE_BY_SQRT3 * beta > alpha)
+			{
 				sector = 5;
-			} else {
+			}
+			else
+			{
 				sector = 6;
 			}
-		} else {
+		}
+		else
+		{
 			//quadrant III
-			if (ONE_BY_SQRT3 * beta > alpha) {
+			if (ONE_BY_SQRT3 * beta > alpha)
+			{
 				sector = 4;
-			} else {
+			}
+			else
+			{
 				sector = 5;
 			}
 		}
 	}
-
+	
 	// PWM timings
 	uint32_t tA, tB, tC;
-
-	switch (sector) {
-
-	// sector 1-2
-	case 1: {
+	
+	switch (sector)
+	{
+		
+		// sector 1-2
+	case 1:
+	{
 		// Vector on-times
 		uint32_t t1 = (alpha - ONE_BY_SQRT3 * beta) * PWMHalfPeriod;
 		uint32_t t2 = (TWO_BY_SQRT3 * beta) * PWMHalfPeriod;
-
+		
 		// PWM timings
 		tA = (PWMHalfPeriod - t1 - t2) / 2;
 		tB = tA + t1;
 		tC = tB + t2;
-
+		
 		break;
 	}
-
-	// sector 2-3
-	case 2: {
+		
+		// sector 2-3
+	case 2:
+	{
 		// Vector on-times
 		uint32_t t2 = (alpha + ONE_BY_SQRT3 * beta) * PWMHalfPeriod;
 		uint32_t t3 = (-alpha + ONE_BY_SQRT3 * beta) * PWMHalfPeriod;
-
+		
 		// PWM timings
 		tB = (PWMHalfPeriod - t2 - t3) / 2;
 		tA = tB + t3;
 		tC = tA + t2;
-
+		
 		break;
 	}
-
-	// sector 3-4
-	case 3: {
+		
+		// sector 3-4
+	case 3:
+	{
 		// Vector on-times
 		uint32_t t3 = (TWO_BY_SQRT3 * beta) * PWMHalfPeriod;
 		uint32_t t4 = (-alpha - ONE_BY_SQRT3 * beta) * PWMHalfPeriod;
-
+		
 		// PWM timings
 		tB = (PWMHalfPeriod - t3 - t4) / 2;
 		tC = tB + t3;
 		tA = tC + t4;
-
+		
 		break;
 	}
-
-	// sector 4-5
-	case 4: {
+		
+		// sector 4-5
+	case 4:
+	{
 		// Vector on-times
 		uint32_t t4 = (-alpha + ONE_BY_SQRT3 * beta) * PWMHalfPeriod;
 		uint32_t t5 = (-TWO_BY_SQRT3 * beta) * PWMHalfPeriod;
-
+		
 		// PWM timings
 		tC = (PWMHalfPeriod - t4 - t5) / 2;
 		tB = tC + t5;
 		tA = tB + t4;
-
+		
 		break;
 	}
-
-	// sector 5-6
-	case 5: {
+		
+		// sector 5-6
+	case 5:
+	{
 		// Vector on-times
 		uint32_t t5 = (-alpha - ONE_BY_SQRT3 * beta) * PWMHalfPeriod;
 		uint32_t t6 = (alpha - ONE_BY_SQRT3 * beta) * PWMHalfPeriod;
-
+		
 		// PWM timings
 		tC = (PWMHalfPeriod - t5 - t6) / 2;
 		tA = tC + t5;
 		tB = tA + t6;
-
+		
 		break;
 	}
-
-	// sector 6-1
-	case 6: {
+		
+		// sector 6-1
+	case 6:
+	{
 		// Vector on-times
 		uint32_t t6 = (-TWO_BY_SQRT3 * beta) * PWMHalfPeriod;
 		uint32_t t1 = (alpha + ONE_BY_SQRT3 * beta) * PWMHalfPeriod;
-
+		
 		// PWM timings
 		tA = (PWMHalfPeriod - t6 - t1) / 2;
 		tC = tA + t1;
 		tB = tC + t6;
-
+		
 		break;
 	}
 	}
-
+	
 	*tAout = tA;
 	*tBout = tB;
 	*tCout = tC;
 	*svm_sector = sector;
 }
 
-static void run_pid_control_pos(float angle_now, float angle_set, float dt, volatile motor_all_state_t *motor) {
-	volatile mc_configuration *conf_now = motor->m_conf;
+static void run_pid_control_pos(float angle_now, float angle_set, float dt, volatile motor_all_state_t* motor)
+{
+	volatile mc_configuration* conf_now = motor->m_conf;
 	float p_term;
 	float d_term;
-
+	
 	// PID is off. Return.
-	if (motor->m_control_mode != CONTROL_MODE_POS) {
+	if (motor->m_control_mode != CONTROL_MODE_POS)
+	{
 		motor->m_pos_i_term = 0;
 		motor->m_pos_prev_error = 0;
 		return;
 	}
-
+	
 	// Compute parameters
 	float error = utils_angle_difference(angle_set, angle_now);
-
-	if (encoder_is_configured()) {
-		if (conf_now->foc_encoder_inverted) {
+	
+	if (encoder_is_configured())
+	{
+		if (conf_now->foc_encoder_inverted)
+		{
 			error = -error;
 		}
 	}
-
+	
 	p_term = error * conf_now->p_pid_kp;
 	motor->m_pos_i_term += error * (conf_now->p_pid_ki * dt);
-
+	
 	// Average DT for the D term when the error does not change. This likely
 	// happens at low speed when the position resolution is low and several
 	// control iterations run without position updates.
 	// TODO: Are there problems with this approach?
 	motor->m_pos_dt_int += dt;
-	if (error == motor->m_pos_prev_error) {
+	if (error == motor->m_pos_prev_error)
+	{
 		d_term = 0.0;
-	} else {
+	}
+	else
+	{
 		d_term = (error - motor->m_pos_prev_error) * (conf_now->p_pid_kd / motor->m_pos_dt_int);
 		motor->m_pos_dt_int = 0.0;
 	}
-
+	
 	// Filter D
 	UTILS_LP_FAST(motor->m_pos_d_filter, d_term, conf_now->p_pid_kd_filter);
 	d_term = motor->m_pos_d_filter;
-
-
+	
+	
 	// I-term wind-up protection
 	float p_tmp = p_term;
 	utils_truncate_number_abs(&p_tmp, 1.0);
 	utils_truncate_number_abs((float*)&motor->m_pos_i_term, 1.0 - fabsf(p_tmp));
-
+	
 	// Store previous error
 	motor->m_pos_prev_error = error;
-
+	
 	// Calculate output
 	float output = p_term + motor->m_pos_i_term + d_term;
 	utils_truncate_number(&output, -1.0, 1.0);
-
-	if (encoder_is_configured()) {
-		if (encoder_index_found()) {
+	
+	if (encoder_is_configured())
+	{
+		if (encoder_index_found())
+		{
 			motor->m_iq_set = output * conf_now->lo_current_max;
-		} else {
+		}
+		else
+		{
 			// Rotate the motor with 40 % power until the encoder index is found.
 			motor->m_iq_set = 0.4 * conf_now->lo_current_max;
 		}
-	} else {
+	}
+	else
+	{
 		motor->m_iq_set = output * conf_now->lo_current_max;
 	}
 }
 
-static void run_pid_control_speed(float dt, volatile motor_all_state_t *motor) {
-	volatile mc_configuration *conf_now = motor->m_conf;
+static void run_pid_control_speed(float dt, volatile motor_all_state_t* motor)
+{
+	volatile mc_configuration* conf_now = motor->m_conf;
 	float p_term;
 	float d_term;
-
+	
 	// PID is off. Return.
-	if (motor->m_control_mode != CONTROL_MODE_SPEED) {
+	if (motor->m_control_mode != CONTROL_MODE_SPEED)
+	{
 		motor->m_speed_i_term = 0.0;
 		motor->m_speed_prev_error = 0.0;
 		return;
 	}
-
+	
 	const float rpm = mcpwm_foc_get_rpm();
 	float error = motor->m_speed_pid_set_rpm - rpm;
-
+	
 	// Too low RPM set. Reset state and return.
-	if (fabsf(motor->m_speed_pid_set_rpm) < conf_now->s_pid_min_erpm) {
+	if (fabsf(motor->m_speed_pid_set_rpm) < conf_now->s_pid_min_erpm)
+	{
 		motor->m_speed_i_term = 0.0;
 		motor->m_speed_prev_error = error;
 		return;
 	}
-
+	
 	// Compute parameters
 	p_term = error * conf_now->s_pid_kp * (1.0 / 20.0);
 	motor->m_speed_i_term += error * (conf_now->s_pid_ki * dt) * (1.0 / 20.0);
 	d_term = (error - motor->m_speed_prev_error) * (conf_now->s_pid_kd / dt) * (1.0 / 20.0);
-
+	
 	// Filter D
 	UTILS_LP_FAST(motor->m_speed_d_filter, d_term, conf_now->s_pid_kd_filter);
 	d_term = motor->m_speed_d_filter;
-
+	
 	// I-term wind-up protection
 	utils_truncate_number((float*)&motor->m_speed_i_term, -1.0, 1.0);
-
+	
 	// Store previous error
 	motor->m_speed_prev_error = error;
-
+	
 	// Calculate output
 	float output = p_term + motor->m_speed_i_term + d_term;
 	utils_truncate_number(&output, -1.0, 1.0);
-
+	
 	// Optionally disable braking
-	if (!conf_now->s_pid_allow_braking) {
-		if (rpm > 20.0 && output < 0.0) {
+	if (!conf_now->s_pid_allow_braking)
+	{
+		if (rpm > 20.0 && output < 0.0)
+		{
 			output = 0.0;
 		}
-
-		if (rpm < -20.0 && output > 0.0) {
+		
+		if (rpm < -20.0 && output > 0.0)
+		{
 			output = 0.0;
 		}
 	}
-
+	
 	motor->m_iq_set = output * conf_now->lo_current_max;
 }
 
-static void stop_pwm_hw(volatile motor_all_state_t *motor) {
+static void stop_pwm_hw(volatile motor_all_state_t* motor)
+{
 	motor->m_id_set = 0.0;
 	motor->m_iq_set = 0.0;
-
-	if (motor == &m_motor_1) {
+	
+	if (motor == &m_motor_1)
+	{
 		TIM_SelectOCxM(TIM1, TIM_Channel_1, TIM_ForcedAction_InActive);
 		TIM_CCxCmd(TIM1, TIM_Channel_1, TIM_CCx_Enable);
 		TIM_CCxNCmd(TIM1, TIM_Channel_1, TIM_CCxN_Disable);
-
+		
 		TIM_SelectOCxM(TIM1, TIM_Channel_2, TIM_ForcedAction_InActive);
 		TIM_CCxCmd(TIM1, TIM_Channel_2, TIM_CCx_Enable);
 		TIM_CCxNCmd(TIM1, TIM_Channel_2, TIM_CCxN_Disable);
-
+		
 		TIM_SelectOCxM(TIM1, TIM_Channel_3, TIM_ForcedAction_InActive);
 		TIM_CCxCmd(TIM1, TIM_Channel_3, TIM_CCx_Enable);
 		TIM_CCxNCmd(TIM1, TIM_Channel_3, TIM_CCxN_Disable);
-
+		
 		TIM_GenerateEvent(TIM1, TIM_EventSource_COM);
 
 #ifdef HW_HAS_DUAL_PARALLEL
@@ -3713,41 +4204,45 @@
 #ifdef HW_HAS_DRV8313
 		DISABLE_BR();
 #endif
-
+		
 		motor->m_output_on = false;
-	} else {
+	}
+	else
+	{
 		TIM_SelectOCxM(TIM8, TIM_Channel_1, TIM_ForcedAction_InActive);
 		TIM_CCxCmd(TIM8, TIM_Channel_1, TIM_CCx_Enable);
 		TIM_CCxNCmd(TIM8, TIM_Channel_1, TIM_CCxN_Disable);
-
+		
 		TIM_SelectOCxM(TIM8, TIM_Channel_2, TIM_ForcedAction_InActive);
 		TIM_CCxCmd(TIM8, TIM_Channel_2, TIM_CCx_Enable);
 		TIM_CCxNCmd(TIM8, TIM_Channel_2, TIM_CCxN_Disable);
-
+		
 		TIM_SelectOCxM(TIM8, TIM_Channel_3, TIM_ForcedAction_InActive);
 		TIM_CCxCmd(TIM8, TIM_Channel_3, TIM_CCx_Enable);
 		TIM_CCxNCmd(TIM8, TIM_Channel_3, TIM_CCxN_Disable);
-
+		
 		TIM_GenerateEvent(TIM8, TIM_EventSource_COM);
 
 #ifdef HW_HAS_DRV8313_2
 		DISABLE_BR_2();
 #endif
-
+		
 		motor->m_output_on = false;
 	}
 }
 
-static void start_pwm_hw(volatile motor_all_state_t *motor) {
-	if (motor == &m_motor_1) {
+static void start_pwm_hw(volatile motor_all_state_t* motor)
+{
+	if (motor == &m_motor_1)
+	{
 		TIM_SelectOCxM(TIM1, TIM_Channel_1, TIM_OCMode_PWM1);
 		TIM_CCxCmd(TIM1, TIM_Channel_1, TIM_CCx_Enable);
 		TIM_CCxNCmd(TIM1, TIM_Channel_1, TIM_CCxN_Enable);
-
+		
 		TIM_SelectOCxM(TIM1, TIM_Channel_2, TIM_OCMode_PWM1);
 		TIM_CCxCmd(TIM1, TIM_Channel_2, TIM_CCx_Enable);
 		TIM_CCxNCmd(TIM1, TIM_Channel_2, TIM_CCxN_Enable);
-
+		
 		TIM_SelectOCxM(TIM1, TIM_Channel_3, TIM_OCMode_PWM1);
 		TIM_CCxCmd(TIM1, TIM_Channel_3, TIM_CCx_Enable);
 		TIM_CCxNCmd(TIM1, TIM_Channel_3, TIM_CCxN_Enable);
@@ -3765,7 +4260,7 @@
 		TIM_CCxCmd(TIM8, TIM_Channel_3, TIM_CCx_Enable);
 		TIM_CCxNCmd(TIM8, TIM_Channel_3, TIM_CCxN_Enable);
 #endif
-
+		
 		// Generate COM event in ADC interrupt to get better synchronization
 		//	TIM_GenerateEvent(TIM1, TIM_EventSource_COM);
 
@@ -3773,15 +4268,17 @@
 		ENABLE_BR();
 #endif
 		motor->m_output_on = true;
-	} else {
+	}
+	else
+	{
 		TIM_SelectOCxM(TIM8, TIM_Channel_1, TIM_OCMode_PWM1);
 		TIM_CCxCmd(TIM8, TIM_Channel_1, TIM_CCx_Enable);
 		TIM_CCxNCmd(TIM8, TIM_Channel_1, TIM_CCxN_Enable);
-
+		
 		TIM_SelectOCxM(TIM8, TIM_Channel_2, TIM_OCMode_PWM1);
 		TIM_CCxCmd(TIM8, TIM_Channel_2, TIM_CCx_Enable);
 		TIM_CCxNCmd(TIM8, TIM_Channel_2, TIM_CCxN_Enable);
-
+		
 		TIM_SelectOCxM(TIM8, TIM_Channel_3, TIM_OCMode_PWM1);
 		TIM_CCxCmd(TIM8, TIM_Channel_3, TIM_CCx_Enable);
 		TIM_CCxNCmd(TIM8, TIM_Channel_3, TIM_CCxN_Enable);
@@ -3793,128 +4290,169 @@
 	}
 }
 
-static float correct_encoder(float obs_angle, float enc_angle, float speed,
-							 float sl_erpm, volatile motor_all_state_t *motor) {
+static float correct_encoder(
+	float obs_angle, float enc_angle, float speed,
+	float sl_erpm, volatile motor_all_state_t* motor
+)
+{
 	float rpm_abs = fabsf(speed / ((2.0 * M_PI) / 60.0));
-
+	
 	// Hysteresis 5 % of total speed
 	float hyst = sl_erpm * 0.05;
-	if (motor->m_using_encoder) {
-		if (rpm_abs > (sl_erpm + hyst)) {
+	if (motor->m_using_encoder)
+	{
+		if (rpm_abs > (sl_erpm + hyst))
+		{
 			motor->m_using_encoder = false;
 		}
-	} else {
-		if (rpm_abs < (sl_erpm- hyst)) {
+	}
+	else
+	{
+		if (rpm_abs < (sl_erpm - hyst))
+		{
 			motor->m_using_encoder = true;
 		}
 	}
-
+	
 	return motor->m_using_encoder ? enc_angle : obs_angle;
 }
 
-static float correct_hall(float angle, float dt, volatile motor_all_state_t *motor) {
-	volatile mc_configuration *conf_now = motor->m_conf;
+static float correct_hall(float angle, float dt, volatile motor_all_state_t* motor)
+{
+	volatile mc_configuration* conf_now = motor->m_conf;
 	motor->m_hall_dt_diff_now += dt;
-
+	
 	float rad_per_sec = (M_PI / 3.0) / motor->m_hall_dt_diff_last;
 	float rpm_abs_fast = fabsf(motor->m_speed_est_fast / ((2.0 * M_PI) / 60.0));
 	float rpm_abs_hall = fabsf(rad_per_sec / ((2.0 * M_PI) / 60.0));
-
+	
 	// Hysteresis 5 % of total speed
 	float hyst = conf_now->foc_sl_erpm * 0.1;
-	if (motor->m_using_hall) {
-		if (fminf(rpm_abs_fast, rpm_abs_hall) > (conf_now->foc_sl_erpm + hyst)) {
+	if (motor->m_using_hall)
+	{
+		if (fminf(rpm_abs_fast, rpm_abs_hall) > (conf_now->foc_sl_erpm + hyst))
+		{
 			motor->m_using_hall = false;
 		}
-	} else {
-		if (rpm_abs_fast < (conf_now->foc_sl_erpm - hyst)) {
+	}
+	else
+	{
+		if (rpm_abs_fast < (conf_now->foc_sl_erpm - hyst))
+		{
 			motor->m_using_hall = true;
 		}
 	}
-
+	
 	int ang_hall_int = conf_now->foc_hall_table[utils_read_hall(motor != &m_motor_1)];
-
+	
 	// Only override the observer if the hall sensor value is valid.
-	if (ang_hall_int < 201) {
+	if (ang_hall_int < 201)
+	{
 		float ang_hall_now = (((float)ang_hall_int / 200.0) * 360.0) * M_PI / 180.0;
-
-		if (motor->m_ang_hall_int_prev < 0) {
+		
+		if (motor->m_ang_hall_int_prev < 0)
+		{
 			// Previous angle not valid
 			motor->m_ang_hall_int_prev = ang_hall_int;
 			motor->m_ang_hall = ang_hall_now;
-		} else if (ang_hall_int != motor->m_ang_hall_int_prev) {
+		}
+		else if (ang_hall_int != motor->m_ang_hall_int_prev)
+		{
 			int diff = ang_hall_int - motor->m_ang_hall_int_prev;
-			if (diff > 100) {
+			if (diff > 100)
+			{
 				diff -= 200;
-			} else if (diff < -100) {
+			}
+			else if (diff < -100)
+			{
 				diff += 200;
 			}
-
+			
 			// This is only valid if the direction did not just change. If it did, we use the
 			// last speed together with the sign right now.
-			if (SIGN(diff) == SIGN(motor->m_hall_dt_diff_last)) {
-				if (diff > 0) {
+			if (SIGN(diff) == SIGN(motor->m_hall_dt_diff_last))
+			{
+				if (diff > 0)
+				{
 					motor->m_hall_dt_diff_last = motor->m_hall_dt_diff_now;
-				} else {
+				}
+				else
+				{
 					motor->m_hall_dt_diff_last = -motor->m_hall_dt_diff_now;
 				}
-			} else {
+			}
+			else
+			{
 				motor->m_hall_dt_diff_last = -motor->m_hall_dt_diff_last;
 			}
-
+			
 			motor->m_hall_dt_diff_now = 0.0;
-
+			
 			// A transition was just made. The angle is in the middle of the new and old angle.
 			int ang_avg = motor->m_ang_hall_int_prev + diff / 2;
 			ang_avg %= 200;
 			motor->m_ang_hall = (((float)ang_avg / 200.0) * 360.0) * M_PI / 180.0;
 		}
-
+		
 		motor->m_ang_hall_int_prev = ang_hall_int;
-
-		if (((60.0 / (2.0 * M_PI)) * ((M_PI / 3.0) / motor->m_hall_dt_diff_now)) < 100) {
+		
+		if (((60.0 / (2.0 * M_PI)) * ((M_PI / 3.0) / motor->m_hall_dt_diff_now)) < 100)
+		{
 			// Don't interpolate on very low speed, just use the closest hall sensor. The reason is that we might
 			// get stuck at 60 degrees off if a direction change happens between two steps.
 			motor->m_ang_hall = ang_hall_now;
-		} else {
+		}
+		else
+		{
 			// Interpolate
 			float diff = utils_angle_difference_rad(motor->m_ang_hall, ang_hall_now);
-			if (fabsf(diff) < ((2.0 * M_PI) / 12.0)) {
+			if (fabsf(diff) < ((2.0 * M_PI) / 12.0))
+			{
 				// Do interpolation
 				motor->m_ang_hall += rad_per_sec * dt;
-			} else {
+			}
+			else
+			{
 				// We are too far away with the interpolation
 				motor->m_ang_hall -= diff / 100.0;
 			}
 		}
-
+		
 		utils_norm_angle_rad((float*)&motor->m_ang_hall);
-		if (motor->m_using_hall) {
+		if (motor->m_using_hall)
+		{
 			angle = motor->m_ang_hall;
 		}
-	} else {
+	}
+	else
+	{
 		// Invalid hall reading. Don't update angle.
 		motor->m_ang_hall_int_prev = -1;
-
+		
 		// Also allow open loop in order to behave like normal sensorless
 		// operation. Then the motor works even if the hall sensor cable
 		// gets disconnected (when the sensor spacing is 120 degrees).
-		if (motor->m_phase_observer_override && motor->m_state == MC_STATE_RUNNING) {
+		if (motor->m_phase_observer_override && motor->m_state == MC_STATE_RUNNING)
+		{
 			angle = motor->m_phase_now_observer_override;
 		}
 	}
-
+	
 	return angle;
 }
 
-static void terminal_plot_hfi(int argc, const char **argv) {
-	if (argc == 2) {
+static void terminal_plot_hfi(int argc, const char** argv)
+{
+	if (argc == 2)
+	{
 		int d = -1;
 		sscanf(argv[1], "%d", &d);
-
-		if (d == 0 || d == 1 || d == 2) {
+		
+		if (d == 0 || d == 1 || d == 2)
+		{
 			motor_now()->m_hfi_plot_en = d;
-			if (motor_now()->m_hfi_plot_en == 1) {
+			if (motor_now()->m_hfi_plot_en == 1)
+			{
 				motor_now()->m_hfi_plot_sample = 0.0;
 				commands_init_plot("Sample", "Value");
 				commands_plot_add_graph("Phase");
@@ -3922,20 +4460,28 @@
 				commands_plot_add_graph("Ld - Lq (uH");
 				commands_plot_add_graph("L Diff Sat (uH)");
 				commands_plot_add_graph("L Avg (uH)");
-			} else if (motor_now()->m_hfi_plot_en == 2) {
+			}
+			else if (motor_now()->m_hfi_plot_en == 2)
+			{
 				motor_now()->m_hfi_plot_sample = 0.0;
 				commands_init_plot("Sample Index", "Value");
 				commands_plot_add_graph("Current (A)");
 				commands_plot_add_graph("Inductance (uH)");
 			}
-
-			commands_printf(motor_now()->m_hfi_plot_en ?
-					"HFI plot enabled" :
-					"HFI plot disabled");
-		} else {
+			
+			commands_printf(
+				motor_now()->m_hfi_plot_en ?
+				"HFI plot enabled" :
+				"HFI plot disabled"
+			);
+		}
+		else
+		{
 			commands_printf("Invalid Argument. en has to be 0, 1 or 2.\n");
 		}
-	} else {
+	}
+	else
+	{
 		commands_printf("This command requires one argument.\n");
 	}
 }
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
new file mode 100755
--- /dev/null	
+++ b/.idea/workspace.xml	
@@ -0,0 +1,489 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="AutoImportSettings">
+    <option name="autoReloadType" value="SELECTIVE" />
+  </component>
+  <component name="CMakeRunConfigurationManager" shouldGenerate="true" shouldDeleteObsolete="true">
+    <generated>
+      <config projectName="bldc" targetName="all" />
+      <config projectName="bldc" targetName="upload" />
+      <config projectName="bldc" targetName="Makefile" />
+      <config projectName="bldc" targetName="lib" />
+      <config projectName="bldc" targetName="debug-start" />
+      <config projectName="bldc" targetName="POST_MAKE_ALL_RULE_HOOK" />
+      <config projectName="bldc" targetName="upload-pi" />
+      <config projectName="bldc" targetName="build" />
+      <config projectName="bldc" targetName="upload-olimex" />
+      <config projectName="bldc" targetName="upload-pi-remote" />
+      <config projectName="bldc" targetName="clear_option_bytes" />
+      <config projectName="bldc" targetName="PRE_MAKE_ALL_RULE_HOOK" />
+    </generated>
+  </component>
+  <component name="CMakeSettings">
+    <configurations>
+      <configuration PROFILE_NAME="Debug" CONFIG_NAME="Debug" ENABLED="true" />
+    </configurations>
+  </component>
+  <component name="ChangeListManager">
+    <list default="true" id="a65eb43f-e36c-45c9-bc3b-94b7eaacf8ae" name="Default Changelist" comment="">
+      <change afterPath="$PROJECT_DIR$/.idea/bldc.iml" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/.idea/inspectionProfiles/Project_Default.xml" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/.idea/misc.xml" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/.idea/modules.xml" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/.idea/vcs.xml" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/.vscode/c_cpp_properties.json" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.gitignore" beforeDir="false" afterPath="$PROJECT_DIR$/.gitignore" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.travis.yml" beforeDir="false" afterPath="$PROJECT_DIR$/.travis.yml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/CHANGELOG" beforeDir="false" afterPath="$PROJECT_DIR$/CHANGELOG" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/CONTRIBUTING" beforeDir="false" afterPath="$PROJECT_DIR$/CONTRIBUTING" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/ChibiOS_3.0.5/ext/stdperiph_stm32f4/inc/stm32f4_gpio_af.h" beforeDir="false" afterPath="$PROJECT_DIR$/ChibiOS_3.0.5/ext/stdperiph_stm32f4/inc/stm32f4_gpio_af.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/ChibiOS_3.0.5/ext/stdperiph_stm32f4/inc/stm32f4xx_iwdg.h" beforeDir="false" afterPath="$PROJECT_DIR$/ChibiOS_3.0.5/ext/stdperiph_stm32f4/inc/stm32f4xx_iwdg.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/ChibiOS_3.0.5/ext/stdperiph_stm32f4/src/stm32f4xx_iwdg.c" beforeDir="false" afterPath="$PROJECT_DIR$/ChibiOS_3.0.5/ext/stdperiph_stm32f4/src/stm32f4xx_iwdg.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/ChibiOS_3.0.5/license.txt" beforeDir="false" afterPath="$PROJECT_DIR$/ChibiOS_3.0.5/license.txt" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Makefile" beforeDir="false" afterPath="$PROJECT_DIR$/Makefile" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/README.md" beforeDir="false" afterPath="$PROJECT_DIR$/README.md" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/appconf/appconf_custom.h" beforeDir="false" afterPath="$PROJECT_DIR$/appconf/appconf_custom.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/appconf/appconf_default.h" beforeDir="false" afterPath="$PROJECT_DIR$/appconf/appconf_default.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/appconf/appconf_example_ppm.h" beforeDir="false" afterPath="$PROJECT_DIR$/appconf/appconf_example_ppm.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/applications/app.c" beforeDir="false" afterPath="$PROJECT_DIR$/applications/app.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/applications/app.h" beforeDir="false" afterPath="$PROJECT_DIR$/applications/app.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/applications/app_adc.c" beforeDir="false" afterPath="$PROJECT_DIR$/applications/app_adc.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/applications/app_balance.c" beforeDir="false" afterPath="$PROJECT_DIR$/applications/app_balance.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/applications/app_custom.c" beforeDir="false" afterPath="$PROJECT_DIR$/applications/app_custom.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/applications/app_custom_template.c" beforeDir="false" afterPath="$PROJECT_DIR$/applications/app_custom_template.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/applications/app_nunchuk.c" beforeDir="false" afterPath="$PROJECT_DIR$/applications/app_nunchuk.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/applications/app_ppm.c" beforeDir="false" afterPath="$PROJECT_DIR$/applications/app_ppm.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/applications/app_skypuff.c" beforeDir="false" afterPath="$PROJECT_DIR$/applications/app_skypuff.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/applications/app_sten.c" beforeDir="false" afterPath="$PROJECT_DIR$/applications/app_sten.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/applications/app_uartcomm.c" beforeDir="false" afterPath="$PROJECT_DIR$/applications/app_uartcomm.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/applications/applications.mk" beforeDir="false" afterPath="$PROJECT_DIR$/applications/applications.mk" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/blackmagic/README.md" beforeDir="false" afterPath="$PROJECT_DIR$/blackmagic/README.md" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/blackmagic/blackmagic.mk" beforeDir="false" afterPath="$PROJECT_DIR$/blackmagic/blackmagic.mk" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/blackmagic/bm_if.c" beforeDir="false" afterPath="$PROJECT_DIR$/blackmagic/bm_if.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/blackmagic/bm_if.h" beforeDir="false" afterPath="$PROJECT_DIR$/blackmagic/bm_if.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/blackmagic/exception.c" beforeDir="false" afterPath="$PROJECT_DIR$/blackmagic/exception.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/blackmagic/exception.h" beforeDir="false" afterPath="$PROJECT_DIR$/blackmagic/exception.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/blackmagic/general.h" beforeDir="false" afterPath="$PROJECT_DIR$/blackmagic/general.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/blackmagic/platform.c" beforeDir="false" afterPath="$PROJECT_DIR$/blackmagic/platform.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/blackmagic/platform.h" beforeDir="false" afterPath="$PROJECT_DIR$/blackmagic/platform.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/blackmagic/platform_support.h" beforeDir="false" afterPath="$PROJECT_DIR$/blackmagic/platform_support.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/blackmagic/swdptap.c" beforeDir="false" afterPath="$PROJECT_DIR$/blackmagic/swdptap.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/blackmagic/swdptap.h" beforeDir="false" afterPath="$PROJECT_DIR$/blackmagic/swdptap.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/blackmagic/target.h" beforeDir="false" afterPath="$PROJECT_DIR$/blackmagic/target.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/blackmagic/target/adiv5.c" beforeDir="false" afterPath="$PROJECT_DIR$/blackmagic/target/adiv5.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/blackmagic/target/adiv5.h" beforeDir="false" afterPath="$PROJECT_DIR$/blackmagic/target/adiv5.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/blackmagic/target/adiv5_jtagdp.c" beforeDir="false" afterPath="$PROJECT_DIR$/blackmagic/target/adiv5_jtagdp.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/blackmagic/target/adiv5_swdp.c" beforeDir="false" afterPath="$PROJECT_DIR$/blackmagic/target/adiv5_swdp.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/blackmagic/target/cortexm.c" beforeDir="false" afterPath="$PROJECT_DIR$/blackmagic/target/cortexm.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/blackmagic/target/cortexm.h" beforeDir="false" afterPath="$PROJECT_DIR$/blackmagic/target/cortexm.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/blackmagic/target/flashstub/Makefile" beforeDir="false" afterPath="$PROJECT_DIR$/blackmagic/target/flashstub/Makefile" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/blackmagic/target/flashstub/README.md" beforeDir="false" afterPath="$PROJECT_DIR$/blackmagic/target/flashstub/README.md" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/blackmagic/target/flashstub/nrf51.c" beforeDir="false" afterPath="$PROJECT_DIR$/blackmagic/target/flashstub/nrf51.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/blackmagic/target/flashstub/stub.h" beforeDir="false" afterPath="$PROJECT_DIR$/blackmagic/target/flashstub/stub.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/blackmagic/target/jtag_scan.h" beforeDir="false" afterPath="$PROJECT_DIR$/blackmagic/target/jtag_scan.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/blackmagic/target/nrf51.c" beforeDir="false" afterPath="$PROJECT_DIR$/blackmagic/target/nrf51.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/blackmagic/target/stm32f1.c" beforeDir="false" afterPath="$PROJECT_DIR$/blackmagic/target/stm32f1.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/blackmagic/target/stm32f4.c" beforeDir="false" afterPath="$PROJECT_DIR$/blackmagic/target/stm32f4.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/blackmagic/target/stm32h7.c" beforeDir="false" afterPath="$PROJECT_DIR$/blackmagic/target/stm32h7.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/blackmagic/target/stm32l0.c" beforeDir="false" afterPath="$PROJECT_DIR$/blackmagic/target/stm32l0.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/blackmagic/target/stm32l4.c" beforeDir="false" afterPath="$PROJECT_DIR$/blackmagic/target/stm32l4.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/blackmagic/target/swdptap_generic.c" beforeDir="false" afterPath="$PROJECT_DIR$/blackmagic/target/swdptap_generic.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/blackmagic/target/target.c" beforeDir="false" afterPath="$PROJECT_DIR$/blackmagic/target/target.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/blackmagic/target/target_internal.h" beforeDir="false" afterPath="$PROJECT_DIR$/blackmagic/target/target_internal.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/blackmagic/timing.c" beforeDir="false" afterPath="$PROJECT_DIR$/blackmagic/timing.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/blackmagic/timing.h" beforeDir="false" afterPath="$PROJECT_DIR$/blackmagic/timing.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/buffer.c" beforeDir="false" afterPath="$PROJECT_DIR$/buffer.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/buffer.h" beforeDir="false" afterPath="$PROJECT_DIR$/buffer.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/build_all/README.md" beforeDir="false" afterPath="$PROJECT_DIR$/build_all/README.md" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/build_all/rebuild_all" beforeDir="false" afterPath="$PROJECT_DIR$/build_all/rebuild_all" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/chconf.h" beforeDir="false" afterPath="$PROJECT_DIR$/chconf.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/comm_can.c" beforeDir="false" afterPath="$PROJECT_DIR$/comm_can.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/comm_can.h" beforeDir="false" afterPath="$PROJECT_DIR$/comm_can.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/comm_usb.c" beforeDir="false" afterPath="$PROJECT_DIR$/comm_usb.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/comm_usb.h" beforeDir="false" afterPath="$PROJECT_DIR$/comm_usb.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/comm_usb_serial.c" beforeDir="false" afterPath="$PROJECT_DIR$/comm_usb_serial.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/comm_usb_serial.h" beforeDir="false" afterPath="$PROJECT_DIR$/comm_usb_serial.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/commands.c" beforeDir="false" afterPath="$PROJECT_DIR$/commands.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/commands.h" beforeDir="false" afterPath="$PROJECT_DIR$/commands.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/compression/README.LZO" beforeDir="false" afterPath="$PROJECT_DIR$/compression/README.LZO" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/compression/compression.mk" beforeDir="false" afterPath="$PROJECT_DIR$/compression/compression.mk" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/compression/lzoconf.h" beforeDir="false" afterPath="$PROJECT_DIR$/compression/lzoconf.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/compression/lzodefs.h" beforeDir="false" afterPath="$PROJECT_DIR$/compression/lzodefs.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/compression/minilzo.c" beforeDir="false" afterPath="$PROJECT_DIR$/compression/minilzo.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/compression/minilzo.h" beforeDir="false" afterPath="$PROJECT_DIR$/compression/minilzo.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/conf_general.c" beforeDir="false" afterPath="$PROJECT_DIR$/conf_general.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/conf_general.h" beforeDir="false" afterPath="$PROJECT_DIR$/conf_general.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/confgenerator.c" beforeDir="false" afterPath="$PROJECT_DIR$/confgenerator.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/confgenerator.h" beforeDir="false" afterPath="$PROJECT_DIR$/confgenerator.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/crc.c" beforeDir="false" afterPath="$PROJECT_DIR$/crc.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/crc.h" beforeDir="false" afterPath="$PROJECT_DIR$/crc.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/datatypes.h" beforeDir="false" afterPath="$PROJECT_DIR$/datatypes.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/digital_filter.c" beforeDir="false" afterPath="$PROJECT_DIR$/digital_filter.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/digital_filter.h" beforeDir="false" afterPath="$PROJECT_DIR$/digital_filter.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/eeprom.c" beforeDir="false" afterPath="$PROJECT_DIR$/eeprom.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/eeprom.h" beforeDir="false" afterPath="$PROJECT_DIR$/eeprom.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/encoder.c" beforeDir="false" afterPath="$PROJECT_DIR$/encoder.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/encoder.h" beforeDir="false" afterPath="$PROJECT_DIR$/encoder.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/flash_helper.c" beforeDir="false" afterPath="$PROJECT_DIR$/flash_helper.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/flash_helper.h" beforeDir="false" afterPath="$PROJECT_DIR$/flash_helper.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/gpdrive.c" beforeDir="false" afterPath="$PROJECT_DIR$/gpdrive.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/gpdrive.h" beforeDir="false" afterPath="$PROJECT_DIR$/gpdrive.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/halconf.h" beforeDir="false" afterPath="$PROJECT_DIR$/halconf.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/drv8301.c" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/drv8301.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/drv8301.h" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/drv8301.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/drv8305.c" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/drv8305.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/drv8305.h" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/drv8305.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/drv8320s.c" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/drv8320s.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/drv8320s.h" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/drv8320s.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/drv8323s.c" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/drv8323s.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/drv8323s.h" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/drv8323s.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw.c" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw.h" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_100_250.c" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_100_250.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_100_250.h" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_100_250.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_40.c" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_40.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_40.h" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_40.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_410.c" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_410.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_410.h" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_410.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_45.c" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_45.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_45.h" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_45.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_46.c" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_46.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_46.h" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_46.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_48.c" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_48.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_48.h" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_48.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_49.c" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_49.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_49.h" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_49.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_60.c" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_60.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_60.h" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_60.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_75_300.c" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_75_300.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_75_300.h" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_75_300.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_a200s_v2.c" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_a200s_v2.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_a200s_v2.h" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_a200s_v2.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_axiom.c" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_axiom.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_axiom.h" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_axiom.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_axiom_fpga_bitstream.c" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_axiom_fpga_bitstream.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_binar_v1.c" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_binar_v1.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_binar_v1.h" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_binar_v1.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_das_mini.c" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_das_mini.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_das_mini.h" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_das_mini.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_das_rs.c" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_das_rs.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_das_rs.h" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_das_rs.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_hd.c" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_hd.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_hd.h" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_hd.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_luna_bbshd.c" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_luna_bbshd.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_luna_bbshd.h" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_luna_bbshd.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_mini4.c" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_mini4.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_mini4.h" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_mini4.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_r2.c" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_r2.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_r2.h" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_r2.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_rd2.c" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_rd2.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_rd2.h" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_rd2.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_rh.c" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_rh.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_rh.h" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_rh.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_stormcore_100d.c" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_stormcore_100d.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_stormcore_100d.h" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_stormcore_100d.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_stormcore_100s.c" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_stormcore_100s.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_stormcore_100s.h" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_stormcore_100s.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_stormcore_60d.c" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_stormcore_60d.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_stormcore_60d.h" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_stormcore_60d.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_tp.c" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_tp.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_tp.h" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_tp.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_uavc_omega.c" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_uavc_omega.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_uavc_omega.h" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_uavc_omega.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_uavc_qcube.c" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_uavc_qcube.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_uavc_qcube.h" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_uavc_qcube.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_victor_r1a.c" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_victor_r1a.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hw_victor_r1a.h" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hw_victor_r1a.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hwconf/hwconf.mk" beforeDir="false" afterPath="$PROJECT_DIR$/hwconf/hwconf.mk" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/i2c_bb.c" beforeDir="false" afterPath="$PROJECT_DIR$/i2c_bb.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/i2c_bb.h" beforeDir="false" afterPath="$PROJECT_DIR$/i2c_bb.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/imu/BMI160_driver/LICENSE" beforeDir="false" afterPath="$PROJECT_DIR$/imu/BMI160_driver/LICENSE" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/imu/BMI160_driver/README.md" beforeDir="false" afterPath="$PROJECT_DIR$/imu/BMI160_driver/README.md" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/imu/BMI160_driver/bmi160.c" beforeDir="false" afterPath="$PROJECT_DIR$/imu/BMI160_driver/bmi160.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/imu/BMI160_driver/bmi160.h" beforeDir="false" afterPath="$PROJECT_DIR$/imu/BMI160_driver/bmi160.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/imu/BMI160_driver/bmi160_defs.h" beforeDir="false" afterPath="$PROJECT_DIR$/imu/BMI160_driver/bmi160_defs.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/imu/ahrs.c" beforeDir="false" afterPath="$PROJECT_DIR$/imu/ahrs.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/imu/ahrs.h" beforeDir="false" afterPath="$PROJECT_DIR$/imu/ahrs.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/imu/bmi160_wrapper.c" beforeDir="false" afterPath="$PROJECT_DIR$/imu/bmi160_wrapper.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/imu/bmi160_wrapper.h" beforeDir="false" afterPath="$PROJECT_DIR$/imu/bmi160_wrapper.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/imu/icm20948.c" beforeDir="false" afterPath="$PROJECT_DIR$/imu/icm20948.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/imu/icm20948.h" beforeDir="false" afterPath="$PROJECT_DIR$/imu/icm20948.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/imu/imu.c" beforeDir="false" afterPath="$PROJECT_DIR$/imu/imu.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/imu/imu.h" beforeDir="false" afterPath="$PROJECT_DIR$/imu/imu.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/imu/imu.mk" beforeDir="false" afterPath="$PROJECT_DIR$/imu/imu.mk" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/imu/mpu9150.c" beforeDir="false" afterPath="$PROJECT_DIR$/imu/mpu9150.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/imu/mpu9150.h" beforeDir="false" afterPath="$PROJECT_DIR$/imu/mpu9150.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/irq_handlers.c" beforeDir="false" afterPath="$PROJECT_DIR$/irq_handlers.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/isr_vector_table.h" beforeDir="false" afterPath="$PROJECT_DIR$/isr_vector_table.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/led_external.c" beforeDir="false" afterPath="$PROJECT_DIR$/led_external.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/led_external.h" beforeDir="false" afterPath="$PROJECT_DIR$/led_external.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/ledpwm.c" beforeDir="false" afterPath="$PROJECT_DIR$/ledpwm.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/ledpwm.h" beforeDir="false" afterPath="$PROJECT_DIR$/ledpwm.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/libcanard/README.md" beforeDir="false" afterPath="$PROJECT_DIR$/libcanard/README.md" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/libcanard/canard.c" beforeDir="false" afterPath="$PROJECT_DIR$/libcanard/canard.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/libcanard/canard.h" beforeDir="false" afterPath="$PROJECT_DIR$/libcanard/canard.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/libcanard/canard.mk" beforeDir="false" afterPath="$PROJECT_DIR$/libcanard/canard.mk" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/libcanard/canard_driver.c" beforeDir="false" afterPath="$PROJECT_DIR$/libcanard/canard_driver.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/libcanard/canard_driver.h" beforeDir="false" afterPath="$PROJECT_DIR$/libcanard/canard_driver.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/libcanard/canard_internals.h" beforeDir="false" afterPath="$PROJECT_DIR$/libcanard/canard_internals.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/libcanard/dsdl/uavcan/equipment/esc/RPMCommand.h" beforeDir="false" afterPath="$PROJECT_DIR$/libcanard/dsdl/uavcan/equipment/esc/RPMCommand.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/libcanard/dsdl/uavcan/equipment/esc/RawCommand.h" beforeDir="false" afterPath="$PROJECT_DIR$/libcanard/dsdl/uavcan/equipment/esc/RawCommand.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/libcanard/dsdl/uavcan/equipment/esc/Status.h" beforeDir="false" afterPath="$PROJECT_DIR$/libcanard/dsdl/uavcan/equipment/esc/Status.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/libcanard/dsdl/uavcan/equipment/esc/esc_RPMCommand.c" beforeDir="false" afterPath="$PROJECT_DIR$/libcanard/dsdl/uavcan/equipment/esc/esc_RPMCommand.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/libcanard/dsdl/uavcan/equipment/esc/esc_RawCommand.c" beforeDir="false" afterPath="$PROJECT_DIR$/libcanard/dsdl/uavcan/equipment/esc/esc_RawCommand.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/libcanard/dsdl/uavcan/equipment/esc/esc_Status.c" beforeDir="false" afterPath="$PROJECT_DIR$/libcanard/dsdl/uavcan/equipment/esc/esc_Status.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/libcanard/dsdl/uavcan/equipment/power/BatteryInfo.h" beforeDir="false" afterPath="$PROJECT_DIR$/libcanard/dsdl/uavcan/equipment/power/BatteryInfo.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/libcanard/dsdl/uavcan/equipment/power/CircuitStatus.h" beforeDir="false" afterPath="$PROJECT_DIR$/libcanard/dsdl/uavcan/equipment/power/CircuitStatus.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/libcanard/dsdl/uavcan/equipment/power/PrimaryPowerSupplyStatus.h" beforeDir="false" afterPath="$PROJECT_DIR$/libcanard/dsdl/uavcan/equipment/power/PrimaryPowerSupplyStatus.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/libcanard/dsdl/uavcan/equipment/power/power_BatteryInfo.c" beforeDir="false" afterPath="$PROJECT_DIR$/libcanard/dsdl/uavcan/equipment/power/power_BatteryInfo.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/libcanard/dsdl/uavcan/equipment/power/power_CircuitStatus.c" beforeDir="false" afterPath="$PROJECT_DIR$/libcanard/dsdl/uavcan/equipment/power/power_CircuitStatus.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/libcanard/dsdl/uavcan/equipment/power/power_PrimaryPowerSupplyStatus.c" beforeDir="false" afterPath="$PROJECT_DIR$/libcanard/dsdl/uavcan/equipment/power/power_PrimaryPowerSupplyStatus.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/main.c" beforeDir="false" afterPath="$PROJECT_DIR$/main.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/mc_interface.c" beforeDir="false" afterPath="$PROJECT_DIR$/mc_interface.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/mc_interface.h" beforeDir="false" afterPath="$PROJECT_DIR$/mc_interface.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/mcconf/mcconf_default.h" beforeDir="false" afterPath="$PROJECT_DIR$/mcconf/mcconf_default.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/mcconf/mcconf_sten.h" beforeDir="false" afterPath="$PROJECT_DIR$/mcconf/mcconf_sten.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/mcpwm.c" beforeDir="false" afterPath="$PROJECT_DIR$/mcpwm.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/mcpwm.h" beforeDir="false" afterPath="$PROJECT_DIR$/mcpwm.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/mcpwm_foc.c" beforeDir="false" afterPath="$PROJECT_DIR$/mcpwm_foc.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/mcpwm_foc.h" beforeDir="false" afterPath="$PROJECT_DIR$/mcpwm_foc.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/mcuconf.h" beforeDir="false" afterPath="$PROJECT_DIR$/mcuconf.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/mempools.c" beforeDir="false" afterPath="$PROJECT_DIR$/mempools.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/mempools.h" beforeDir="false" afterPath="$PROJECT_DIR$/mempools.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/nrf/nrf.mk" beforeDir="false" afterPath="$PROJECT_DIR$/nrf/nrf.mk" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/nrf/nrf_driver.c" beforeDir="false" afterPath="$PROJECT_DIR$/nrf/nrf_driver.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/nrf/nrf_driver.h" beforeDir="false" afterPath="$PROJECT_DIR$/nrf/nrf_driver.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/nrf/rf.c" beforeDir="false" afterPath="$PROJECT_DIR$/nrf/rf.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/nrf/rf.h" beforeDir="false" afterPath="$PROJECT_DIR$/nrf/rf.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/nrf/rfhelp.c" beforeDir="false" afterPath="$PROJECT_DIR$/nrf/rfhelp.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/nrf/rfhelp.h" beforeDir="false" afterPath="$PROJECT_DIR$/nrf/rfhelp.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/nrf/spi_sw.c" beforeDir="false" afterPath="$PROJECT_DIR$/nrf/spi_sw.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/nrf/spi_sw.h" beforeDir="false" afterPath="$PROJECT_DIR$/nrf/spi_sw.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/packet.c" beforeDir="false" afterPath="$PROJECT_DIR$/packet.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/packet.h" beforeDir="false" afterPath="$PROJECT_DIR$/packet.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/pi_stm32.cfg" beforeDir="false" afterPath="$PROJECT_DIR$/pi_stm32.cfg" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/servo_dec.c" beforeDir="false" afterPath="$PROJECT_DIR$/servo_dec.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/servo_dec.h" beforeDir="false" afterPath="$PROJECT_DIR$/servo_dec.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/servo_simple.c" beforeDir="false" afterPath="$PROJECT_DIR$/servo_simple.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/servo_simple.h" beforeDir="false" afterPath="$PROJECT_DIR$/servo_simple.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/shutdown.c" beforeDir="false" afterPath="$PROJECT_DIR$/shutdown.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/shutdown.h" beforeDir="false" afterPath="$PROJECT_DIR$/shutdown.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/stm32-bv_openocd.cfg" beforeDir="false" afterPath="$PROJECT_DIR$/stm32-bv_openocd.cfg" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/stm32f4xx_conf.h" beforeDir="false" afterPath="$PROJECT_DIR$/stm32f4xx_conf.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/terminal.c" beforeDir="false" afterPath="$PROJECT_DIR$/terminal.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/terminal.h" beforeDir="false" afterPath="$PROJECT_DIR$/terminal.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/tests/packet_recovery/Makefile" beforeDir="false" afterPath="$PROJECT_DIR$/tests/packet_recovery/Makefile" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/tests/packet_recovery/main.c" beforeDir="false" afterPath="$PROJECT_DIR$/tests/packet_recovery/main.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/timeout.c" beforeDir="false" afterPath="$PROJECT_DIR$/timeout.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/timeout.h" beforeDir="false" afterPath="$PROJECT_DIR$/timeout.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/timer.c" beforeDir="false" afterPath="$PROJECT_DIR$/timer.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/timer.h" beforeDir="false" afterPath="$PROJECT_DIR$/timer.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/utils.c" beforeDir="false" afterPath="$PROJECT_DIR$/utils.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/utils.h" beforeDir="false" afterPath="$PROJECT_DIR$/utils.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/virtual_motor.c" beforeDir="false" afterPath="$PROJECT_DIR$/virtual_motor.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/virtual_motor.h" beforeDir="false" afterPath="$PROJECT_DIR$/virtual_motor.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/worker.c" beforeDir="false" afterPath="$PROJECT_DIR$/worker.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/worker.h" beforeDir="false" afterPath="$PROJECT_DIR$/worker.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/ws2811.c" beforeDir="false" afterPath="$PROJECT_DIR$/ws2811.c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/ws2811.h" beforeDir="false" afterPath="$PROJECT_DIR$/ws2811.h" afterDir="false" />
+    </list>
+    <option name="SHOW_DIALOG" value="false" />
+    <option name="HIGHLIGHT_CONFLICTS" value="true" />
+    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
+    <option name="LAST_RESOLUTION" value="IGNORE" />
+  </component>
+  <component name="ChangesViewManager">
+    <option name="groupingKeys">
+      <option value="directory" />
+    </option>
+  </component>
+  <component name="ClangdSettings">
+    <option name="clangTidyViaClangd" value="false" />
+    <option name="formatViaClangd" value="false" />
+    <option name="clangWarnings" value="-Wno-unused-variable,-Wno-infinite-recursion,-Werror=implicit-function-declaratio,-Wshadow,-Wno-shadow-field-in-constructor-modified,-Wno-shadow-ivar,-Wuninitialized,-Wunused-label,-Wunused-lambda-capture,-Wno-double-promotion,-Wno-absolute-value,-Wno-enum-conversion" />
+  </component>
+  <component name="ExternalProjectsData">
+    <projectState path="$PROJECT_DIR$">
+      <ProjectState />
+    </projectState>
+  </component>
+  <component name="Git.Settings">
+    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
+  </component>
+  <component name="GitToolBoxStore">
+    <option name="projectConfigVersion" value="2" />
+  </component>
+  <component name="MakefileLocalSettings">
+    <option name="toolchainName" value="gcc-arm-none-embi-9" />
+    <option name="availableProjects">
+      <map>
+        <entry>
+          <key>
+            <ExternalProjectPojo>
+              <option name="name" value="bldc" />
+              <option name="path" value="$PROJECT_DIR$" />
+            </ExternalProjectPojo>
+          </key>
+          <value>
+            <list>
+              <ExternalProjectPojo>
+                <option name="name" value="bldc" />
+                <option name="path" value="$PROJECT_DIR$" />
+              </ExternalProjectPojo>
+            </list>
+          </value>
+        </entry>
+      </map>
+    </option>
+    <option name="projectSyncType">
+      <map>
+        <entry key="$PROJECT_DIR$" value="RE_IMPORT" />
+      </map>
+    </option>
+  </component>
+  <component name="ProjectId" id="1mSwPhCVHH0u6k70z1YdD8Qb3x0" />
+  <component name="ProjectLevelVcsManager" settingsEditedManually="true" />
+  <component name="ProjectViewState">
+    <option name="hideEmptyMiddlePackages" value="true" />
+    <option name="showLibraryContents" value="true" />
+  </component>
+  <component name="PropertiesComponent">
+    <property name="RunOnceActivity.OpenProjectViewOnStart" value="true" />
+    <property name="RunOnceActivity.ShowReadmeOnStart" value="true" />
+    <property name="SHARE_PROJECT_CONFIGURATION_FILES" value="true" />
+    <property name="WebServerToolWindowFactoryState" value="false" />
+    <property name="cf.first.check.clang-format" value="false" />
+    <property name="last_opened_file_path" value="$PROJECT_DIR$/../CppTest" />
+    <property name="node.js.detected.package.eslint" value="true" />
+    <property name="node.js.detected.package.tslint" value="true" />
+    <property name="node.js.path.for.package.eslint" value="project" />
+    <property name="node.js.path.for.package.tslint" value="project" />
+    <property name="node.js.selected.package.eslint" value="(autodetect)" />
+    <property name="node.js.selected.package.tslint" value="(autodetect)" />
+    <property name="settings.editor.selected.configurable" value="preferences.sourceCode" />
+  </component>
+  <component name="RunManager" selected="Makefile Application.all">
+    <configuration name="Makefile" type="CLionNativeAppRunConfigurationType" REDIRECT_INPUT="false" ELEVATE="false" PASS_PARENT_ENVS_2="true" PROJECT_NAME="bldc" TARGET_NAME="Makefile" CONFIG_NAME="Makefile" version="1">
+      <method v="2">
+        <option name="CLION.COMPOUND.BUILD" enabled="true" />
+      </method>
+    </configuration>
+    <configuration name="POST_MAKE_ALL_RULE_HOOK" type="CLionNativeAppRunConfigurationType" REDIRECT_INPUT="false" ELEVATE="false" PASS_PARENT_ENVS_2="true" PROJECT_NAME="bldc" TARGET_NAME="POST_MAKE_ALL_RULE_HOOK" CONFIG_NAME="POST_MAKE_ALL_RULE_HOOK" version="1">
+      <method v="2">
+        <option name="CLION.COMPOUND.BUILD" enabled="true" />
+      </method>
+    </configuration>
+    <configuration name="PRE_MAKE_ALL_RULE_HOOK" type="CLionNativeAppRunConfigurationType" REDIRECT_INPUT="false" ELEVATE="false" PASS_PARENT_ENVS_2="true" PROJECT_NAME="bldc" TARGET_NAME="PRE_MAKE_ALL_RULE_HOOK" CONFIG_NAME="PRE_MAKE_ALL_RULE_HOOK" version="1">
+      <method v="2">
+        <option name="CLION.COMPOUND.BUILD" enabled="true" />
+      </method>
+    </configuration>
+    <configuration name="all" type="CLionNativeAppRunConfigurationType" REDIRECT_INPUT="false" ELEVATE="false" PASS_PARENT_ENVS_2="true" PROJECT_NAME="bldc" TARGET_NAME="all" CONFIG_NAME="all" version="1">
+      <method v="2">
+        <option name="CLION.COMPOUND.BUILD" enabled="true" />
+      </method>
+    </configuration>
+    <configuration name="build" type="CLionNativeAppRunConfigurationType" REDIRECT_INPUT="false" ELEVATE="false" PASS_PARENT_ENVS_2="true" PROJECT_NAME="bldc" TARGET_NAME="build" CONFIG_NAME="build" version="1">
+      <method v="2">
+        <option name="CLION.COMPOUND.BUILD" enabled="true" />
+      </method>
+    </configuration>
+    <configuration name="clear_option_bytes" type="CLionNativeAppRunConfigurationType" REDIRECT_INPUT="false" ELEVATE="false" PASS_PARENT_ENVS_2="true" PROJECT_NAME="bldc" TARGET_NAME="clear_option_bytes" CONFIG_NAME="clear_option_bytes" version="1">
+      <method v="2">
+        <option name="CLION.COMPOUND.BUILD" enabled="true" />
+      </method>
+    </configuration>
+    <configuration name="debug-start" type="CLionNativeAppRunConfigurationType" REDIRECT_INPUT="false" ELEVATE="false" PASS_PARENT_ENVS_2="true" PROJECT_NAME="bldc" TARGET_NAME="debug-start" CONFIG_NAME="debug-start" version="1">
+      <method v="2">
+        <option name="CLION.COMPOUND.BUILD" enabled="true" />
+      </method>
+    </configuration>
+    <configuration name="lib" type="CLionNativeAppRunConfigurationType" REDIRECT_INPUT="false" ELEVATE="false" PASS_PARENT_ENVS_2="true" PROJECT_NAME="bldc" TARGET_NAME="lib" CONFIG_NAME="lib" version="1">
+      <method v="2">
+        <option name="CLION.COMPOUND.BUILD" enabled="true" />
+      </method>
+    </configuration>
+    <configuration name="upload-olimex" type="CLionNativeAppRunConfigurationType" REDIRECT_INPUT="false" ELEVATE="false" PASS_PARENT_ENVS_2="true" PROJECT_NAME="bldc" TARGET_NAME="upload-olimex" CONFIG_NAME="upload-olimex" version="1">
+      <method v="2">
+        <option name="CLION.COMPOUND.BUILD" enabled="true" />
+      </method>
+    </configuration>
+    <configuration name="upload-pi-remote" type="CLionNativeAppRunConfigurationType" REDIRECT_INPUT="false" ELEVATE="false" PASS_PARENT_ENVS_2="true" PROJECT_NAME="bldc" TARGET_NAME="upload-pi-remote" CONFIG_NAME="upload-pi-remote" version="1">
+      <method v="2">
+        <option name="CLION.COMPOUND.BUILD" enabled="true" />
+      </method>
+    </configuration>
+    <configuration name="upload-pi" type="CLionNativeAppRunConfigurationType" REDIRECT_INPUT="false" ELEVATE="false" PASS_PARENT_ENVS_2="true" PROJECT_NAME="bldc" TARGET_NAME="upload-pi" CONFIG_NAME="upload-pi" version="1">
+      <method v="2">
+        <option name="CLION.COMPOUND.BUILD" enabled="true" />
+      </method>
+    </configuration>
+    <configuration name="upload" type="CLionNativeAppRunConfigurationType" REDIRECT_INPUT="false" ELEVATE="false" PASS_PARENT_ENVS_2="true" PROJECT_NAME="bldc" TARGET_NAME="upload" CONFIG_NAME="upload" version="1">
+      <method v="2">
+        <option name="CLION.COMPOUND.BUILD" enabled="true" />
+      </method>
+    </configuration>
+    <configuration default="true" type="CMakeRunConfiguration" factoryName="Application" REDIRECT_INPUT="false" ELEVATE="false" PASS_PARENT_ENVS_2="true">
+      <method v="2">
+        <option name="com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask" enabled="true" />
+      </method>
+    </configuration>
+    <list>
+      <item itemvalue="Makefile Application.all" />
+      <item itemvalue="Makefile Application.build" />
+      <item itemvalue="Makefile Application.clear_option_bytes" />
+      <item itemvalue="Makefile Application.debug-start" />
+      <item itemvalue="Makefile Application.lib" />
+      <item itemvalue="Makefile Application.Makefile" />
+      <item itemvalue="Makefile Application.POST_MAKE_ALL_RULE_HOOK" />
+      <item itemvalue="Makefile Application.PRE_MAKE_ALL_RULE_HOOK" />
+      <item itemvalue="Makefile Application.upload" />
+      <item itemvalue="Makefile Application.upload-olimex" />
+      <item itemvalue="Makefile Application.upload-pi" />
+      <item itemvalue="Makefile Application.upload-pi-remote" />
+    </list>
+  </component>
+  <component name="SpellCheckerSettings" RuntimeDictionaries="0" Folders="0" CustomDictionaries="0" DefaultDictionary="application-level" UseSingleDictionary="true" transferred="true" />
+  <component name="SvnConfiguration">
+    <configuration>$USER_HOME$/.subversion</configuration>
+    <myIsUseDefaultProxy>true</myIsUseDefaultProxy>
+  </component>
+  <component name="TaskManager">
+    <task active="true" id="Default" summary="Default task">
+      <changelist id="a65eb43f-e36c-45c9-bc3b-94b7eaacf8ae" name="Default Changelist" comment="" />
+      <created>1609500279492</created>
+      <option name="number" value="Default" />
+      <option name="presentableId" value="Default" />
+      <updated>1609500279492</updated>
+      <workItem from="1609500281564" duration="6914000" />
+      <workItem from="1609510613705" duration="5041000" />
+      <workItem from="1609515662201" duration="30000" />
+      <workItem from="1609515699597" duration="159000" />
+      <workItem from="1609515866362" duration="6000" />
+      <workItem from="1609516644869" duration="3000" />
+      <workItem from="1609554913177" duration="2064000" />
+      <workItem from="1609560169676" duration="8580000" />
+      <workItem from="1609592538687" duration="887000" />
+    </task>
+    <servers />
+  </component>
+  <component name="TypeScriptGeneratedFilesManager">
+    <option name="version" value="3" />
+  </component>
+  <component name="Vcs.Log.Tabs.Properties">
+    <option name="TAB_STATES">
+      <map>
+        <entry key="MAIN">
+          <value>
+            <State />
+          </value>
+        </entry>
+      </map>
+    </option>
+  </component>
+  <component name="XSLT-Support.FileAssociations.UIState">
+    <expand />
+    <select />
+  </component>
+</project>
\ No newline at end of file
Index: .idea/bldc.iml
===================================================================
diff --git a/.idea/bldc.iml b/.idea/bldc.iml
new file mode 100644
--- /dev/null	
+++ b/.idea/bldc.iml	
@@ -0,0 +1,2 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module classpath="External" type="CPP_MODULE" version="4" />
\ No newline at end of file
Index: .idea/modules.xml
===================================================================
diff --git a/.idea/modules.xml b/.idea/modules.xml
new file mode 100644
--- /dev/null	
+++ b/.idea/modules.xml	
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectModuleManager">
+    <modules>
+      <module fileurl="file://$PROJECT_DIR$/.idea/bldc.iml" filepath="$PROJECT_DIR$/.idea/bldc.iml" />
+    </modules>
+  </component>
+</project>
\ No newline at end of file
Index: .idea/misc.xml
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
new file mode 100644
--- /dev/null	
+++ b/.idea/misc.xml	
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ExternalStorageConfigurationManager" enabled="true" />
+  <component name="MakefileSettings">
+    <option name="linkedExternalProjectsSettings">
+      <MakefileProjectSettings>
+        <option name="externalProjectPath" value="$PROJECT_DIR$" />
+        <option name="modules">
+          <set>
+            <option value="$PROJECT_DIR$" />
+          </set>
+        </option>
+        <option name="version" value="2" />
+      </MakefileProjectSettings>
+    </option>
+  </component>
+  <component name="MakefileWorkspace" PROJECT_DIR="$PROJECT_DIR$" />
+</project>
\ No newline at end of file
Index: .idea/vcs.xml
===================================================================
diff --git a/.idea/vcs.xml b/.idea/vcs.xml
new file mode 100644
--- /dev/null	
+++ b/.idea/vcs.xml	
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="VcsDirectoryMappings">
+    <mapping directory="$PROJECT_DIR$" vcs="Git" />
+  </component>
+</project>
\ No newline at end of file
Index: .idea/codeStyles/codeStyleConfig.xml
===================================================================
diff --git a/.idea/codeStyles/codeStyleConfig.xml b/.idea/codeStyles/codeStyleConfig.xml
new file mode 100644
--- /dev/null	
+++ b/.idea/codeStyles/codeStyleConfig.xml	
@@ -0,0 +1,5 @@
+<component name="ProjectCodeStyleConfiguration">
+  <state>
+    <option name="PREFERRED_PROJECT_CODE_STYLE" value="Default" />
+  </state>
+</component>
\ No newline at end of file
Index: .idea/inspectionProfiles/Project_Default.xml
===================================================================
diff --git a/.idea/inspectionProfiles/Project_Default.xml b/.idea/inspectionProfiles/Project_Default.xml
new file mode 100644
--- /dev/null	
+++ b/.idea/inspectionProfiles/Project_Default.xml	
@@ -0,0 +1,18 @@
+<component name="InspectionProjectProfileManager">
+  <profile version="1.0">
+    <option name="myName" value="Project Default" />
+    <inspection_tool class="ClangTidy" enabled="false" level="WARNING" enabled_by_default="false" />
+    <inspection_tool class="ImplicitIntegerAndEnumConversion" enabled="false" level="WARNING" enabled_by_default="false" />
+    <inspection_tool class="IncompatibleEnums" enabled="false" level="WARNING" enabled_by_default="false" />
+    <inspection_tool class="OCUnusedGlobalDeclaration" enabled="false" level="WARNING" enabled_by_default="false" />
+    <inspection_tool class="OCUnusedIncludeDirective" enabled="false" level="WARNING" enabled_by_default="false" />
+    <inspection_tool class="RedundantCast" enabled="false" level="WARNING" enabled_by_default="false" />
+    <inspection_tool class="SignednessMismatch" enabled="false" level="WARNING" enabled_by_default="false" />
+    <inspection_tool class="SpellCheckingInspection" enabled="false" level="TYPO" enabled_by_default="false">
+      <option name="processCode" value="true" />
+      <option name="processLiterals" value="true" />
+      <option name="processComments" value="true" />
+    </inspection_tool>
+    <inspection_tool class="ValueMayNotFitIntoReceiver" enabled="false" level="WARNING" enabled_by_default="false" />
+  </profile>
+</component>
\ No newline at end of file
Index: .vscode/c_cpp_properties.json
===================================================================
diff --git a/.vscode/c_cpp_properties.json b/.vscode/c_cpp_properties.json
new file mode 100644
--- /dev/null	
+++ b/.vscode/c_cpp_properties.json	
@@ -0,0 +1,16 @@
+{
+    "configurations": [
+        {
+            "name": "Linux",
+            "includePath": [
+                "${workspaceFolder}/**"
+            ],
+            "defines": [],
+            "compilerPath": "/usr/bin/arm-none-eabi-g++",
+            "cStandard": "gnu99",
+            "cppStandard": "c++14",
+            "intelliSenseMode": "gcc-arm"
+        }
+    ],
+    "version": 4
+}
\ No newline at end of file
Index: .gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>*~\n\nbuild\n.dep\n.project\n.cproject\n.settings/language.settings.xml\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.gitignore b/.gitignore
--- a/.gitignore	
+++ b/.gitignore	
@@ -5,3 +5,4 @@
 .project
 .cproject
 .settings/language.settings.xml
+/VSGDB_Project/
